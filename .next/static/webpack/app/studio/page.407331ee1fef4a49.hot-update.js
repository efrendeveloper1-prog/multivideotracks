"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./utils/audioAnalysis.ts":
/*!********************************!*\
  !*** ./utils/audioAnalysis.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeAudio: function() { return /* binding */ analyzeAudio; }\n/* harmony export */ });\n/* harmony import */ var web_audio_beat_detector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web-audio-beat-detector */ \"(app-pages-browser)/./node_modules/web-audio-beat-detector/build/es2019/module.js\");\n/**\r\n * Audio analysis utilities for BPM and musical key detection.\r\n * Uses web-audio-beat-detector for BPM and spectral analysis for key.\r\n */ \n// Musical key names  \nconst KEY_NAMES = [\n    \"C\",\n    \"C#\",\n    \"D\",\n    \"D#\",\n    \"E\",\n    \"F\",\n    \"F#\",\n    \"G\",\n    \"G#\",\n    \"A\",\n    \"A#\",\n    \"B\"\n];\n// Krumhansl-Kessler key profiles for major and minor keys\nconst MAJOR_PROFILE = [\n    6.35,\n    2.23,\n    3.48,\n    2.33,\n    4.38,\n    4.09,\n    2.52,\n    5.19,\n    2.39,\n    3.66,\n    2.29,\n    2.88\n];\nconst MINOR_PROFILE = [\n    6.33,\n    2.68,\n    3.52,\n    5.38,\n    2.60,\n    3.53,\n    2.54,\n    4.75,\n    3.98,\n    2.69,\n    3.34,\n    3.17\n];\n/**\r\n * Detect BPM from an AudioBuffer using web-audio-beat-detector.\r\n */ async function detectBPM(buffer) {\n    try {\n        const result = await (0,web_audio_beat_detector__WEBPACK_IMPORTED_MODULE_0__.guess)(buffer);\n        return Math.round(result.bpm);\n    } catch (e) {\n        console.warn(\"BPM detection failed, trying fallback:\", e);\n        try {\n            const result = await (0,web_audio_beat_detector__WEBPACK_IMPORTED_MODULE_0__.guess)(buffer, 0, Math.min(buffer.duration, 15));\n            return Math.round(result.bpm);\n        } catch (e) {\n            return 0;\n        }\n    }\n}\n/**\r\n * Detect musical key using FFT-based chromagram analysis.\r\n * Uses OfflineAudioContext + AnalyserNode for efficient FFT.\r\n */ async function detectKey(buffer) {\n    const sampleRate = buffer.sampleRate;\n    const channelData = buffer.getChannelData(0);\n    // Create offline context to use AnalyserNode for FFT\n    const fftSize = 4096;\n    const chromagram = new Float64Array(12).fill(0);\n    // Sample multiple windows across the track\n    const totalFrames = channelData.length;\n    const windowCount = Math.min(80, Math.floor(totalFrames / fftSize));\n    const hopSize = Math.floor(totalFrames / windowCount);\n    for(let w = 0; w < windowCount; w++){\n        const start = w * hopSize;\n        const end = Math.min(start + fftSize, totalFrames);\n        const segLen = end - start;\n        // Apply Hanning window and compute power spectrum via simple FFT\n        const windowed = new Float32Array(fftSize);\n        for(let i = 0; i < segLen; i++){\n            windowed[i] = channelData[start + i] * (0.5 - 0.5 * Math.cos(2 * Math.PI * i / (segLen - 1)));\n        }\n        // Compute magnitude spectrum using correlation with known note frequencies\n        // Instead of full DFT, just check the 12 chroma pitch classes\n        for(let note = 0; note < 12; note++){\n            // Check multiple octaves (2 through 6)\n            for(let octave = 2; octave <= 6; octave++){\n                const freq = 440 * Math.pow(2, (note - 9 + (octave - 4) * 12) / 12);\n                const bin = Math.round(freq * fftSize / sampleRate);\n                if (bin <= 0 || bin >= fftSize / 2) continue;\n                // Goertzel algorithm for single frequency magnitude â€” O(N) per frequency\n                const k = bin;\n                const w0 = 2 * Math.PI * k / fftSize;\n                const coeff = 2 * Math.cos(w0);\n                let s0 = 0, s1 = 0, s2 = 0;\n                for(let i = 0; i < fftSize; i++){\n                    s0 = windowed[i] + coeff * s1 - s2;\n                    s2 = s1;\n                    s1 = s0;\n                }\n                const magnitude = Math.sqrt(s1 * s1 + s2 * s2 - coeff * s1 * s2);\n                chromagram[note] += magnitude;\n            }\n        }\n    }\n    // Normalize chromagram\n    const maxChroma = Math.max(...chromagram);\n    if (maxChroma > 0) {\n        for(let i = 0; i < 12; i++){\n            chromagram[i] /= maxChroma;\n        }\n    }\n    // Correlate with key profiles (Krumhansl-Kessler)\n    let bestCorrelation = -Infinity;\n    let bestKey = 0;\n    let bestScale = \"Major\";\n    for(let key = 0; key < 12; key++){\n        const rotated = new Float64Array(12);\n        for(let i = 0; i < 12; i++){\n            rotated[i] = chromagram[(i + key) % 12];\n        }\n        const majorCorr = correlate(rotated, MAJOR_PROFILE);\n        if (majorCorr > bestCorrelation) {\n            bestCorrelation = majorCorr;\n            bestKey = key;\n            bestScale = \"Major\";\n        }\n        const minorCorr = correlate(rotated, MINOR_PROFILE);\n        if (minorCorr > bestCorrelation) {\n            bestCorrelation = minorCorr;\n            bestKey = key;\n            bestScale = \"Minor\";\n        }\n    }\n    const keyName = KEY_NAMES[bestKey];\n    const displayKey = keyName.includes(\"#\") ? toFlat(keyName) : keyName;\n    const display = bestScale === \"Minor\" ? \"\".concat(displayKey, \"m\") : displayKey;\n    return {\n        key: displayKey,\n        scale: bestScale,\n        display\n    };\n}\n/**\r\n * Pearson correlation coefficient\r\n */ function correlate(a, b) {\n    const n = a.length;\n    let sumA = 0, sumB = 0, sumAB = 0, sumA2 = 0, sumB2 = 0;\n    for(let i = 0; i < n; i++){\n        sumA += a[i];\n        sumB += b[i];\n        sumAB += a[i] * b[i];\n        sumA2 += a[i] * a[i];\n        sumB2 += b[i] * b[i];\n    }\n    const num = n * sumAB - sumA * sumB;\n    const den = Math.sqrt((n * sumA2 - sumA * sumA) * (n * sumB2 - sumB * sumB));\n    return den === 0 ? 0 : num / den;\n}\n/**\r\n * Convert sharp notation to flat notation where conventional\r\n */ function toFlat(note) {\n    const map = {\n        \"C#\": \"Db\",\n        \"D#\": \"Eb\",\n        \"F#\": \"F#\",\n        \"G#\": \"Ab\",\n        \"A#\": \"Bb\"\n    };\n    return map[note] || note;\n}\n/**\r\n * Perform full audio analysis (BPM + Key) on an AudioBuffer.\r\n */ async function analyzeAudio(buffer) {\n    const [bpm, keyResult] = await Promise.all([\n        detectBPM(buffer),\n        detectKey(buffer)\n    ]);\n    return {\n        bpm,\n        key: keyResult.key,\n        scale: keyResult.scale,\n        keyDisplay: keyResult.display\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2F1ZGlvQW5hbHlzaXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FFK0M7QUFFaEQsc0JBQXNCO0FBQ3RCLE1BQU1DLFlBQVk7SUFBQztJQUFLO0lBQU07SUFBSztJQUFNO0lBQUs7SUFBSztJQUFNO0lBQUs7SUFBTTtJQUFLO0lBQU07Q0FBSTtBQUVuRiwwREFBMEQ7QUFDMUQsTUFBTUMsZ0JBQWdCO0lBQUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFDOUYsTUFBTUMsZ0JBQWdCO0lBQUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFTOUY7O0NBRUMsR0FDRCxlQUFlQyxVQUFVQyxNQUFtQjtJQUN4QyxJQUFJO1FBQ0EsTUFBTUMsU0FBUyxNQUFNTiw4REFBS0EsQ0FBQ0s7UUFDM0IsT0FBT0UsS0FBS0MsS0FBSyxDQUFDRixPQUFPRyxHQUFHO0lBQ2hDLEVBQUUsT0FBT0MsR0FBRztRQUNSQyxRQUFRQyxJQUFJLENBQUMsMENBQTBDRjtRQUN2RCxJQUFJO1lBQ0EsTUFBTUosU0FBUyxNQUFNTiw4REFBS0EsQ0FBQ0ssUUFBUSxHQUFHRSxLQUFLTSxHQUFHLENBQUNSLE9BQU9TLFFBQVEsRUFBRTtZQUNoRSxPQUFPUCxLQUFLQyxLQUFLLENBQUNGLE9BQU9HLEdBQUc7UUFDaEMsRUFBRSxVQUFNO1lBQ0osT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUVBOzs7Q0FHQyxHQUNELGVBQWVNLFVBQVVWLE1BQW1CO0lBQ3hDLE1BQU1XLGFBQWFYLE9BQU9XLFVBQVU7SUFDcEMsTUFBTUMsY0FBY1osT0FBT2EsY0FBYyxDQUFDO0lBRTFDLHFEQUFxRDtJQUNyRCxNQUFNQyxVQUFVO0lBQ2hCLE1BQU1DLGFBQWEsSUFBSUMsYUFBYSxJQUFJQyxJQUFJLENBQUM7SUFFN0Ms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QyxNQUFNO1FBQU0sTUFBTTtRQUFNLE1BQU07UUFBTSxNQUFNO1FBQU0sTUFBTTtJQUMxRDtJQUNBLE9BQU9BLEdBQUcsQ0FBQ3hDLEtBQUssSUFBSUE7QUFDeEI7QUFFQTs7Q0FFQyxHQUNNLGVBQWV5QyxhQUFhekUsTUFBbUI7SUFDbEQsTUFBTSxDQUFDSSxLQUFLc0UsVUFBVSxHQUFHLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztRQUN2QzdFLFVBQVVDO1FBQ1ZVLFVBQVVWO0tBQ2I7SUFFRCxPQUFPO1FBQ0hJO1FBQ0ErQyxLQUFLdUIsVUFBVXZCLEdBQUc7UUFDbEJVLE9BQU9hLFVBQVViLEtBQUs7UUFDdEJnQixZQUFZSCxVQUFVZCxPQUFPO0lBQ2pDO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvYXVkaW9BbmFseXNpcy50cz80OTliIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBdWRpbyBhbmFseXNpcyB1dGlsaXRpZXMgZm9yIEJQTSBhbmQgbXVzaWNhbCBrZXkgZGV0ZWN0aW9uLlxyXG4gKiBVc2VzIHdlYi1hdWRpby1iZWF0LWRldGVjdG9yIGZvciBCUE0gYW5kIHNwZWN0cmFsIGFuYWx5c2lzIGZvciBrZXkuXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgZ3Vlc3MgfSBmcm9tICd3ZWItYXVkaW8tYmVhdC1kZXRlY3Rvcic7XHJcblxyXG4vLyBNdXNpY2FsIGtleSBuYW1lcyAgXHJcbmNvbnN0IEtFWV9OQU1FUyA9IFsnQycsICdDIycsICdEJywgJ0QjJywgJ0UnLCAnRicsICdGIycsICdHJywgJ0cjJywgJ0EnLCAnQSMnLCAnQiddO1xyXG5cclxuLy8gS3J1bWhhbnNsLUtlc3NsZXIga2V5IHByb2ZpbGVzIGZvciBtYWpvciBhbmQgbWlub3Iga2V5c1xyXG5jb25zdCBNQUpPUl9QUk9GSUxFID0gWzYuMzUsIDIuMjMsIDMuNDgsIDIuMzMsIDQuMzgsIDQuMDksIDIuNTIsIDUuMTksIDIuMzksIDMuNjYsIDIuMjksIDIuODhdO1xyXG5jb25zdCBNSU5PUl9QUk9GSUxFID0gWzYuMzMsIDIuNjgsIDMuNTIsIDUuMzgsIDIuNjAsIDMuNTMsIDIuNTQsIDQuNzUsIDMuOTgsIDIuNjksIDMuMzQsIDMuMTddO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBdWRpb0FuYWx5c2lzIHtcclxuICAgIGJwbTogbnVtYmVyO1xyXG4gICAga2V5OiBzdHJpbmc7ICAgICAgIC8vIGUuZy4gXCJDXCIsIFwiRiNcIiwgXCJCYlwiXHJcbiAgICBzY2FsZTogc3RyaW5nOyAgICAgLy8gXCJNYWpvclwiIG9yIFwiTWlub3JcIlxyXG4gICAga2V5RGlzcGxheTogc3RyaW5nOyAvLyBlLmcuIFwiQyBNYWpvclwiLCBcIkYjbVwiXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgQlBNIGZyb20gYW4gQXVkaW9CdWZmZXIgdXNpbmcgd2ViLWF1ZGlvLWJlYXQtZGV0ZWN0b3IuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RCUE0oYnVmZmVyOiBBdWRpb0J1ZmZlcik6IFByb21pc2U8bnVtYmVyPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGd1ZXNzKGJ1ZmZlcik7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocmVzdWx0LmJwbSk7XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdCUE0gZGV0ZWN0aW9uIGZhaWxlZCwgdHJ5aW5nIGZhbGxiYWNrOicsIGUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGd1ZXNzKGJ1ZmZlciwgMCwgTWF0aC5taW4oYnVmZmVyLmR1cmF0aW9uLCAxNSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChyZXN1bHQuYnBtKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGV0ZWN0IG11c2ljYWwga2V5IHVzaW5nIEZGVC1iYXNlZCBjaHJvbWFncmFtIGFuYWx5c2lzLlxyXG4gKiBVc2VzIE9mZmxpbmVBdWRpb0NvbnRleHQgKyBBbmFseXNlck5vZGUgZm9yIGVmZmljaWVudCBGRlQuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RLZXkoYnVmZmVyOiBBdWRpb0J1ZmZlcik6IFByb21pc2U8eyBrZXk6IHN0cmluZzsgc2NhbGU6IHN0cmluZzsgZGlzcGxheTogc3RyaW5nIH0+IHtcclxuICAgIGNvbnN0IHNhbXBsZVJhdGUgPSBidWZmZXIuc2FtcGxlUmF0ZTtcclxuICAgIGNvbnN0IGNoYW5uZWxEYXRhID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xyXG5cclxuICAgIC8vIENyZWF0ZSBvZmZsaW5lIGNvbnRleHQgdG8gdXNlIEFuYWx5c2VyTm9kZSBmb3IgRkZUXHJcbiAgICBjb25zdCBmZnRTaXplID0gNDA5NjtcclxuICAgIGNvbnN0IGNocm9tYWdyYW0gPSBuZXcgRmxvYXQ2NEFycmF5KDEyKS5maWxsKDApO1xyXG5cclxuICAgIC8vIFNhbXBsZSBtdWx0aXBsZSB3aW5kb3dzIGFjcm9zcyB0aGUgdHJhY2tcclxuICAgIGNvbnN0IHRvdGFsRnJhbWVzID0gY2hhbm5lbERhdGEubGVuZ3RoO1xyXG4gICAgY29uc3Qgd2luZG93Q291bnQgPSBNYXRoLm1pbig4MCwgTWF0aC5mbG9vcih0b3RhbEZyYW1lcyAvIGZmdFNpemUpKTtcclxuICAgIGNvbnN0IGhvcFNpemUgPSBNYXRoLmZsb29yKHRvdGFsRnJhbWVzIC8gd2luZG93Q291bnQpO1xyXG5cclxuICAgIGZvciAobGV0IHcgPSAwOyB3IDwgd2luZG93Q291bnQ7IHcrKykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdyAqIGhvcFNpemU7XHJcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBmZnRTaXplLCB0b3RhbEZyYW1lcyk7XHJcbiAgICAgICAgY29uc3Qgc2VnTGVuID0gZW5kIC0gc3RhcnQ7XHJcblxyXG4gICAgICAgIC8vIEFwcGx5IEhhbm5pbmcgd2luZG93IGFuZCBjb21wdXRlIHBvd2VyIHNwZWN0cnVtIHZpYSBzaW1wbGUgRkZUXHJcbiAgICAgICAgY29uc3Qgd2luZG93ZWQgPSBuZXcgRmxvYXQzMkFycmF5KGZmdFNpemUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnTGVuOyBpKyspIHtcclxuICAgICAgICAgICAgd2luZG93ZWRbaV0gPSBjaGFubmVsRGF0YVtzdGFydCArIGldICogKDAuNSAtIDAuNSAqIE1hdGguY29zKDIgKiBNYXRoLlBJICogaSAvIChzZWdMZW4gLSAxKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29tcHV0ZSBtYWduaXR1ZGUgc3BlY3RydW0gdXNpbmcgY29ycmVsYXRpb24gd2l0aCBrbm93biBub3RlIGZyZXF1ZW5jaWVzXHJcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBmdWxsIERGVCwganVzdCBjaGVjayB0aGUgMTIgY2hyb21hIHBpdGNoIGNsYXNzZXNcclxuICAgICAgICBmb3IgKGxldCBub3RlID0gMDsgbm90ZSA8IDEyOyBub3RlKyspIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgbXVsdGlwbGUgb2N0YXZlcyAoMiB0aHJvdWdoIDYpXHJcbiAgICAgICAgICAgIGZvciAobGV0IG9jdGF2ZSA9IDI7IG9jdGF2ZSA8PSA2OyBvY3RhdmUrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJlcSA9IDQ0MCAqIE1hdGgucG93KDIsIChub3RlIC0gOSArIChvY3RhdmUgLSA0KSAqIDEyKSAvIDEyKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJpbiA9IE1hdGgucm91bmQoZnJlcSAqIGZmdFNpemUgLyBzYW1wbGVSYXRlKTtcclxuICAgICAgICAgICAgICAgIGlmIChiaW4gPD0gMCB8fCBiaW4gPj0gZmZ0U2l6ZSAvIDIpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEdvZXJ0emVsIGFsZ29yaXRobSBmb3Igc2luZ2xlIGZyZXF1ZW5jeSBtYWduaXR1ZGUg4oCUIE8oTikgcGVyIGZyZXF1ZW5jeVxyXG4gICAgICAgICAgICAgICAgY29uc3QgayA9IGJpbjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHcwID0gMiAqIE1hdGguUEkgKiBrIC8gZmZ0U2l6ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZWZmID0gMiAqIE1hdGguY29zKHcwKTtcclxuICAgICAgICAgICAgICAgIGxldCBzMCA9IDAsIHMxID0gMCwgczIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmZ0U2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgczAgPSB3aW5kb3dlZFtpXSArIGNvZWZmICogczEgLSBzMjtcclxuICAgICAgICAgICAgICAgICAgICBzMiA9IHMxO1xyXG4gICAgICAgICAgICAgICAgICAgIHMxID0gczA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFnbml0dWRlID0gTWF0aC5zcXJ0KHMxICogczEgKyBzMiAqIHMyIC0gY29lZmYgKiBzMSAqIHMyKTtcclxuICAgICAgICAgICAgICAgIGNocm9tYWdyYW1bbm90ZV0gKz0gbWFnbml0dWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vcm1hbGl6ZSBjaHJvbWFncmFtXHJcbiAgICBjb25zdCBtYXhDaHJvbWEgPSBNYXRoLm1heCguLi5jaHJvbWFncmFtKTtcclxuICAgIGlmIChtYXhDaHJvbWEgPiAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNocm9tYWdyYW1baV0gLz0gbWF4Q2hyb21hO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb3JyZWxhdGUgd2l0aCBrZXkgcHJvZmlsZXMgKEtydW1oYW5zbC1LZXNzbGVyKVxyXG4gICAgbGV0IGJlc3RDb3JyZWxhdGlvbiA9IC1JbmZpbml0eTtcclxuICAgIGxldCBiZXN0S2V5ID0gMDtcclxuICAgIGxldCBiZXN0U2NhbGUgPSAnTWFqb3InO1xyXG5cclxuICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IDEyOyBrZXkrKykge1xyXG4gICAgICAgIGNvbnN0IHJvdGF0ZWQgPSBuZXcgRmxvYXQ2NEFycmF5KDEyKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgcm90YXRlZFtpXSA9IGNocm9tYWdyYW1bKGkgKyBrZXkpICUgMTJdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbWFqb3JDb3JyID0gY29ycmVsYXRlKHJvdGF0ZWQsIE1BSk9SX1BST0ZJTEUpO1xyXG4gICAgICAgIGlmIChtYWpvckNvcnIgPiBiZXN0Q29ycmVsYXRpb24pIHtcclxuICAgICAgICAgICAgYmVzdENvcnJlbGF0aW9uID0gbWFqb3JDb3JyO1xyXG4gICAgICAgICAgICBiZXN0S2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBiZXN0U2NhbGUgPSAnTWFqb3InO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbWlub3JDb3JyID0gY29ycmVsYXRlKHJvdGF0ZWQsIE1JTk9SX1BST0ZJTEUpO1xyXG4gICAgICAgIGlmIChtaW5vckNvcnIgPiBiZXN0Q29ycmVsYXRpb24pIHtcclxuICAgICAgICAgICAgYmVzdENvcnJlbGF0aW9uID0gbWlub3JDb3JyO1xyXG4gICAgICAgICAgICBiZXN0S2V5ID0ga2V5O1xyXG4gICAgICAgICAgICBiZXN0U2NhbGUgPSAnTWlub3InO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBrZXlOYW1lID0gS0VZX05BTUVTW2Jlc3RLZXldO1xyXG4gICAgY29uc3QgZGlzcGxheUtleSA9IGtleU5hbWUuaW5jbHVkZXMoJyMnKSA/IHRvRmxhdChrZXlOYW1lKSA6IGtleU5hbWU7XHJcbiAgICBjb25zdCBkaXNwbGF5ID0gYmVzdFNjYWxlID09PSAnTWlub3InID8gYCR7ZGlzcGxheUtleX1tYCA6IGRpc3BsYXlLZXk7XHJcblxyXG4gICAgcmV0dXJuIHsga2V5OiBkaXNwbGF5S2V5LCBzY2FsZTogYmVzdFNjYWxlLCBkaXNwbGF5IH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZWFyc29uIGNvcnJlbGF0aW9uIGNvZWZmaWNpZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBjb3JyZWxhdGUoYTogRmxvYXQ2NEFycmF5LCBiOiBudW1iZXJbXSk6IG51bWJlciB7XHJcbiAgICBjb25zdCBuID0gYS5sZW5ndGg7XHJcbiAgICBsZXQgc3VtQSA9IDAsIHN1bUIgPSAwLCBzdW1BQiA9IDAsIHN1bUEyID0gMCwgc3VtQjIgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICBzdW1BICs9IGFbaV07XHJcbiAgICAgICAgc3VtQiArPSBiW2ldO1xyXG4gICAgICAgIHN1bUFCICs9IGFbaV0gKiBiW2ldO1xyXG4gICAgICAgIHN1bUEyICs9IGFbaV0gKiBhW2ldO1xyXG4gICAgICAgIHN1bUIyICs9IGJbaV0gKiBiW2ldO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbnVtID0gbiAqIHN1bUFCIC0gc3VtQSAqIHN1bUI7XHJcbiAgICBjb25zdCBkZW4gPSBNYXRoLnNxcnQoKG4gKiBzdW1BMiAtIHN1bUEgKiBzdW1BKSAqIChuICogc3VtQjIgLSBzdW1CICogc3VtQikpO1xyXG4gICAgcmV0dXJuIGRlbiA9PT0gMCA/IDAgOiBudW0gLyBkZW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHNoYXJwIG5vdGF0aW9uIHRvIGZsYXQgbm90YXRpb24gd2hlcmUgY29udmVudGlvbmFsXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0ZsYXQobm90ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IG1hcDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICAgICAnQyMnOiAnRGInLCAnRCMnOiAnRWInLCAnRiMnOiAnRiMnLCAnRyMnOiAnQWInLCAnQSMnOiAnQmInXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIG1hcFtub3RlXSB8fCBub3RlO1xyXG59XHJcblxyXG4vKipcclxuICogUGVyZm9ybSBmdWxsIGF1ZGlvIGFuYWx5c2lzIChCUE0gKyBLZXkpIG9uIGFuIEF1ZGlvQnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFuYWx5emVBdWRpbyhidWZmZXI6IEF1ZGlvQnVmZmVyKTogUHJvbWlzZTxBdWRpb0FuYWx5c2lzPiB7XHJcbiAgICBjb25zdCBbYnBtLCBrZXlSZXN1bHRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgIGRldGVjdEJQTShidWZmZXIpLFxyXG4gICAgICAgIGRldGVjdEtleShidWZmZXIpXHJcbiAgICBdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGJwbSxcclxuICAgICAgICBrZXk6IGtleVJlc3VsdC5rZXksXHJcbiAgICAgICAgc2NhbGU6IGtleVJlc3VsdC5zY2FsZSxcclxuICAgICAgICBrZXlEaXNwbGF5OiBrZXlSZXN1bHQuZGlzcGxheVxyXG4gICAgfTtcclxufVxyXG4iXSwibmFtZXMiOlsiZ3Vlc3MiLCJLRVlfTkFNRVMiLCJNQUpPUl9QUk9GSUxFIiwiTUlOT1JfUFJPRklMRSIsImRldGVjdEJQTSIsImJ1ZmZlciIsInJlc3VsdCIsIk1hdGgiLCJyb3VuZCIsImJwbSIsImUiLCJjb25zb2xlIiwid2FybiIsIm1pbiIsImR1cmF0aW9uIiwiZGV0ZWN0S2V5Iiwic2FtcGxlUmF0ZSIsImNoYW5uZWxEYXRhIiwiZ2V0Q2hhbm5lbERhdGEiLCJmZnRTaXplIiwiY2hyb21hZ3JhbSIsIkZsb2F0NjRBcnJheSIsImZpbGwiLCJ0b3RhbEZyYW1lcyIsImxlbmd0aCIsIndpbmRvd0NvdW50IiwiZmxvb3IiLCJob3BTaXplIiwidyIsInN0YXJ0IiwiZW5kIiwic2VnTGVuIiwid2luZG93ZWQiLCJGbG9hdDMyQXJyYXkiLCJpIiwiY29zIiwiUEkiLCJub3RlIiwib2N0YXZlIiwiZnJlcSIsInBvdyIsImJpbiIsImsiLCJ3MCIsImNvZWZmIiwiczAiLCJzMSIsInMyIiwibWFnbml0dWRlIiwic3FydCIsIm1heENocm9tYSIsIm1heCIsImJlc3RDb3JyZWxhdGlvbiIsIkluZmluaXR5IiwiYmVzdEtleSIsImJlc3RTY2FsZSIsImtleSIsInJvdGF0ZWQiLCJtYWpvckNvcnIiLCJjb3JyZWxhdGUiLCJtaW5vckNvcnIiLCJrZXlOYW1lIiwiZGlzcGxheUtleSIsImluY2x1ZGVzIiwidG9GbGF0IiwiZGlzcGxheSIsInNjYWxlIiwiYSIsImIiLCJuIiwic3VtQSIsInN1bUIiLCJzdW1BQiIsInN1bUEyIiwic3VtQjIiLCJudW0iLCJkZW4iLCJtYXAiLCJhbmFseXplQXVkaW8iLCJrZXlSZXN1bHQiLCJQcm9taXNlIiwiYWxsIiwia2V5RGlzcGxheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/audioAnalysis.ts\n"));

/***/ })

});