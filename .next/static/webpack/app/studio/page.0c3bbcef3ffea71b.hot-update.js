"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./utils/audioAnalysis.ts":
/*!********************************!*\
  !*** ./utils/audioAnalysis.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analyzeAudio: function() { return /* binding */ analyzeAudio; }\n/* harmony export */ });\n/* harmony import */ var web_audio_beat_detector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! web-audio-beat-detector */ \"(app-pages-browser)/./node_modules/web-audio-beat-detector/build/es2019/module.js\");\n/**\r\n * Audio analysis utilities for BPM and musical key detection.\r\n * Uses web-audio-beat-detector for BPM and spectral analysis for key.\r\n */ \n// Musical key names  \nconst KEY_NAMES = [\n    \"C\",\n    \"C#\",\n    \"D\",\n    \"D#\",\n    \"E\",\n    \"F\",\n    \"F#\",\n    \"G\",\n    \"G#\",\n    \"A\",\n    \"A#\",\n    \"B\"\n];\n// Krumhansl-Kessler key profiles for major and minor keys\nconst MAJOR_PROFILE = [\n    6.35,\n    2.23,\n    3.48,\n    2.33,\n    4.38,\n    4.09,\n    2.52,\n    5.19,\n    2.39,\n    3.66,\n    2.29,\n    2.88\n];\nconst MINOR_PROFILE = [\n    6.33,\n    2.68,\n    3.52,\n    5.38,\n    2.60,\n    3.53,\n    2.54,\n    4.75,\n    3.98,\n    2.69,\n    3.34,\n    3.17\n];\n/**\r\n * Detect BPM from an AudioBuffer using web-audio-beat-detector.\r\n */ async function detectBPM(buffer) {\n    try {\n        const result = await (0,web_audio_beat_detector__WEBPACK_IMPORTED_MODULE_0__.guess)(buffer);\n        return Math.round(result.bpm);\n    } catch (e) {\n        console.warn(\"BPM detection failed, trying fallback:\", e);\n        try {\n            const result = await (0,web_audio_beat_detector__WEBPACK_IMPORTED_MODULE_0__.guess)(buffer, 0, Math.min(buffer.duration, 15));\n            return Math.round(result.bpm);\n        } catch (e) {\n            return 0;\n        }\n    }\n}\n/**\r\n * Detect musical key using FFT-based chromagram analysis.\r\n * Uses OfflineAudioContext + AnalyserNode for efficient FFT.\r\n */ async function detectKey(buffer) {\n    const sampleRate = buffer.sampleRate;\n    const channelData = buffer.getChannelData(0);\n    // Create offline context to use AnalyserNode for FFT\n    const fftSize = 4096;\n    const chromagram = new Float64Array(12).fill(0);\n    // Sample multiple windows across the track\n    const totalFrames = channelData.length;\n    const windowCount = Math.min(80, Math.floor(totalFrames / fftSize));\n    const hopSize = Math.floor(totalFrames / windowCount);\n    for(let w = 0; w < windowCount; w++){\n        const start = w * hopSize;\n        const end = Math.min(start + fftSize, totalFrames);\n        const segLen = end - start;\n        // Apply Hanning window and compute power spectrum via simple FFT\n        const windowed = new Float32Array(fftSize);\n        for(let i = 0; i < segLen; i++){\n            windowed[i] = channelData[start + i] * (0.5 - 0.5 * Math.cos(2 * Math.PI * i / (segLen - 1)));\n        }\n        // Compute magnitude spectrum using correlation with known note frequencies\n        // Instead of full DFT, just check the 12 chroma pitch classes\n        for(let note = 0; note < 12; note++){\n            // Check multiple octaves (2 through 6)\n            for(let octave = 2; octave <= 6; octave++){\n                const freq = 440 * Math.pow(2, (note - 9 + (octave - 4) * 12) / 12);\n                const bin = Math.round(freq * fftSize / sampleRate);\n                if (bin <= 0 || bin >= fftSize / 2) continue;\n                // Goertzel algorithm for single frequency magnitude â€” O(N) per frequency\n                const k = bin;\n                const w0 = 2 * Math.PI * k / fftSize;\n                const coeff = 2 * Math.cos(w0);\n                let s0 = 0, s1 = 0, s2 = 0;\n                for(let i = 0; i < fftSize; i++){\n                    s0 = windowed[i] + coeff * s1 - s2;\n                    s2 = s1;\n                    s1 = s0;\n                }\n                const magnitude = Math.sqrt(s1 * s1 + s2 * s2 - coeff * s1 * s2);\n                chromagram[note] += magnitude;\n            }\n        }\n    }\n    // Normalize chromagram\n    const maxChroma = chromagram.reduce((acc, v)=>v > acc ? v : acc, 0);\n    if (maxChroma > 0) {\n        for(let i = 0; i < 12; i++){\n            chromagram[i] /= maxChroma;\n        }\n    }\n    // Correlate with key profiles (Krumhansl-Kessler)\n    let bestCorrelation = -Infinity;\n    let bestKey = 0;\n    let bestScale = \"Major\";\n    for(let key = 0; key < 12; key++){\n        const rotated = new Float64Array(12);\n        for(let i = 0; i < 12; i++){\n            rotated[i] = chromagram[(i + key) % 12];\n        }\n        const majorCorr = correlate(rotated, MAJOR_PROFILE);\n        if (majorCorr > bestCorrelation) {\n            bestCorrelation = majorCorr;\n            bestKey = key;\n            bestScale = \"Major\";\n        }\n        const minorCorr = correlate(rotated, MINOR_PROFILE);\n        if (minorCorr > bestCorrelation) {\n            bestCorrelation = minorCorr;\n            bestKey = key;\n            bestScale = \"Minor\";\n        }\n    }\n    const keyName = KEY_NAMES[bestKey];\n    const displayKey = keyName.includes(\"#\") ? toFlat(keyName) : keyName;\n    const display = bestScale === \"Minor\" ? \"\".concat(displayKey, \"m\") : displayKey;\n    return {\n        key: displayKey,\n        scale: bestScale,\n        display\n    };\n}\n/**\r\n * Pearson correlation coefficient\r\n */ function correlate(a, b) {\n    const n = a.length;\n    let sumA = 0, sumB = 0, sumAB = 0, sumA2 = 0, sumB2 = 0;\n    for(let i = 0; i < n; i++){\n        sumA += a[i];\n        sumB += b[i];\n        sumAB += a[i] * b[i];\n        sumA2 += a[i] * a[i];\n        sumB2 += b[i] * b[i];\n    }\n    const num = n * sumAB - sumA * sumB;\n    const den = Math.sqrt((n * sumA2 - sumA * sumA) * (n * sumB2 - sumB * sumB));\n    return den === 0 ? 0 : num / den;\n}\n/**\r\n * Convert sharp notation to flat notation where conventional\r\n */ function toFlat(note) {\n    const map = {\n        \"C#\": \"Db\",\n        \"D#\": \"Eb\",\n        \"F#\": \"F#\",\n        \"G#\": \"Ab\",\n        \"A#\": \"Bb\"\n    };\n    return map[note] || note;\n}\n/**\r\n * Perform full audio analysis (BPM + Key) on an AudioBuffer.\r\n */ async function analyzeAudio(buffer) {\n    const [bpm, keyResult] = await Promise.all([\n        detectBPM(buffer),\n        detectKey(buffer)\n    ]);\n    return {\n        bpm,\n        key: keyResult.key,\n        scale: keyResult.scale,\n        keyDisplay: keyResult.display\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL2F1ZGlvQW5hbHlzaXMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FFK0M7QUFFaEQsc0JBQXNCO0FBQ3RCLE1BQU1DLFlBQVk7SUFBQztJQUFLO0lBQU07SUFBSztJQUFNO0lBQUs7SUFBSztJQUFNO0lBQUs7SUFBTTtJQUFLO0lBQU07Q0FBSTtBQUVuRiwwREFBMEQ7QUFDMUQsTUFBTUMsZ0JBQWdCO0lBQUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFDOUYsTUFBTUMsZ0JBQWdCO0lBQUM7SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0lBQU07SUFBTTtJQUFNO0NBQUs7QUFTOUY7O0NBRUMsR0FDRCxlQUFlQyxVQUFVQyxNQUFtQjtJQUN4QyxJQUFJO1FBQ0EsTUFBTUMsU0FBUyxNQUFNTiw4REFBS0EsQ0FBQ0s7UUFDM0IsT0FBT0UsS0FBS0MsS0FBSyxDQUFDRixPQUFPRyxHQUFHO0lBQ2hDLEVBQUUsT0FBT0MsR0FBRztRQUNSQyxRQUFRQyxJQUFJLENBQUMsMENBQTBDRjtRQUN2RCxJQUFJO1lBQ0EsTUFBTUosU0FBUyxNQUFNTiw4REFBS0EsQ0FBQ0ssUUFBUSxHQUFHRSxLQUFLTSxHQUFHLENBQUNSLE9BQU9TLFFBQVEsRUFBRTtZQUNoRSxPQUFPUCxLQUFLQyxLQUFLLENBQUNGLE9BQU9HLEdBQUc7UUFDaEMsRUFBRSxVQUFNO1lBQ0osT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUVBOzs7Q0FHQyxHQUNELGVBQWVNLFVBQVVWLE1BQW1CO0lBQ3hDLE1BQU1XLGFBQWFYLE9BQU9XLFVBQVU7SUFDcEMsTUFBTUMsY0FBY1osT0FBT2EsY0FBYyxDQUFDO0lBRTFDLHFEQUFxRDtJQUNyRCxNQUFNQyxVQUFVO0lBQ2hCLE1BQU1DLGFBQWEsSUFBSUMsYUFBYSxJQUFJQyxJQUFJLENBQUM7SUFFN0Ms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U1osT0FBTzdCLElBQVk7SUFDeEIsTUFBTTBDLE1BQThCO1FBQ2hDLE1BQU07UUFBTSxNQUFNO1FBQU0sTUFBTTtRQUFNLE1BQU07UUFBTSxNQUFNO0lBQzFEO0lBQ0EsT0FBT0EsR0FBRyxDQUFDMUMsS0FBSyxJQUFJQTtBQUN4QjtBQUVBOztDQUVDLEdBQ00sZUFBZTJDLGFBQWEzRSxNQUFtQjtJQUNsRCxNQUFNLENBQUNJLEtBQUt3RSxVQUFVLEdBQUcsTUFBTUMsUUFBUUMsR0FBRyxDQUFDO1FBQ3ZDL0UsVUFBVUM7UUFDVlUsVUFBVVY7S0FDYjtJQUVELE9BQU87UUFDSEk7UUFDQWlELEtBQUt1QixVQUFVdkIsR0FBRztRQUNsQlUsT0FBT2EsVUFBVWIsS0FBSztRQUN0QmdCLFlBQVlILFVBQVVkLE9BQU87SUFDakM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9hdWRpb0FuYWx5c2lzLnRzPzQ5OWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEF1ZGlvIGFuYWx5c2lzIHV0aWxpdGllcyBmb3IgQlBNIGFuZCBtdXNpY2FsIGtleSBkZXRlY3Rpb24uXHJcbiAqIFVzZXMgd2ViLWF1ZGlvLWJlYXQtZGV0ZWN0b3IgZm9yIEJQTSBhbmQgc3BlY3RyYWwgYW5hbHlzaXMgZm9yIGtleS5cclxuICovXHJcblxyXG5pbXBvcnQgeyBndWVzcyB9IGZyb20gJ3dlYi1hdWRpby1iZWF0LWRldGVjdG9yJztcclxuXHJcbi8vIE11c2ljYWwga2V5IG5hbWVzICBcclxuY29uc3QgS0VZX05BTUVTID0gWydDJywgJ0MjJywgJ0QnLCAnRCMnLCAnRScsICdGJywgJ0YjJywgJ0cnLCAnRyMnLCAnQScsICdBIycsICdCJ107XHJcblxyXG4vLyBLcnVtaGFuc2wtS2Vzc2xlciBrZXkgcHJvZmlsZXMgZm9yIG1ham9yIGFuZCBtaW5vciBrZXlzXHJcbmNvbnN0IE1BSk9SX1BST0ZJTEUgPSBbNi4zNSwgMi4yMywgMy40OCwgMi4zMywgNC4zOCwgNC4wOSwgMi41MiwgNS4xOSwgMi4zOSwgMy42NiwgMi4yOSwgMi44OF07XHJcbmNvbnN0IE1JTk9SX1BST0ZJTEUgPSBbNi4zMywgMi42OCwgMy41MiwgNS4zOCwgMi42MCwgMy41MywgMi41NCwgNC43NSwgMy45OCwgMi42OSwgMy4zNCwgMy4xN107XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvQW5hbHlzaXMge1xyXG4gICAgYnBtOiBudW1iZXI7XHJcbiAgICBrZXk6IHN0cmluZzsgICAgICAgLy8gZS5nLiBcIkNcIiwgXCJGI1wiLCBcIkJiXCJcclxuICAgIHNjYWxlOiBzdHJpbmc7ICAgICAvLyBcIk1ham9yXCIgb3IgXCJNaW5vclwiXHJcbiAgICBrZXlEaXNwbGF5OiBzdHJpbmc7IC8vIGUuZy4gXCJDIE1ham9yXCIsIFwiRiNtXCJcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVjdCBCUE0gZnJvbSBhbiBBdWRpb0J1ZmZlciB1c2luZyB3ZWItYXVkaW8tYmVhdC1kZXRlY3Rvci5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRldGVjdEJQTShidWZmZXI6IEF1ZGlvQnVmZmVyKTogUHJvbWlzZTxudW1iZXI+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3Vlc3MoYnVmZmVyKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChyZXN1bHQuYnBtKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0JQTSBkZXRlY3Rpb24gZmFpbGVkLCB0cnlpbmcgZmFsbGJhY2s6JywgZSk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ3Vlc3MoYnVmZmVyLCAwLCBNYXRoLm1pbihidWZmZXIuZHVyYXRpb24sIDE1KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHJlc3VsdC5icG0pO1xyXG4gICAgICAgIH0gY2F0Y2gge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlY3QgbXVzaWNhbCBrZXkgdXNpbmcgRkZULWJhc2VkIGNocm9tYWdyYW0gYW5hbHlzaXMuXHJcbiAqIFVzZXMgT2ZmbGluZUF1ZGlvQ29udGV4dCArIEFuYWx5c2VyTm9kZSBmb3IgZWZmaWNpZW50IEZGVC5cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRldGVjdEtleShidWZmZXI6IEF1ZGlvQnVmZmVyKTogUHJvbWlzZTx7IGtleTogc3RyaW5nOyBzY2FsZTogc3RyaW5nOyBkaXNwbGF5OiBzdHJpbmcgfT4ge1xyXG4gICAgY29uc3Qgc2FtcGxlUmF0ZSA9IGJ1ZmZlci5zYW1wbGVSYXRlO1xyXG4gICAgY29uc3QgY2hhbm5lbERhdGEgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIG9mZmxpbmUgY29udGV4dCB0byB1c2UgQW5hbHlzZXJOb2RlIGZvciBGRlRcclxuICAgIGNvbnN0IGZmdFNpemUgPSA0MDk2O1xyXG4gICAgY29uc3QgY2hyb21hZ3JhbSA9IG5ldyBGbG9hdDY0QXJyYXkoMTIpLmZpbGwoMCk7XHJcblxyXG4gICAgLy8gU2FtcGxlIG11bHRpcGxlIHdpbmRvd3MgYWNyb3NzIHRoZSB0cmFja1xyXG4gICAgY29uc3QgdG90YWxGcmFtZXMgPSBjaGFubmVsRGF0YS5sZW5ndGg7XHJcbiAgICBjb25zdCB3aW5kb3dDb3VudCA9IE1hdGgubWluKDgwLCBNYXRoLmZsb29yKHRvdGFsRnJhbWVzIC8gZmZ0U2l6ZSkpO1xyXG4gICAgY29uc3QgaG9wU2l6ZSA9IE1hdGguZmxvb3IodG90YWxGcmFtZXMgLyB3aW5kb3dDb3VudCk7XHJcblxyXG4gICAgZm9yIChsZXQgdyA9IDA7IHcgPCB3aW5kb3dDb3VudDsgdysrKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB3ICogaG9wU2l6ZTtcclxuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihzdGFydCArIGZmdFNpemUsIHRvdGFsRnJhbWVzKTtcclxuICAgICAgICBjb25zdCBzZWdMZW4gPSBlbmQgLSBzdGFydDtcclxuXHJcbiAgICAgICAgLy8gQXBwbHkgSGFubmluZyB3aW5kb3cgYW5kIGNvbXB1dGUgcG93ZXIgc3BlY3RydW0gdmlhIHNpbXBsZSBGRlRcclxuICAgICAgICBjb25zdCB3aW5kb3dlZCA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0U2l6ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdMZW47IGkrKykge1xyXG4gICAgICAgICAgICB3aW5kb3dlZFtpXSA9IGNoYW5uZWxEYXRhW3N0YXJ0ICsgaV0gKiAoMC41IC0gMC41ICogTWF0aC5jb3MoMiAqIE1hdGguUEkgKiBpIC8gKHNlZ0xlbiAtIDEpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb21wdXRlIG1hZ25pdHVkZSBzcGVjdHJ1bSB1c2luZyBjb3JyZWxhdGlvbiB3aXRoIGtub3duIG5vdGUgZnJlcXVlbmNpZXNcclxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGZ1bGwgREZULCBqdXN0IGNoZWNrIHRoZSAxMiBjaHJvbWEgcGl0Y2ggY2xhc3Nlc1xyXG4gICAgICAgIGZvciAobGV0IG5vdGUgPSAwOyBub3RlIDwgMTI7IG5vdGUrKykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBtdWx0aXBsZSBvY3RhdmVzICgyIHRocm91Z2ggNilcclxuICAgICAgICAgICAgZm9yIChsZXQgb2N0YXZlID0gMjsgb2N0YXZlIDw9IDY7IG9jdGF2ZSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcmVxID0gNDQwICogTWF0aC5wb3coMiwgKG5vdGUgLSA5ICsgKG9jdGF2ZSAtIDQpICogMTIpIC8gMTIpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmluID0gTWF0aC5yb3VuZChmcmVxICogZmZ0U2l6ZSAvIHNhbXBsZVJhdGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJpbiA8PSAwIHx8IGJpbiA+PSBmZnRTaXplIC8gMikgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR29lcnR6ZWwgYWxnb3JpdGhtIGZvciBzaW5nbGUgZnJlcXVlbmN5IG1hZ25pdHVkZSDigJQgTyhOKSBwZXIgZnJlcXVlbmN5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gYmluO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdzAgPSAyICogTWF0aC5QSSAqIGsgLyBmZnRTaXplO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29lZmYgPSAyICogTWF0aC5jb3ModzApO1xyXG4gICAgICAgICAgICAgICAgbGV0IHMwID0gMCwgczEgPSAwLCBzMiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmZnRTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBzMCA9IHdpbmRvd2VkW2ldICsgY29lZmYgKiBzMSAtIHMyO1xyXG4gICAgICAgICAgICAgICAgICAgIHMyID0gczE7XHJcbiAgICAgICAgICAgICAgICAgICAgczEgPSBzMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoczEgKiBzMSArIHMyICogczIgLSBjb2VmZiAqIHMxICogczIpO1xyXG4gICAgICAgICAgICAgICAgY2hyb21hZ3JhbVtub3RlXSArPSBtYWduaXR1ZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm9ybWFsaXplIGNocm9tYWdyYW1cclxuICAgIGNvbnN0IG1heENocm9tYSA9IGNocm9tYWdyYW0ucmVkdWNlKChhY2MsIHYpID0+ICh2ID4gYWNjID8gdiA6IGFjYyksIDApO1xyXG4gICAgaWYgKG1heENocm9tYSA+IDApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgY2hyb21hZ3JhbVtpXSAvPSBtYXhDaHJvbWE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIENvcnJlbGF0ZSB3aXRoIGtleSBwcm9maWxlcyAoS3J1bWhhbnNsLUtlc3NsZXIpXHJcbiAgICBsZXQgYmVzdENvcnJlbGF0aW9uID0gLUluZmluaXR5O1xyXG4gICAgbGV0IGJlc3RLZXkgPSAwO1xyXG4gICAgbGV0IGJlc3RTY2FsZSA9ICdNYWpvcic7XHJcblxyXG4gICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgMTI7IGtleSsrKSB7XHJcbiAgICAgICAgY29uc3Qgcm90YXRlZCA9IG5ldyBGbG9hdDY0QXJyYXkoMTIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICByb3RhdGVkW2ldID0gY2hyb21hZ3JhbVsoaSArIGtleSkgJSAxMl07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBtYWpvckNvcnIgPSBjb3JyZWxhdGUocm90YXRlZCwgTUFKT1JfUFJPRklMRSk7XHJcbiAgICAgICAgaWYgKG1ham9yQ29yciA+IGJlc3RDb3JyZWxhdGlvbikge1xyXG4gICAgICAgICAgICBiZXN0Q29ycmVsYXRpb24gPSBtYWpvckNvcnI7XHJcbiAgICAgICAgICAgIGJlc3RLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGJlc3RTY2FsZSA9ICdNYWpvcic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBtaW5vckNvcnIgPSBjb3JyZWxhdGUocm90YXRlZCwgTUlOT1JfUFJPRklMRSk7XHJcbiAgICAgICAgaWYgKG1pbm9yQ29yciA+IGJlc3RDb3JyZWxhdGlvbikge1xyXG4gICAgICAgICAgICBiZXN0Q29ycmVsYXRpb24gPSBtaW5vckNvcnI7XHJcbiAgICAgICAgICAgIGJlc3RLZXkgPSBrZXk7XHJcbiAgICAgICAgICAgIGJlc3RTY2FsZSA9ICdNaW5vcic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGtleU5hbWUgPSBLRVlfTkFNRVNbYmVzdEtleV07XHJcbiAgICBjb25zdCBkaXNwbGF5S2V5ID0ga2V5TmFtZS5pbmNsdWRlcygnIycpID8gdG9GbGF0KGtleU5hbWUpIDoga2V5TmFtZTtcclxuICAgIGNvbnN0IGRpc3BsYXkgPSBiZXN0U2NhbGUgPT09ICdNaW5vcicgPyBgJHtkaXNwbGF5S2V5fW1gIDogZGlzcGxheUtleTtcclxuXHJcbiAgICByZXR1cm4geyBrZXk6IGRpc3BsYXlLZXksIHNjYWxlOiBiZXN0U2NhbGUsIGRpc3BsYXkgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBlYXJzb24gY29ycmVsYXRpb24gY29lZmZpY2llbnRcclxuICovXHJcbmZ1bmN0aW9uIGNvcnJlbGF0ZShhOiBGbG9hdDY0QXJyYXksIGI6IG51bWJlcltdKTogbnVtYmVyIHtcclxuICAgIGNvbnN0IG4gPSBhLmxlbmd0aDtcclxuICAgIGxldCBzdW1BID0gMCwgc3VtQiA9IDAsIHN1bUFCID0gMCwgc3VtQTIgPSAwLCBzdW1CMiA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHN1bUEgKz0gYVtpXTtcclxuICAgICAgICBzdW1CICs9IGJbaV07XHJcbiAgICAgICAgc3VtQUIgKz0gYVtpXSAqIGJbaV07XHJcbiAgICAgICAgc3VtQTIgKz0gYVtpXSAqIGFbaV07XHJcbiAgICAgICAgc3VtQjIgKz0gYltpXSAqIGJbaV07XHJcbiAgICB9XHJcbiAgICBjb25zdCBudW0gPSBuICogc3VtQUIgLSBzdW1BICogc3VtQjtcclxuICAgIGNvbnN0IGRlbiA9IE1hdGguc3FydCgobiAqIHN1bUEyIC0gc3VtQSAqIHN1bUEpICogKG4gKiBzdW1CMiAtIHN1bUIgKiBzdW1CKSk7XHJcbiAgICByZXR1cm4gZGVuID09PSAwID8gMCA6IG51bSAvIGRlbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgc2hhcnAgbm90YXRpb24gdG8gZmxhdCBub3RhdGlvbiB3aGVyZSBjb252ZW50aW9uYWxcclxuICovXHJcbmZ1bmN0aW9uIHRvRmxhdChub3RlOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbWFwOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xyXG4gICAgICAgICdDIyc6ICdEYicsICdEIyc6ICdFYicsICdGIyc6ICdGIycsICdHIyc6ICdBYicsICdBIyc6ICdCYidcclxuICAgIH07XHJcbiAgICByZXR1cm4gbWFwW25vdGVdIHx8IG5vdGU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQZXJmb3JtIGZ1bGwgYXVkaW8gYW5hbHlzaXMgKEJQTSArIEtleSkgb24gYW4gQXVkaW9CdWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYW5hbHl6ZUF1ZGlvKGJ1ZmZlcjogQXVkaW9CdWZmZXIpOiBQcm9taXNlPEF1ZGlvQW5hbHlzaXM+IHtcclxuICAgIGNvbnN0IFticG0sIGtleVJlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXHJcbiAgICAgICAgZGV0ZWN0QlBNKGJ1ZmZlciksXHJcbiAgICAgICAgZGV0ZWN0S2V5KGJ1ZmZlcilcclxuICAgIF0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgYnBtLFxyXG4gICAgICAgIGtleToga2V5UmVzdWx0LmtleSxcclxuICAgICAgICBzY2FsZToga2V5UmVzdWx0LnNjYWxlLFxyXG4gICAgICAgIGtleURpc3BsYXk6IGtleVJlc3VsdC5kaXNwbGF5XHJcbiAgICB9O1xyXG59XHJcbiJdLCJuYW1lcyI6WyJndWVzcyIsIktFWV9OQU1FUyIsIk1BSk9SX1BST0ZJTEUiLCJNSU5PUl9QUk9GSUxFIiwiZGV0ZWN0QlBNIiwiYnVmZmVyIiwicmVzdWx0IiwiTWF0aCIsInJvdW5kIiwiYnBtIiwiZSIsImNvbnNvbGUiLCJ3YXJuIiwibWluIiwiZHVyYXRpb24iLCJkZXRlY3RLZXkiLCJzYW1wbGVSYXRlIiwiY2hhbm5lbERhdGEiLCJnZXRDaGFubmVsRGF0YSIsImZmdFNpemUiLCJjaHJvbWFncmFtIiwiRmxvYXQ2NEFycmF5IiwiZmlsbCIsInRvdGFsRnJhbWVzIiwibGVuZ3RoIiwid2luZG93Q291bnQiLCJmbG9vciIsImhvcFNpemUiLCJ3Iiwic3RhcnQiLCJlbmQiLCJzZWdMZW4iLCJ3aW5kb3dlZCIsIkZsb2F0MzJBcnJheSIsImkiLCJjb3MiLCJQSSIsIm5vdGUiLCJvY3RhdmUiLCJmcmVxIiwicG93IiwiYmluIiwiayIsIncwIiwiY29lZmYiLCJzMCIsInMxIiwiczIiLCJtYWduaXR1ZGUiLCJzcXJ0IiwibWF4Q2hyb21hIiwicmVkdWNlIiwiYWNjIiwidiIsImJlc3RDb3JyZWxhdGlvbiIsIkluZmluaXR5IiwiYmVzdEtleSIsImJlc3RTY2FsZSIsImtleSIsInJvdGF0ZWQiLCJtYWpvckNvcnIiLCJjb3JyZWxhdGUiLCJtaW5vckNvcnIiLCJrZXlOYW1lIiwiZGlzcGxheUtleSIsImluY2x1ZGVzIiwidG9GbGF0IiwiZGlzcGxheSIsInNjYWxlIiwiYSIsImIiLCJuIiwic3VtQSIsInN1bUIiLCJzdW1BQiIsInN1bUEyIiwic3VtQjIiLCJudW0iLCJkZW4iLCJtYXAiLCJhbmFseXplQXVkaW8iLCJrZXlSZXN1bHQiLCJQcm9taXNlIiwiYWxsIiwia2V5RGlzcGxheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/audioAnalysis.ts\n"));

/***/ })

});