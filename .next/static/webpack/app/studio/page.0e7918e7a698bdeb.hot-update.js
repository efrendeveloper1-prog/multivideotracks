"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./hooks/useAudioEngine.tsx":
/*!**********************************!*\
  !*** ./hooks/useAudioEngine.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioEngineProvider: function() { return /* binding */ AudioEngineProvider; },\n/* harmony export */   useAudioEngine: function() { return /* binding */ useAudioEngine; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst AudioEngineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useAudioEngine = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AudioEngineContext);\n    if (!context) throw new Error(\"useAudioEngine must be used within AudioEngineProvider\");\n    return context;\n};\n_s(useAudioEngine, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst AudioEngineProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const [tracks, setTracks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentTime, setCurrentTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [duration, setDuration] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [masterVolume, setMasterVolume] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [videoDuration, setVideoDuration] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [playlist, setPlaylist] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeSongId, setActiveSongId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const audioContextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sourceNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const gainNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const masterGainRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const startTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const pauseTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const animationFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const durationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const isPlayingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Initialize AudioContext\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        audioContextRef.current = new AudioCtx();\n        masterGainRef.current = audioContextRef.current.createGain();\n        masterGainRef.current.connect(audioContextRef.current.destination);\n        return ()=>{\n            var _audioContextRef_current;\n            (_audioContextRef_current = audioContextRef.current) === null || _audioContextRef_current === void 0 ? void 0 : _audioContextRef_current.close();\n        };\n    }, []);\n    // Keep refs in sync with state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        durationRef.current = duration;\n    }, [\n        duration\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        isPlayingRef.current = isPlaying;\n    }, [\n        isPlaying\n    ]);\n    // Master Volume Effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (masterGainRef.current) {\n            masterGainRef.current.gain.value = masterVolume;\n        }\n    }, [\n        masterVolume\n    ]);\n    // Color helper\n    const getTrackColor = (name)=>{\n        const n = name.toLowerCase();\n        if (n.includes(\"drum\") || n.includes(\"bateria\")) return \"#06b6d4\";\n        if (n.includes(\"bass\") || n.includes(\"bajo\")) return \"#0d9488\";\n        if (n.includes(\"vox\") || n.includes(\"voz\") || n.includes(\"vocal\")) return \"#2563eb\";\n        if (n.includes(\"click\")) return \"#dc2626\";\n        if (n.includes(\"key\") || n.includes(\"piano\") || n.includes(\"synth\")) return \"#d946ef\";\n        if (n.includes(\"guitar\") || n.includes(\"guit\")) return \"#f59e0b\";\n        if (n.includes(\"video\")) return \"#a855f7\";\n        return \"#94a3b8\";\n    };\n    const addTrack = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (file, name)=>{\n        if (!audioContextRef.current) return;\n        try {\n            const arrayBuffer = await file.arrayBuffer();\n            const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);\n            const newTrack = {\n                id: crypto.randomUUID(),\n                name,\n                file,\n                buffer: audioBuffer,\n                volume: 1,\n                muted: false,\n                soloed: false,\n                color: getTrackColor(name)\n            };\n            setTracks((prev)=>[\n                    ...prev,\n                    newTrack\n                ]);\n            setDuration((prev)=>Math.max(prev, audioBuffer.duration));\n        } catch (e) {\n            console.error(\"Error decoding audio\", e);\n        }\n    }, []);\n    const addVideoTrack = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (videoFile)=>{\n        if (!audioContextRef.current) return;\n        const url = URL.createObjectURL(videoFile);\n        // 1. Create the visual VIDEO TRACK (no buffer, for timeline thumbnails)\n        const videoTrack = {\n            id: crypto.randomUUID(),\n            name: \"VIDEO TRACK\",\n            file: videoFile,\n            buffer: undefined,\n            volume: 1,\n            muted: false,\n            soloed: false,\n            color: \"#a855f7\"\n        };\n        // 2. Try to extract audio from video and create a separate audio channel\n        let audioTrack = null;\n        try {\n            const arrayBuffer = await videoFile.arrayBuffer();\n            const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer.slice(0));\n            audioTrack = {\n                id: crypto.randomUUID(),\n                name: \"VIDEO AUDIO\",\n                file: videoFile,\n                buffer: audioBuffer,\n                volume: 1,\n                muted: false,\n                soloed: false,\n                color: \"#c084fc\",\n                isVideoAudio: true\n            };\n        } catch (e) {\n            console.warn(\"Video has no extractable audio or decode failed:\", e);\n        }\n        setTracks((prev)=>{\n            const newTracks = [\n                ...prev,\n                videoTrack\n            ];\n            if (audioTrack) newTracks.push(audioTrack);\n            return newTracks;\n        });\n        // Emit event for the UI to catch and set video src\n        const customEvent = new CustomEvent(\"video-uploaded\", {\n            detail: url\n        });\n        window.dispatchEvent(customEvent);\n        // Get video duration (store separately, do NOT extend master duration)\n        const tempVideo = document.createElement(\"video\");\n        tempVideo.src = url;\n        tempVideo.onloadedmetadata = ()=>{\n            setVideoDuration(tempVideo.duration);\n            // Only use video duration if there are NO audio tracks yet\n            setDuration((prev)=>{\n                if (prev === 0) return tempVideo.duration; // No audio, use video duration\n                return prev; // Audio exists, keep audio duration as master\n            });\n        };\n    }, []);\n    const clearTracks = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        stopAudioInternal();\n        setTracks([]);\n        setDuration(0);\n        setVideoDuration(0);\n        setCurrentTime(0);\n        pauseTimeRef.current = 0;\n        setIsPlaying(false);\n    }, []);\n    const stopAudioInternal = ()=>{\n        sourceNodesRef.current.forEach((source)=>{\n            try {\n                source.stop();\n            } catch (e) {}\n        });\n        sourceNodesRef.current.clear();\n        gainNodesRef.current.clear();\n    };\n    const playAudio = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((startOffset)=>{\n        if (!audioContextRef.current || !masterGainRef.current) return;\n        if (audioContextRef.current.state === \"suspended\") {\n            audioContextRef.current.resume();\n        }\n        const anySolo = tracks.some((t)=>t.soloed);\n        tracks.forEach((track)=>{\n            if (!track.buffer) return; // Skip VIDEO TRACK (no buffer)\n            const source = audioContextRef.current.createBufferSource();\n            source.buffer = track.buffer;\n            const gainNode = audioContextRef.current.createGain();\n            const shouldLogicallyMute = track.muted || anySolo && !track.soloed;\n            gainNode.gain.value = shouldLogicallyMute ? 0 : track.volume;\n            source.connect(gainNode);\n            gainNode.connect(masterGainRef.current);\n            source.start(0, startOffset);\n            sourceNodesRef.current.set(track.id, source);\n            gainNodesRef.current.set(track.id, gainNode);\n            source.onended = ()=>{};\n        });\n    }, [\n        tracks\n    ]);\n    const stopAudio = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        stopAudioInternal();\n    }, []);\n    const togglePlay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (isPlayingRef.current) {\n            stopAudioInternal();\n            pauseTimeRef.current = currentTime;\n            if (videoRef.current) videoRef.current.pause();\n            cancelAnimationFrame(animationFrameRef.current);\n            setIsPlaying(false);\n            isPlayingRef.current = false;\n        } else {\n            let start = pauseTimeRef.current;\n            if (start >= durationRef.current && durationRef.current > 0) {\n                start = 0;\n                pauseTimeRef.current = 0;\n            }\n            playAudio(start);\n            startTimeRef.current = audioContextRef.current.currentTime - start;\n            if (videoRef.current) {\n                videoRef.current.currentTime = start;\n                videoRef.current.play().catch((e)=>console.error(\"Video play failed\", e));\n            }\n            setIsPlaying(true);\n            isPlayingRef.current = true;\n            const update = ()=>{\n                var _audioContextRef_current;\n                if (!isPlayingRef.current) return; // Guard: if stopped externally\n                const now = (_audioContextRef_current = audioContextRef.current) === null || _audioContextRef_current === void 0 ? void 0 : _audioContextRef_current.currentTime;\n                if (now === undefined) return;\n                const calculatedTime = now - startTimeRef.current;\n                const dur = durationRef.current;\n                if (calculatedTime >= dur && dur > 0) {\n                    // Song ended â€” stop everything\n                    stopAudioInternal();\n                    if (videoRef.current) {\n                        videoRef.current.pause();\n                        videoRef.current.currentTime = 0;\n                    }\n                    pauseTimeRef.current = 0;\n                    setCurrentTime(0);\n                    setIsPlaying(false);\n                    isPlayingRef.current = false;\n                    return;\n                }\n                setCurrentTime(calculatedTime);\n                animationFrameRef.current = requestAnimationFrame(update);\n            };\n            animationFrameRef.current = requestAnimationFrame(update);\n        }\n    }, [\n        currentTime,\n        playAudio\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        stopAudioInternal();\n        if (videoRef.current) {\n            videoRef.current.pause();\n            videoRef.current.currentTime = 0;\n        }\n        pauseTimeRef.current = 0;\n        setCurrentTime(0);\n        setIsPlaying(false);\n        cancelAnimationFrame(animationFrameRef.current);\n    }, []);\n    const seek = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((time)=>{\n        const wasPlaying = isPlaying;\n        if (wasPlaying) stopAudioInternal();\n        pauseTimeRef.current = time;\n        setCurrentTime(time);\n        if (videoRef.current) {\n            videoRef.current.currentTime = time;\n        }\n        if (wasPlaying) {\n            playAudio(time);\n            startTimeRef.current = audioContextRef.current.currentTime - time;\n        }\n    }, [\n        isPlaying,\n        playAudio\n    ]);\n    // Live Volume/Mute/Solo updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const anySolo = tracks.some((t)=>t.soloed);\n        tracks.forEach((track)=>{\n            const shouldLogicallyMute = track.muted || anySolo && !track.soloed;\n            const targetVolume = shouldLogicallyMute ? 0 : track.volume;\n            if (track.name === \"VIDEO TRACK\" && videoRef.current) {\n                videoRef.current.volume = targetVolume * masterVolume;\n                videoRef.current.muted = shouldLogicallyMute;\n            } else {\n                const gainNode = gainNodesRef.current.get(track.id);\n                if (gainNode && audioContextRef.current) {\n                    gainNode.gain.cancelScheduledValues(audioContextRef.current.currentTime);\n                    gainNode.gain.setTargetAtTime(targetVolume, audioContextRef.current.currentTime, 0.05);\n                }\n            }\n        });\n    }, [\n        tracks,\n        masterVolume\n    ]);\n    const setTrackVolume = (id, volume)=>{\n        setTracks((prev)=>prev.map((t)=>t.id === id ? {\n                    ...t,\n                    volume\n                } : t));\n    };\n    const toggleTrackMute = (id)=>{\n        setTracks((prev)=>prev.map((t)=>t.id === id ? {\n                    ...t,\n                    muted: !t.muted\n                } : t));\n    };\n    const toggleTrackSolo = (id)=>{\n        setTracks((prev)=>prev.map((t)=>t.id === id ? {\n                    ...t,\n                    soloed: !t.soloed\n                } : t));\n    };\n    const removeTrack = (id)=>{\n        setTracks((prev)=>prev.filter((t)=>t.id !== id));\n    };\n    // Playlist management\n    const addSongToPlaylist = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((song)=>{\n        setPlaylist((prev)=>[\n                ...prev,\n                song\n            ]);\n    }, []);\n    const removeSongFromPlaylist = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        setPlaylist((prev)=>prev.filter((s)=>s.id !== id));\n    }, []);\n    const loadSong = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (id)=>{\n        const song = playlist.find((s)=>s.id === id);\n        if (!song) return;\n        // Stop current playback and clear tracks\n        stopAudioInternal();\n        cancelAnimationFrame(animationFrameRef.current);\n        setIsPlaying(false);\n        setCurrentTime(0);\n        pauseTimeRef.current = 0;\n        setDuration(0);\n        setTracks([]);\n        setActiveSongId(id);\n        // Load all stem files\n        for (const stemFile of song.stemFiles){\n            const trackName = stemFile.name.replace(/\\.(wav|mp3)$/i, \"\");\n            await addTrack(stemFile, trackName);\n        }\n        // Load video if present\n        if (song.videoFile) {\n            await addVideoTrack(song.videoFile);\n        }\n    }, [\n        playlist,\n        addTrack,\n        addVideoTrack\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AudioEngineContext.Provider, {\n        value: {\n            tracks,\n            isPlaying,\n            currentTime,\n            duration,\n            addTrack,\n            addVideoTrack,\n            removeTrack,\n            clearTracks,\n            togglePlay,\n            stop,\n            seek,\n            setTrackVolume,\n            toggleTrackMute,\n            toggleTrackSolo,\n            setVideoElement: (el)=>videoRef.current = el,\n            masterVolume,\n            setMasterVolume,\n            playlist,\n            activeSongId,\n            addSongToPlaylist,\n            removeSongFromPlaylist,\n            loadSong\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Efren\\\\Documents\\\\Proyectos\\\\multivideotrack\\\\hooks\\\\useAudioEngine.tsx\",\n        lineNumber: 413,\n        columnNumber: 9\n    }, undefined);\n};\n_s1(AudioEngineProvider, \"29RgUoKUaO5kQV9wYJZM7nxgK1A=\");\n_c = AudioEngineProvider;\nvar _c;\n$RefreshReg$(_c, \"AudioEngineProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUF1ZGlvRW5naW5lLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1HO0FBcURuRyxNQUFNTyxtQ0FBcUJOLG9EQUFhQSxDQUFnQztBQUVqRSxNQUFNTyxpQkFBaUI7O0lBQzFCLE1BQU1DLFVBQVVQLGlEQUFVQSxDQUFDSztJQUMzQixJQUFJLENBQUNFLFNBQVMsTUFBTSxJQUFJQyxNQUFNO0lBQzlCLE9BQU9EO0FBQ1gsRUFBRTtHQUpXRDtBQU1OLE1BQU1HLHNCQUErRDtRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDckYsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdWLCtDQUFRQSxDQUFVLEVBQUU7SUFDaEQsTUFBTSxDQUFDVyxXQUFXQyxhQUFhLEdBQUdaLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2EsYUFBYUMsZUFBZSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNlLFVBQVVDLFlBQVksR0FBR2hCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ2lCLGNBQWNDLGdCQUFnQixHQUFHbEIsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDbUIsZUFBZUMsaUJBQWlCLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNxQixVQUFVQyxZQUFZLEdBQUd0QiwrQ0FBUUEsQ0FBUyxFQUFFO0lBQ25ELE1BQU0sQ0FBQ3VCLGNBQWNDLGdCQUFnQixHQUFHeEIsK0NBQVFBLENBQWdCO0lBRWhFLE1BQU15QixrQkFBa0IxQiw2Q0FBTUEsQ0FBc0I7SUFDcEQsTUFBTTJCLGlCQUFpQjNCLDZDQUFNQSxDQUFxQyxJQUFJNEI7SUFDdEUsTUFBTUMsZUFBZTdCLDZDQUFNQSxDQUF3QixJQUFJNEI7SUFDdkQsTUFBTUUsZ0JBQWdCOUIsNkNBQU1BLENBQWtCO0lBQzlDLE1BQU0rQixXQUFXL0IsNkNBQU1BLENBQTBCO0lBQ2pELE1BQU1nQyxlQUFlaEMsNkNBQU1BLENBQVM7SUFD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IjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlQXVkaW9FbmdpbmUudHN4PzEwZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcblxyXG4vLyBUeXBlc1xyXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrIHtcclxuICAgIGlkOiBzdHJpbmc7XHJcbiAgICBuYW1lOiBzdHJpbmc7XHJcbiAgICBmaWxlOiBGaWxlO1xyXG4gICAgYnVmZmVyPzogQXVkaW9CdWZmZXI7XHJcbiAgICB2b2x1bWU6IG51bWJlcjtcclxuICAgIG11dGVkOiBib29sZWFuO1xyXG4gICAgc29sb2VkOiBib29sZWFuO1xyXG4gICAgY29sb3I6IHN0cmluZztcclxuICAgIGlzVmlkZW9BdWRpbz86IGJvb2xlYW47IC8vIEZsYWcgZm9yIHRoZSBleHRyYWN0ZWQgYXVkaW8gZnJvbSB2aWRlb1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNvbmcge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIHRpdGxlOiBzdHJpbmc7XHJcbiAgICBhcnRpc3Q6IHN0cmluZztcclxuICAgIGtleTogc3RyaW5nO1xyXG4gICAgYnBtOiBudW1iZXI7XHJcbiAgICBzdGVtRmlsZXM6IEZpbGVbXTtcclxuICAgIHZpZGVvRmlsZT86IEZpbGU7XHJcbn1cclxuXHJcbmludGVyZmFjZSBBdWRpb0VuZ2luZUNvbnRleHRUeXBlIHtcclxuICAgIHRyYWNrczogVHJhY2tbXTtcclxuICAgIGlzUGxheWluZzogYm9vbGVhbjtcclxuICAgIGN1cnJlbnRUaW1lOiBudW1iZXI7XHJcbiAgICBkdXJhdGlvbjogbnVtYmVyO1xyXG4gICAgYWRkVHJhY2s6IChmaWxlOiBGaWxlLCBuYW1lOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XHJcbiAgICBhZGRWaWRlb1RyYWNrOiAoZmlsZTogRmlsZSkgPT4gUHJvbWlzZTx2b2lkPjtcclxuICAgIHJlbW92ZVRyYWNrOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICAgIGNsZWFyVHJhY2tzOiAoKSA9PiB2b2lkO1xyXG4gICAgdG9nZ2xlUGxheTogKCkgPT4gdm9pZDtcclxuICAgIHN0b3A6ICgpID0+IHZvaWQ7XHJcbiAgICBzZWVrOiAodGltZTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gICAgc2V0VHJhY2tWb2x1bWU6IChpZDogc3RyaW5nLCB2b2x1bWU6IG51bWJlcikgPT4gdm9pZDtcclxuICAgIHRvZ2dsZVRyYWNrTXV0ZTogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgICB0b2dnbGVUcmFja1NvbG86IChpZDogc3RyaW5nKSA9PiB2b2lkO1xyXG4gICAgc2V0VmlkZW9FbGVtZW50OiAoZWxlbWVudDogSFRNTFZpZGVvRWxlbWVudCB8IG51bGwpID0+IHZvaWQ7XHJcbiAgICBtYXN0ZXJWb2x1bWU6IG51bWJlcjtcclxuICAgIHNldE1hc3RlclZvbHVtZTogKHZhbDogbnVtYmVyKSA9PiB2b2lkO1xyXG4gICAgdmlkZW9EdXJhdGlvbjogbnVtYmVyOyAvLyBPcmlnaW5hbCB2aWRlbyBkdXJhdGlvbiAobWF5IGJlIGxvbmdlciB0aGFuIGF1ZGlvKVxyXG4gICAgdHJpbVZpZGVvVG9BdWRpbzogKCkgPT4gdm9pZDsgLy8gVHJpbSB2aWRlbyB0byBtYXRjaCBhdWRpbyBkdXJhdGlvblxyXG4gICAgLy8gUGxheWxpc3RcclxuICAgIHBsYXlsaXN0OiBTb25nW107XHJcbiAgICBhY3RpdmVTb25nSWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgICBhZGRTb25nVG9QbGF5bGlzdDogKHNvbmc6IFNvbmcpID0+IHZvaWQ7XHJcbiAgICByZW1vdmVTb25nRnJvbVBsYXlsaXN0OiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICAgIGxvYWRTb25nOiAoaWQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxufVxyXG5cclxuY29uc3QgQXVkaW9FbmdpbmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBdWRpb0VuZ2luZUNvbnRleHRUeXBlIHwgbnVsbD4obnVsbCk7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQXVkaW9FbmdpbmUgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBdWRpb0VuZ2luZUNvbnRleHQpO1xyXG4gICAgaWYgKCFjb250ZXh0KSB0aHJvdyBuZXcgRXJyb3IoJ3VzZUF1ZGlvRW5naW5lIG11c3QgYmUgdXNlZCB3aXRoaW4gQXVkaW9FbmdpbmVQcm92aWRlcicpO1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgQXVkaW9FbmdpbmVQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xyXG4gICAgY29uc3QgW3RyYWNrcywgc2V0VHJhY2tzXSA9IHVzZVN0YXRlPFRyYWNrW10+KFtdKTtcclxuICAgIGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbY3VycmVudFRpbWUsIHNldEN1cnJlbnRUaW1lXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW2R1cmF0aW9uLCBzZXREdXJhdGlvbl0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFttYXN0ZXJWb2x1bWUsIHNldE1hc3RlclZvbHVtZV0gPSB1c2VTdGF0ZSgxKTtcclxuICAgIGNvbnN0IFt2aWRlb0R1cmF0aW9uLCBzZXRWaWRlb0R1cmF0aW9uXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3BsYXlsaXN0LCBzZXRQbGF5bGlzdF0gPSB1c2VTdGF0ZTxTb25nW10+KFtdKTtcclxuICAgIGNvbnN0IFthY3RpdmVTb25nSWQsIHNldEFjdGl2ZVNvbmdJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHRSZWYgPSB1c2VSZWY8QXVkaW9Db250ZXh0IHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCBzb3VyY2VOb2Rlc1JlZiA9IHVzZVJlZjxNYXA8c3RyaW5nLCBBdWRpb0J1ZmZlclNvdXJjZU5vZGU+PihuZXcgTWFwKCkpO1xyXG4gICAgY29uc3QgZ2Fpbk5vZGVzUmVmID0gdXNlUmVmPE1hcDxzdHJpbmcsIEdhaW5Ob2RlPj4obmV3IE1hcCgpKTtcclxuICAgIGNvbnN0IG1hc3RlckdhaW5SZWYgPSB1c2VSZWY8R2Fpbk5vZGUgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmPEhUTUxWaWRlb0VsZW1lbnQgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IHN0YXJ0VGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gICAgY29uc3QgcGF1c2VUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgICBjb25zdCBhbmltYXRpb25GcmFtZVJlZiA9IHVzZVJlZjxudW1iZXI+KCk7XHJcbiAgICBjb25zdCBkdXJhdGlvblJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gICAgY29uc3QgaXNQbGF5aW5nUmVmID0gdXNlUmVmPGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIEF1ZGlvQ29udGV4dFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBBdWRpb0N0eCA9IHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgKHdpbmRvdyBhcyBhbnkpLndlYmtpdEF1ZGlvQ29udGV4dDtcclxuICAgICAgICBhdWRpb0NvbnRleHRSZWYuY3VycmVudCA9IG5ldyBBdWRpb0N0eCgpO1xyXG4gICAgICAgIG1hc3RlckdhaW5SZWYuY3VycmVudCA9IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICBtYXN0ZXJHYWluUmVmLmN1cnJlbnQuY29ubmVjdChhdWRpb0NvbnRleHRSZWYuY3VycmVudC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQ/LmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBLZWVwIHJlZnMgaW4gc3luYyB3aXRoIHN0YXRlXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBkdXJhdGlvblJlZi5jdXJyZW50ID0gZHVyYXRpb247IH0sIFtkdXJhdGlvbl0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHsgaXNQbGF5aW5nUmVmLmN1cnJlbnQgPSBpc1BsYXlpbmc7IH0sIFtpc1BsYXlpbmddKTtcclxuXHJcbiAgICAvLyBNYXN0ZXIgVm9sdW1lIEVmZmVjdFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAobWFzdGVyR2FpblJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIG1hc3RlckdhaW5SZWYuY3VycmVudC5nYWluLnZhbHVlID0gbWFzdGVyVm9sdW1lO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFttYXN0ZXJWb2x1bWVdKTtcclxuXHJcbiAgICAvLyBDb2xvciBoZWxwZXJcclxuICAgIGNvbnN0IGdldFRyYWNrQ29sb3IgPSAobmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbiA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAobi5pbmNsdWRlcygnZHJ1bScpIHx8IG4uaW5jbHVkZXMoJ2JhdGVyaWEnKSkgcmV0dXJuICcjMDZiNmQ0JztcclxuICAgICAgICBpZiAobi5pbmNsdWRlcygnYmFzcycpIHx8IG4uaW5jbHVkZXMoJ2Jham8nKSkgcmV0dXJuICcjMGQ5NDg4JztcclxuICAgICAgICBpZiAobi5pbmNsdWRlcygndm94JykgfHwgbi5pbmNsdWRlcygndm96JykgfHwgbi5pbmNsdWRlcygndm9jYWwnKSkgcmV0dXJuICcjMjU2M2ViJztcclxuICAgICAgICBpZiAobi5pbmNsdWRlcygnY2xpY2snKSkgcmV0dXJuICcjZGMyNjI2JztcclxuICAgICAgICBpZiAobi5pbmNsdWRlcygna2V5JykgfHwgbi5pbmNsdWRlcygncGlhbm8nKSB8fCBuLmluY2x1ZGVzKCdzeW50aCcpKSByZXR1cm4gJyNkOTQ2ZWYnO1xyXG4gICAgICAgIGlmIChuLmluY2x1ZGVzKCdndWl0YXInKSB8fCBuLmluY2x1ZGVzKCdndWl0JykpIHJldHVybiAnI2Y1OWUwYic7XHJcbiAgICAgICAgaWYgKG4uaW5jbHVkZXMoJ3ZpZGVvJykpIHJldHVybiAnI2E4NTVmNyc7XHJcbiAgICAgICAgcmV0dXJuICcjOTRhM2I4JztcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgYWRkVHJhY2sgPSB1c2VDYWxsYmFjayhhc3luYyAoZmlsZTogRmlsZSwgbmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhdWRpb0NvbnRleHRSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgYXVkaW9CdWZmZXIgPSBhd2FpdCBhdWRpb0NvbnRleHRSZWYuY3VycmVudC5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbmV3VHJhY2s6IFRyYWNrID0ge1xyXG4gICAgICAgICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgZmlsZSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogYXVkaW9CdWZmZXIsXHJcbiAgICAgICAgICAgICAgICB2b2x1bWU6IDEsXHJcbiAgICAgICAgICAgICAgICBtdXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzb2xvZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6IGdldFRyYWNrQ29sb3IobmFtZSlcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIHNldFRyYWNrcyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdUcmFja10pO1xyXG4gICAgICAgICAgICBzZXREdXJhdGlvbihwcmV2ID0+IE1hdGgubWF4KHByZXYsIGF1ZGlvQnVmZmVyLmR1cmF0aW9uKSk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmcgYXVkaW9cIiwgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGFkZFZpZGVvVHJhY2sgPSB1c2VDYWxsYmFjayhhc3luYyAodmlkZW9GaWxlOiBGaWxlKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhdWRpb0NvbnRleHRSZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHZpZGVvRmlsZSk7XHJcblxyXG4gICAgICAgIC8vIDEuIENyZWF0ZSB0aGUgdmlzdWFsIFZJREVPIFRSQUNLIChubyBidWZmZXIsIGZvciB0aW1lbGluZSB0aHVtYm5haWxzKVxyXG4gICAgICAgIGNvbnN0IHZpZGVvVHJhY2s6IFRyYWNrID0ge1xyXG4gICAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICAgICAgbmFtZTogXCJWSURFTyBUUkFDS1wiLFxyXG4gICAgICAgICAgICBmaWxlOiB2aWRlb0ZpbGUsXHJcbiAgICAgICAgICAgIGJ1ZmZlcjogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB2b2x1bWU6IDEsXHJcbiAgICAgICAgICAgIG11dGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgc29sb2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgY29sb3I6ICcjYTg1NWY3J1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIDIuIFRyeSB0byBleHRyYWN0IGF1ZGlvIGZyb20gdmlkZW8gYW5kIGNyZWF0ZSBhIHNlcGFyYXRlIGF1ZGlvIGNoYW5uZWxcclxuICAgICAgICBsZXQgYXVkaW9UcmFjazogVHJhY2sgfCBudWxsID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IHZpZGVvRmlsZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBhdWRpb0J1ZmZlciA9IGF3YWl0IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LmRlY29kZUF1ZGlvRGF0YShhcnJheUJ1ZmZlci5zbGljZSgwKSk7XHJcblxyXG4gICAgICAgICAgICBhdWRpb1RyYWNrID0ge1xyXG4gICAgICAgICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBcIlZJREVPIEFVRElPXCIsXHJcbiAgICAgICAgICAgICAgICBmaWxlOiB2aWRlb0ZpbGUsXHJcbiAgICAgICAgICAgICAgICBidWZmZXI6IGF1ZGlvQnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgdm9sdW1lOiAxLFxyXG4gICAgICAgICAgICAgICAgbXV0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgc29sb2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNvbG9yOiAnI2MwODRmYycsXHJcbiAgICAgICAgICAgICAgICBpc1ZpZGVvQXVkaW86IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZpZGVvIGhhcyBubyBleHRyYWN0YWJsZSBhdWRpbyBvciBkZWNvZGUgZmFpbGVkOlwiLCBlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNldFRyYWNrcyhwcmV2ID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3VHJhY2tzID0gWy4uLnByZXYsIHZpZGVvVHJhY2tdO1xyXG4gICAgICAgICAgICBpZiAoYXVkaW9UcmFjaykgbmV3VHJhY2tzLnB1c2goYXVkaW9UcmFjayk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmFja3M7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIEVtaXQgZXZlbnQgZm9yIHRoZSBVSSB0byBjYXRjaCBhbmQgc2V0IHZpZGVvIHNyY1xyXG4gICAgICAgIGNvbnN0IGN1c3RvbUV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd2aWRlby11cGxvYWRlZCcsIHsgZGV0YWlsOiB1cmwgfSk7XHJcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBHZXQgdmlkZW8gZHVyYXRpb24gKHN0b3JlIHNlcGFyYXRlbHksIGRvIE5PVCBleHRlbmQgbWFzdGVyIGR1cmF0aW9uKVxyXG4gICAgICAgIGNvbnN0IHRlbXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XHJcbiAgICAgICAgdGVtcFZpZGVvLnNyYyA9IHVybDtcclxuICAgICAgICB0ZW1wVmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcclxuICAgICAgICAgICAgc2V0VmlkZW9EdXJhdGlvbih0ZW1wVmlkZW8uZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAvLyBPbmx5IHVzZSB2aWRlbyBkdXJhdGlvbiBpZiB0aGVyZSBhcmUgTk8gYXVkaW8gdHJhY2tzIHlldFxyXG4gICAgICAgICAgICBzZXREdXJhdGlvbihwcmV2ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSAwKSByZXR1cm4gdGVtcFZpZGVvLmR1cmF0aW9uOyAvLyBObyBhdWRpbywgdXNlIHZpZGVvIGR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldjsgLy8gQXVkaW8gZXhpc3RzLCBrZWVwIGF1ZGlvIGR1cmF0aW9uIGFzIG1hc3RlclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNsZWFyVHJhY2tzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHN0b3BBdWRpb0ludGVybmFsKCk7XHJcbiAgICAgICAgc2V0VHJhY2tzKFtdKTtcclxuICAgICAgICBzZXREdXJhdGlvbigwKTtcclxuICAgICAgICBzZXRWaWRlb0R1cmF0aW9uKDApO1xyXG4gICAgICAgIHNldEN1cnJlbnRUaW1lKDApO1xyXG4gICAgICAgIHBhdXNlVGltZVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHN0b3BBdWRpb0ludGVybmFsID0gKCkgPT4ge1xyXG4gICAgICAgIHNvdXJjZU5vZGVzUmVmLmN1cnJlbnQuZm9yRWFjaChzb3VyY2UgPT4ge1xyXG4gICAgICAgICAgICB0cnkgeyBzb3VyY2Uuc3RvcCgpOyB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzb3VyY2VOb2Rlc1JlZi5jdXJyZW50LmNsZWFyKCk7XHJcbiAgICAgICAgZ2Fpbk5vZGVzUmVmLmN1cnJlbnQuY2xlYXIoKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcGxheUF1ZGlvID0gdXNlQ2FsbGJhY2soKHN0YXJ0T2Zmc2V0OiBudW1iZXIpID0+IHtcclxuICAgICAgICBpZiAoIWF1ZGlvQ29udGV4dFJlZi5jdXJyZW50IHx8ICFtYXN0ZXJHYWluUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xyXG4gICAgICAgICAgICBhdWRpb0NvbnRleHRSZWYuY3VycmVudC5yZXN1bWUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGFueVNvbG8gPSB0cmFja3Muc29tZSh0ID0+IHQuc29sb2VkKTtcclxuXHJcbiAgICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRyYWNrLmJ1ZmZlcikgcmV0dXJuOyAvLyBTa2lwIFZJREVPIFRSQUNLIChubyBidWZmZXIpXHJcblxyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHRSZWYuY3VycmVudCEuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgIHNvdXJjZS5idWZmZXIgPSB0cmFjay5idWZmZXI7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBnYWluTm9kZSA9IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50IS5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZExvZ2ljYWxseU11dGUgPSB0cmFjay5tdXRlZCB8fCAoYW55U29sbyAmJiAhdHJhY2suc29sb2VkKTtcclxuICAgICAgICAgICAgZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IHNob3VsZExvZ2ljYWxseU11dGUgPyAwIDogdHJhY2sudm9sdW1lO1xyXG5cclxuICAgICAgICAgICAgc291cmNlLmNvbm5lY3QoZ2Fpbk5vZGUpO1xyXG4gICAgICAgICAgICBnYWluTm9kZS5jb25uZWN0KG1hc3RlckdhaW5SZWYuY3VycmVudCEpO1xyXG4gICAgICAgICAgICBzb3VyY2Uuc3RhcnQoMCwgc3RhcnRPZmZzZXQpO1xyXG5cclxuICAgICAgICAgICAgc291cmNlTm9kZXNSZWYuY3VycmVudC5zZXQodHJhY2suaWQsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIGdhaW5Ob2Rlc1JlZi5jdXJyZW50LnNldCh0cmFjay5pZCwgZ2Fpbk5vZGUpO1xyXG5cclxuICAgICAgICAgICAgc291cmNlLm9uZW5kZWQgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbdHJhY2tzXSk7XHJcblxyXG4gICAgY29uc3Qgc3RvcEF1ZGlvID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHN0b3BBdWRpb0ludGVybmFsKCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgdG9nZ2xlUGxheSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAoaXNQbGF5aW5nUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgc3RvcEF1ZGlvSW50ZXJuYWwoKTtcclxuICAgICAgICAgICAgcGF1c2VUaW1lUmVmLmN1cnJlbnQgPSBjdXJyZW50VGltZTtcclxuICAgICAgICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHZpZGVvUmVmLmN1cnJlbnQucGF1c2UoKTtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCEpO1xyXG4gICAgICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICBpc1BsYXlpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHBhdXNlVGltZVJlZi5jdXJyZW50O1xyXG4gICAgICAgICAgICBpZiAoc3RhcnQgPj0gZHVyYXRpb25SZWYuY3VycmVudCAmJiBkdXJhdGlvblJlZi5jdXJyZW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgcGF1c2VUaW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBwbGF5QXVkaW8oc3RhcnQpO1xyXG4gICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50IS5jdXJyZW50VGltZSAtIHN0YXJ0O1xyXG5cclxuICAgICAgICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSBzdGFydDtcclxuICAgICAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQucGxheSgpLmNhdGNoKGUgPT4gY29uc29sZS5lcnJvcihcIlZpZGVvIHBsYXkgZmFpbGVkXCIsIGUpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgc2V0SXNQbGF5aW5nKHRydWUpO1xyXG4gICAgICAgICAgICBpc1BsYXlpbmdSZWYuY3VycmVudCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGxheWluZ1JlZi5jdXJyZW50KSByZXR1cm47IC8vIEd1YXJkOiBpZiBzdG9wcGVkIGV4dGVybmFsbHlcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBhdWRpb0NvbnRleHRSZWYuY3VycmVudD8uY3VycmVudFRpbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobm93ID09PSB1bmRlZmluZWQpIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRUaW1lID0gbm93IC0gc3RhcnRUaW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkdXIgPSBkdXJhdGlvblJlZi5jdXJyZW50O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkVGltZSA+PSBkdXIgJiYgZHVyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbmcgZW5kZWQg4oCUIHN0b3AgZXZlcnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BBdWRpb0ludGVybmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9SZWYuY3VycmVudC5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LmN1cnJlbnRUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF1c2VUaW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUaW1lKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNQbGF5aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUoY2FsY3VsYXRlZFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRUaW1lLCBwbGF5QXVkaW9dKTtcclxuXHJcbiAgICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHN0b3BBdWRpb0ludGVybmFsKCk7XHJcbiAgICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdmlkZW9SZWYuY3VycmVudC5wYXVzZSgpO1xyXG4gICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LmN1cnJlbnRUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGF1c2VUaW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIHNldEN1cnJlbnRUaW1lKDApO1xyXG4gICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCEpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHNlZWsgPSB1c2VDYWxsYmFjaygodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgd2FzUGxheWluZyA9IGlzUGxheWluZztcclxuICAgICAgICBpZiAod2FzUGxheWluZykgc3RvcEF1ZGlvSW50ZXJuYWwoKTtcclxuXHJcbiAgICAgICAgcGF1c2VUaW1lUmVmLmN1cnJlbnQgPSB0aW1lO1xyXG4gICAgICAgIHNldEN1cnJlbnRUaW1lKHRpbWUpO1xyXG5cclxuICAgICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LmN1cnJlbnRUaW1lID0gdGltZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh3YXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHBsYXlBdWRpbyh0aW1lKTtcclxuICAgICAgICAgICAgc3RhcnRUaW1lUmVmLmN1cnJlbnQgPSBhdWRpb0NvbnRleHRSZWYuY3VycmVudCEuY3VycmVudFRpbWUgLSB0aW1lO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtpc1BsYXlpbmcsIHBsYXlBdWRpb10pO1xyXG5cclxuICAgIC8vIExpdmUgVm9sdW1lL011dGUvU29sbyB1cGRhdGVzXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGFueVNvbG8gPSB0cmFja3Muc29tZSh0ID0+IHQuc29sb2VkKTtcclxuXHJcbiAgICAgICAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzaG91bGRMb2dpY2FsbHlNdXRlID0gdHJhY2subXV0ZWQgfHwgKGFueVNvbG8gJiYgIXRyYWNrLnNvbG9lZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFZvbHVtZSA9IHNob3VsZExvZ2ljYWxseU11dGUgPyAwIDogdHJhY2sudm9sdW1lO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRyYWNrLm5hbWUgPT09IFwiVklERU8gVFJBQ0tcIiAmJiB2aWRlb1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LnZvbHVtZSA9IHRhcmdldFZvbHVtZSAqIG1hc3RlclZvbHVtZTtcclxuICAgICAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQubXV0ZWQgPSBzaG91bGRMb2dpY2FsbHlNdXRlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2Fpbk5vZGUgPSBnYWluTm9kZXNSZWYuY3VycmVudC5nZXQodHJhY2suaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdhaW5Ob2RlICYmIGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2Fpbk5vZGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQuY3VycmVudFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdhaW5Ob2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHRhcmdldFZvbHVtZSwgYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQuY3VycmVudFRpbWUsIDAuMDUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LCBbdHJhY2tzLCBtYXN0ZXJWb2x1bWVdKTtcclxuXHJcbiAgICBjb25zdCBzZXRUcmFja1ZvbHVtZSA9IChpZDogc3RyaW5nLCB2b2x1bWU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIHNldFRyYWNrcyhwcmV2ID0+IHByZXYubWFwKHQgPT4gdC5pZCA9PT0gaWQgPyB7IC4uLnQsIHZvbHVtZSB9IDogdCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB0b2dnbGVUcmFja011dGUgPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHNldFRyYWNrcyhwcmV2ID0+IHByZXYubWFwKHQgPT4gdC5pZCA9PT0gaWQgPyB7IC4uLnQsIG11dGVkOiAhdC5tdXRlZCB9IDogdCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCB0b2dnbGVUcmFja1NvbG8gPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHNldFRyYWNrcyhwcmV2ID0+IHByZXYubWFwKHQgPT4gdC5pZCA9PT0gaWQgPyB7IC4uLnQsIHNvbG9lZDogIXQuc29sb2VkIH0gOiB0KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHJlbW92ZVRyYWNrID0gKGlkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBzZXRUcmFja3MocHJldiA9PiBwcmV2LmZpbHRlcih0ID0+IHQuaWQgIT09IGlkKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFBsYXlsaXN0IG1hbmFnZW1lbnRcclxuICAgIGNvbnN0IGFkZFNvbmdUb1BsYXlsaXN0ID0gdXNlQ2FsbGJhY2soKHNvbmc6IFNvbmcpID0+IHtcclxuICAgICAgICBzZXRQbGF5bGlzdChwcmV2ID0+IFsuLi5wcmV2LCBzb25nXSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgc2V0UGxheWxpc3QocHJldiA9PiBwcmV2LmZpbHRlcihzID0+IHMuaWQgIT09IGlkKSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgbG9hZFNvbmcgPSB1c2VDYWxsYmFjayhhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNvbmcgPSBwbGF5bGlzdC5maW5kKHMgPT4gcy5pZCA9PT0gaWQpO1xyXG4gICAgICAgIGlmICghc29uZykgcmV0dXJuO1xyXG5cclxuICAgICAgICAvLyBTdG9wIGN1cnJlbnQgcGxheWJhY2sgYW5kIGNsZWFyIHRyYWNrc1xyXG4gICAgICAgIHN0b3BBdWRpb0ludGVybmFsKCk7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVSZWYuY3VycmVudCEpO1xyXG4gICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XHJcbiAgICAgICAgc2V0Q3VycmVudFRpbWUoMCk7XHJcbiAgICAgICAgcGF1c2VUaW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIHNldER1cmF0aW9uKDApO1xyXG4gICAgICAgIHNldFRyYWNrcyhbXSk7XHJcbiAgICAgICAgc2V0QWN0aXZlU29uZ0lkKGlkKTtcclxuXHJcbiAgICAgICAgLy8gTG9hZCBhbGwgc3RlbSBmaWxlc1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3RlbUZpbGUgb2Ygc29uZy5zdGVtRmlsZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2tOYW1lID0gc3RlbUZpbGUubmFtZS5yZXBsYWNlKC9cXC4od2F2fG1wMykkL2ksICcnKTtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVHJhY2soc3RlbUZpbGUsIHRyYWNrTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2FkIHZpZGVvIGlmIHByZXNlbnRcclxuICAgICAgICBpZiAoc29uZy52aWRlb0ZpbGUpIHtcclxuICAgICAgICAgICAgYXdhaXQgYWRkVmlkZW9UcmFjayhzb25nLnZpZGVvRmlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3BsYXlsaXN0LCBhZGRUcmFjaywgYWRkVmlkZW9UcmFja10pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPEF1ZGlvRW5naW5lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xyXG4gICAgICAgICAgICB0cmFja3MsXHJcbiAgICAgICAgICAgIGlzUGxheWluZyxcclxuICAgICAgICAgICAgY3VycmVudFRpbWUsXHJcbiAgICAgICAgICAgIGR1cmF0aW9uLFxyXG4gICAgICAgICAgICBhZGRUcmFjayxcclxuICAgICAgICAgICAgYWRkVmlkZW9UcmFjayxcclxuICAgICAgICAgICAgcmVtb3ZlVHJhY2ssXHJcbiAgICAgICAgICAgIGNsZWFyVHJhY2tzLFxyXG4gICAgICAgICAgICB0b2dnbGVQbGF5LFxyXG4gICAgICAgICAgICBzdG9wLFxyXG4gICAgICAgICAgICBzZWVrLFxyXG4gICAgICAgICAgICBzZXRUcmFja1ZvbHVtZSxcclxuICAgICAgICAgICAgdG9nZ2xlVHJhY2tNdXRlLFxyXG4gICAgICAgICAgICB0b2dnbGVUcmFja1NvbG8sXHJcbiAgICAgICAgICAgIHNldFZpZGVvRWxlbWVudDogKGVsKSA9PiB2aWRlb1JlZi5jdXJyZW50ID0gZWwsXHJcbiAgICAgICAgICAgIG1hc3RlclZvbHVtZSxcclxuICAgICAgICAgICAgc2V0TWFzdGVyVm9sdW1lLFxyXG4gICAgICAgICAgICBwbGF5bGlzdCxcclxuICAgICAgICAgICAgYWN0aXZlU29uZ0lkLFxyXG4gICAgICAgICAgICBhZGRTb25nVG9QbGF5bGlzdCxcclxuICAgICAgICAgICAgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCxcclxuICAgICAgICAgICAgbG9hZFNvbmdcclxuICAgICAgICB9fT5cclxuICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgIDwvQXVkaW9FbmdpbmVDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgKTtcclxufTtcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwiQXVkaW9FbmdpbmVDb250ZXh0IiwidXNlQXVkaW9FbmdpbmUiLCJjb250ZXh0IiwiRXJyb3IiLCJBdWRpb0VuZ2luZVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ0cmFja3MiLCJzZXRUcmFja3MiLCJpc1BsYXlpbmciLCJzZXRJc1BsYXlpbmciLCJjdXJyZW50VGltZSIsInNldEN1cnJlbnRUaW1lIiwiZHVyYXRpb24iLCJzZXREdXJhdGlvbiIsIm1hc3RlclZvbHVtZSIsInNldE1hc3RlclZvbHVtZSIsInZpZGVvRHVyYXRpb24iLCJzZXRWaWRlb0R1cmF0aW9uIiwicGxheWxpc3QiLCJzZXRQbGF5bGlzdCIsImFjdGl2ZVNvbmdJZCIsInNldEFjdGl2ZVNvbmdJZCIsImF1ZGlvQ29udGV4dFJlZiIsInNvdXJjZU5vZGVzUmVmIiwiTWFwIiwiZ2Fpbk5vZGVzUmVmIiwibWFzdGVyR2FpblJlZiIsInZpZGVvUmVmIiwic3RhcnRUaW1lUmVmIiwicGF1c2VUaW1lUmVmIiwiYW5pbWF0aW9uRnJhbWVSZWYiLCJkdXJhdGlvblJlZiIsImlzUGxheWluZ1JlZiIsIkF1ZGlvQ3R4Iiwid2luZG93IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0IiwiY3VycmVudCIsImNyZWF0ZUdhaW4iLCJjb25uZWN0IiwiZGVzdGluYXRpb24iLCJjbG9zZSIsImdhaW4iLCJ2YWx1ZSIsImdldFRyYWNrQ29sb3IiLCJuYW1lIiwibiIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJhZGRUcmFjayIsImZpbGUiLCJhcnJheUJ1ZmZlciIsImF1ZGlvQnVmZmVyIiwiZGVjb2RlQXVkaW9EYXRhIiwibmV3VHJhY2siLCJpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJidWZmZXIiLCJ2b2x1bWUiLCJtdXRlZCIsInNvbG9lZCIsImNvbG9yIiwicHJldiIsIk1hdGgiLCJtYXgiLCJlIiwiY29uc29sZSIsImVycm9yIiwiYWRkVmlkZW9UcmFjayIsInZpZGVvRmlsZSIsInVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInZpZGVvVHJhY2siLCJ1bmRlZmluZWQiLCJhdWRpb1RyYWNrIiwic2xpY2UiLCJpc1ZpZGVvQXVkaW8iLCJ3YXJuIiwibmV3VHJhY2tzIiwicHVzaCIsImN1c3RvbUV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJkaXNwYXRjaEV2ZW50IiwidGVtcFZpZGVvIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwib25sb2FkZWRtZXRhZGF0YSIsImNsZWFyVHJhY2tzIiwic3RvcEF1ZGlvSW50ZXJuYWwiLCJmb3JFYWNoIiwic291cmNlIiwic3RvcCIsImNsZWFyIiwicGxheUF1ZGlvIiwic3RhcnRPZmZzZXQiLCJzdGF0ZSIsInJlc3VtZSIsImFueVNvbG8iLCJzb21lIiwidCIsInRyYWNrIiwiY3JlYXRlQnVmZmVyU291cmNlIiwiZ2Fpbk5vZGUiLCJzaG91bGRMb2dpY2FsbHlNdXRlIiwic3RhcnQiLCJzZXQiLCJvbmVuZGVkIiwic3RvcEF1ZGlvIiwidG9nZ2xlUGxheSIsInBhdXNlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJwbGF5IiwiY2F0Y2giLCJ1cGRhdGUiLCJub3ciLCJjYWxjdWxhdGVkVGltZSIsImR1ciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNlZWsiLCJ0aW1lIiwid2FzUGxheWluZyIsInRhcmdldFZvbHVtZSIsImdldCIsImNhbmNlbFNjaGVkdWxlZFZhbHVlcyIsInNldFRhcmdldEF0VGltZSIsInNldFRyYWNrVm9sdW1lIiwibWFwIiwidG9nZ2xlVHJhY2tNdXRlIiwidG9nZ2xlVHJhY2tTb2xvIiwicmVtb3ZlVHJhY2siLCJmaWx0ZXIiLCJhZGRTb25nVG9QbGF5bGlzdCIsInNvbmciLCJyZW1vdmVTb25nRnJvbVBsYXlsaXN0IiwicyIsImxvYWRTb25nIiwiZmluZCIsInN0ZW1GaWxlIiwic3RlbUZpbGVzIiwidHJhY2tOYW1lIiwicmVwbGFjZSIsIlByb3ZpZGVyIiwic2V0VmlkZW9FbGVtZW50IiwiZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useAudioEngine.tsx\n"));

/***/ })

});