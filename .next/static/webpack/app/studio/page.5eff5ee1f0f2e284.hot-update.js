"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/studio/page",{

/***/ "(app-pages-browser)/./hooks/useAudioEngine.tsx":
/*!**********************************!*\
  !*** ./hooks/useAudioEngine.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioEngineProvider: function() { return /* binding */ AudioEngineProvider; },\n/* harmony export */   useAudioEngine: function() { return /* binding */ useAudioEngine; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst AudioEngineContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst useAudioEngine = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AudioEngineContext);\n    if (!context) throw new Error(\"useAudioEngine must be used within AudioEngineProvider\");\n    return context;\n};\n_s(useAudioEngine, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nconst AudioEngineProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const [tracks, setTracks] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentTime, setCurrentTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [duration, setDuration] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [masterVolume, setMasterVolume] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [videoDuration, setVideoDuration] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [playlist, setPlaylist] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeSongId, setActiveSongId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const audioContextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const sourceNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const gainNodesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const masterGainRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const startTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const pauseTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const animationFrameRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const durationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const isPlayingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Initialize AudioContext\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const AudioCtx = window.AudioContext || window.webkitAudioContext;\n        audioContextRef.current = new AudioCtx();\n        masterGainRef.current = audioContextRef.current.createGain();\n        masterGainRef.current.connect(audioContextRef.current.destination);\n        return ()=>{\n            var _audioContextRef_current;\n            (_audioContextRef_current = audioContextRef.current) === null || _audioContextRef_current === void 0 ? void 0 : _audioContextRef_current.close();\n        };\n    }, []);\n    // Keep refs in sync with state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        durationRef.current = duration;\n    }, [\n        duration\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        isPlayingRef.current = isPlaying;\n    }, [\n        isPlaying\n    ]);\n    // Master Volume Effect\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (masterGainRef.current) {\n            masterGainRef.current.gain.value = masterVolume;\n        }\n    }, [\n        masterVolume\n    ]);\n    // Color helper\n    const getTrackColor = (name)=>{\n        const n = name.toLowerCase();\n        if (n.includes(\"drum\") || n.includes(\"bateria\")) return \"#06b6d4\";\n        if (n.includes(\"bass\") || n.includes(\"bajo\")) return \"#0d9488\";\n        if (n.includes(\"vox\") || n.includes(\"voz\") || n.includes(\"vocal\")) return \"#2563eb\";\n        if (n.includes(\"click\")) return \"#dc2626\";\n        if (n.includes(\"key\") || n.includes(\"piano\") || n.includes(\"synth\")) return \"#d946ef\";\n        if (n.includes(\"guitar\") || n.includes(\"guit\")) return \"#f59e0b\";\n        if (n.includes(\"video\")) return \"#a855f7\";\n        return \"#94a3b8\";\n    };\n    const addTrack = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (file, name)=>{\n        if (!audioContextRef.current) return;\n        try {\n            const arrayBuffer = await file.arrayBuffer();\n            const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);\n            const newTrack = {\n                id: crypto.randomUUID(),\n                name,\n                file,\n                buffer: audioBuffer,\n                volume: 1,\n                muted: false,\n                soloed: false,\n                color: getTrackColor(name)\n            };\n            setTracks((prev)=>[\n                    ...prev,\n                    newTrack\n                ]);\n            setDuration((prev)=>Math.max(prev, audioBuffer.duration));\n        } catch (e) {\n            console.error(\"Error decoding audio\", e);\n        }\n    }, []);\n    const addVideoTrack = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (videoFile)=>{\n        if (!audioContextRef.current) return;\n        const url = URL.createObjectURL(videoFile);\n        // 1. Create the visual VIDEO TRACK (no buffer, for timeline thumbnails)\n        const videoTrack = {\n            id: crypto.randomUUID(),\n            name: \"VIDEO TRACK\",\n            file: videoFile,\n            buffer: undefined,\n            volume: 1,\n            muted: false,\n            soloed: false,\n            color: \"#a855f7\"\n        };\n        // 2. Try to extract audio from video and create a separate audio channel\n        let audioTrack = null;\n        try {\n            const arrayBuffer = await videoFile.arrayBuffer();\n            const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer.slice(0));\n            audioTrack = {\n                id: crypto.randomUUID(),\n                name: \"VIDEO AUDIO\",\n                file: videoFile,\n                buffer: audioBuffer,\n                volume: 1,\n                muted: false,\n                soloed: false,\n                color: \"#c084fc\",\n                isVideoAudio: true\n            };\n        } catch (e) {\n            console.warn(\"Video has no extractable audio or decode failed:\", e);\n        }\n        setTracks((prev)=>{\n            const newTracks = [\n                ...prev,\n                videoTrack\n            ];\n            if (audioTrack) newTracks.push(audioTrack);\n            return newTracks;\n        });\n        // Emit event for the UI to catch and set video src\n        const customEvent = new CustomEvent(\"video-uploaded\", {\n            detail: url\n        });\n        window.dispatchEvent(customEvent);\n        // Get video duration (store separately, do NOT extend master duration)\n        const tempVideo = document.createElement(\"video\");\n        tempVideo.src = url;\n        tempVideo.onloadedmetadata = ()=>{\n            setVideoDuration(tempVideo.duration);\n            // Only use video duration if there are NO audio tracks yet\n            setDuration((prev)=>{\n                if (prev === 0) return tempVideo.duration; // No audio, use video duration\n                return prev; // Audio exists, keep audio duration as master\n            });\n        };\n    }, []);\n    const clearTracks = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        stopAudioInternal();\n        setTracks([]);\n        setDuration(0);\n        setVideoDuration(0);\n        setCurrentTime(0);\n        pauseTimeRef.current = 0;\n        setIsPlaying(false);\n    }, []);\n    const stopAudioInternal = ()=>{\n        sourceNodesRef.current.forEach((source)=>{\n            try {\n                source.stop();\n            } catch (e) {}\n        });\n        sourceNodesRef.current.clear();\n        gainNodesRef.current.clear();\n    };\n    const playAudio = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((startOffset)=>{\n        if (!audioContextRef.current || !masterGainRef.current) return;\n        if (audioContextRef.current.state === \"suspended\") {\n            audioContextRef.current.resume();\n        }\n        const anySolo = tracks.some((t)=>t.soloed);\n        tracks.forEach((track)=>{\n            if (!track.buffer) return; // Skip VIDEO TRACK (no buffer)\n            const source = audioContextRef.current.createBufferSource();\n            source.buffer = track.buffer;\n            const gainNode = audioContextRef.current.createGain();\n            const shouldLogicallyMute = track.muted || anySolo && !track.soloed;\n            gainNode.gain.value = shouldLogicallyMute ? 0 : track.volume;\n            source.connect(gainNode);\n            gainNode.connect(masterGainRef.current);\n            source.start(0, startOffset);\n            sourceNodesRef.current.set(track.id, source);\n            gainNodesRef.current.set(track.id, gainNode);\n            source.onended = ()=>{};\n        });\n    }, [\n        tracks\n    ]);\n    const stopAudio = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        stopAudioInternal();\n    }, []);\n    const togglePlay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (isPlayingRef.current) {\n            stopAudioInternal();\n            pauseTimeRef.current = currentTime;\n            if (videoRef.current) videoRef.current.pause();\n            cancelAnimationFrame(animationFrameRef.current);\n            setIsPlaying(false);\n            isPlayingRef.current = false;\n        } else {\n            let start = pauseTimeRef.current;\n            if (start >= durationRef.current && durationRef.current > 0) {\n                start = 0;\n                pauseTimeRef.current = 0;\n            }\n            playAudio(start);\n            startTimeRef.current = audioContextRef.current.currentTime - start;\n            if (videoRef.current) {\n                videoRef.current.currentTime = start;\n                videoRef.current.play().catch((e)=>console.error(\"Video play failed\", e));\n            }\n            setIsPlaying(true);\n            isPlayingRef.current = true;\n            const update = ()=>{\n                var _audioContextRef_current;\n                if (!isPlayingRef.current) return; // Guard: if stopped externally\n                const now = (_audioContextRef_current = audioContextRef.current) === null || _audioContextRef_current === void 0 ? void 0 : _audioContextRef_current.currentTime;\n                if (now === undefined) return;\n                const calculatedTime = now - startTimeRef.current;\n                const dur = durationRef.current;\n                if (calculatedTime >= dur && dur > 0) {\n                    // Song ended â€” stop everything\n                    stopAudioInternal();\n                    if (videoRef.current) {\n                        videoRef.current.pause();\n                        videoRef.current.currentTime = 0;\n                    }\n                    pauseTimeRef.current = 0;\n                    setCurrentTime(0);\n                    setIsPlaying(false);\n                    isPlayingRef.current = false;\n                    return;\n                }\n                setCurrentTime(calculatedTime);\n                animationFrameRef.current = requestAnimationFrame(update);\n            };\n            animationFrameRef.current = requestAnimationFrame(update);\n        }\n    }, [\n        currentTime,\n        playAudio\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        stopAudioInternal();\n        if (videoRef.current) {\n            videoRef.current.pause();\n            videoRef.current.currentTime = 0;\n        }\n        pauseTimeRef.current = 0;\n        setCurrentTime(0);\n        setIsPlaying(false);\n        cancelAnimationFrame(animationFrameRef.current);\n    }, []);\n    const seek = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((time)=>{\n        const wasPlaying = isPlaying;\n        if (wasPlaying) stopAudioInternal();\n        pauseTimeRef.current = time;\n        setCurrentTime(time);\n        if (videoRef.current) {\n            videoRef.current.currentTime = time;\n        }\n        if (wasPlaying) {\n            playAudio(time);\n            startTimeRef.current = audioContextRef.current.currentTime - time;\n        }\n    }, [\n        isPlaying,\n        playAudio\n    ]);\n    // Live Volume/Mute/Solo updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const anySolo = tracks.some((t)=>t.soloed);\n        tracks.forEach((track)=>{\n            const shouldLogicallyMute = track.muted || anySolo && !track.soloed;\n            const targetVolume = shouldLogicallyMute ? 0 : track.volume;\n            if (track.name === \"VIDEO TRACK\" && videoRef.current) {\n                videoRef.current.volume = targetVolume * masterVolume;\n                videoRef.current.muted = shouldLogicallyMute;\n            } else {\n                const gainNode = gainNodesRef.current.get(track.id);\n                if (gainNode && audioContextRef.current) {\n                    gainNode.gain.cancelScheduledValues(audioContextRef.current.currentTime);\n                    gainNode.gain.setTargetAtTime(targetVolume, audioContextRef.current.currentTime, 0.05);\n                }\n            }\n        });\n    }, [\n        tracks,\n        masterVolume\n    ]);\n    const setTrackVolume = (id, volume)=>{\n        setTracks((prev)=>prev.map((t)=>t.id === id ? {\n                    ...t,\n                    volume\n                } : t));\n    };\n    const toggleTrackMute = (id)=>{\n        setTracks((prev)=>prev.map((t)=>t.id === id ? {\n                    ...t,\n                    muted: !t.muted\n                } : t));\n    };\n    const toggleTrackSolo = (id)=>{\n        setTracks((prev)=>prev.map((t)=>t.id === id ? {\n                    ...t,\n                    soloed: !t.soloed\n                } : t));\n    };\n    const removeTrack = (id)=>{\n        setTracks((prev)=>prev.filter((t)=>t.id !== id));\n    };\n    // Trim video to match audio duration\n    const trimVideoToAudio = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        // Recalculate duration based only on audio tracks\n        const audioTracks = tracks.filter((t)=>t.buffer && !t.name.includes(\"VIDEO\"));\n        if (audioTracks.length > 0) {\n            const audioDur = Math.max(...audioTracks.map((t)=>t.buffer.duration));\n            setDuration(audioDur);\n        }\n    }, [\n        tracks\n    ]);\n    // Playlist management\n    const addSongToPlaylist = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((song)=>{\n        setPlaylist((prev)=>[\n                ...prev,\n                song\n            ]);\n    }, []);\n    const removeSongFromPlaylist = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((id)=>{\n        setPlaylist((prev)=>prev.filter((s)=>s.id !== id));\n    }, []);\n    const loadSong = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(async (id)=>{\n        const song = playlist.find((s)=>s.id === id);\n        if (!song) return;\n        // Stop current playback and clear tracks\n        stopAudioInternal();\n        cancelAnimationFrame(animationFrameRef.current);\n        setIsPlaying(false);\n        setCurrentTime(0);\n        pauseTimeRef.current = 0;\n        setDuration(0);\n        setTracks([]);\n        setActiveSongId(id);\n        // Load all stem files\n        for (const stemFile of song.stemFiles){\n            const trackName = stemFile.name.replace(/\\.(wav|mp3)$/i, \"\");\n            await addTrack(stemFile, trackName);\n        }\n        // Load video if present\n        if (song.videoFile) {\n            await addVideoTrack(song.videoFile);\n        }\n    }, [\n        playlist,\n        addTrack,\n        addVideoTrack\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AudioEngineContext.Provider, {\n        value: {\n            tracks,\n            isPlaying,\n            currentTime,\n            duration,\n            addTrack,\n            addVideoTrack,\n            removeTrack,\n            clearTracks,\n            togglePlay,\n            stop,\n            seek,\n            setTrackVolume,\n            toggleTrackMute,\n            toggleTrackSolo,\n            setVideoElement: (el)=>videoRef.current = el,\n            masterVolume,\n            setMasterVolume,\n            playlist,\n            activeSongId,\n            addSongToPlaylist,\n            removeSongFromPlaylist,\n            loadSong,\n            videoDuration,\n            trimVideoToAudio\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\Efren\\\\Documents\\\\Proyectos\\\\multivideotrack\\\\hooks\\\\useAudioEngine.tsx\",\n        lineNumber: 423,\n        columnNumber: 9\n    }, undefined);\n};\n_s1(AudioEngineProvider, \"cz3yI6HdfK9cbryvorWK4TfVS+g=\");\n_c = AudioEngineProvider;\nvar _c;\n$RefreshReg$(_c, \"AudioEngineProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZUF1ZGlvRW5naW5lLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1HO0FBcURuRyxNQUFNTyxtQ0FBcUJOLG9EQUFhQSxDQUFnQztBQUVqRSxNQUFNTyxpQkFBaUI7O0lBQzFCLE1BQU1DLFVBQVVQLGlEQUFVQSxDQUFDSztJQUMzQixJQUFJLENBQUNFLFNBQVMsTUFBTSxJQUFJQyxNQUFNO0lBQzlCLE9BQU9EO0FBQ1gsRUFBRTtHQUpXRDtBQU1OLE1BQU1HLHNCQUErRDtRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDckYsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdWLCtDQUFRQSxDQUFVLEVBQUU7SUFDaEQsTUFBTSxDQUFDVyxXQUFXQyxhQUFhLEdBQUdaLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2EsYUFBYUMsZUFBZSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNlLFVBQVVDLFlBQVksR0FBR2hCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQ2lCLGNBQWNDLGdCQUFnQixHQUFHbEIsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDbUIsZUFBZUMsaUJBQWlCLEdBQUdwQiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNxQixVQUFVQyxZQUFZLEdBQUd0QiwrQ0FBUUEsQ0FBUyxFQUFFO0lBQ25ELE1BQU0sQ0FBQ3VCLGNBQWNDLGdCQUFnQixHQUFHeEIsK0NBQVFBLENBQWdCO0lBRWhFLE1BQU15QixrQkFBa0IxQiw2Q0FBTUEsQ0FBc0I7SUFDcEQsTUFBTTJCLGlCQUFpQjNCLDZDQUFNQSxDQUFxQyxJQUFJNEI7SUFDdEUsTUFBTUMsZUFBZTdCLDZDQUFNQSxDQUF3QixJQUFJNEI7SUFDdkQsTUFBTUUsZ0JBQWdCOUIsNkNBQU1BLENBQWtCO0lBQzlDLE1BQU0rQixXQUFXL0IsNkNBQU1BLENBQTBCO0lBQ2pELE1BQU1nQyxlQUFlaEMsNkNBQU1BLENBQVM7SUFD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S3RFLFNBQVM7UUFDdEM7SUFDSixHQUFHO1FBQUNwRDtRQUFVK0I7UUFBVW9CO0tBQWM7SUFFdEMscUJBQ0ksOERBQUNyRSxtQkFBbUJxSixRQUFRO1FBQUMxRyxPQUFPO1lBQ2hDckM7WUFDQUU7WUFDQUU7WUFDQUU7WUFDQXFDO1lBQ0FvQjtZQUNBZ0U7WUFDQTFDO1lBQ0FxQjtZQUNBakI7WUFDQTJCO1lBQ0FPO1lBQ0FFO1lBQ0FDO1lBQ0FrQixpQkFBaUIsQ0FBQ0MsS0FBTzVILFNBQVNVLE9BQU8sR0FBR2tIO1lBQzVDekk7WUFDQUM7WUFDQUc7WUFDQUU7WUFDQXVIO1lBQ0FFO1lBQ0FFO1lBQ0EvSDtZQUNBdUg7UUFDSjtrQkFDS2xJOzs7Ozs7QUFHYixFQUFFO0lBdFlXRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ob29rcy91c2VBdWRpb0VuZ2luZS50c3g/MTBmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuXHJcbi8vIFR5cGVzXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhY2sge1xyXG4gICAgaWQ6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGZpbGU6IEZpbGU7XHJcbiAgICBidWZmZXI/OiBBdWRpb0J1ZmZlcjtcclxuICAgIHZvbHVtZTogbnVtYmVyO1xyXG4gICAgbXV0ZWQ6IGJvb2xlYW47XHJcbiAgICBzb2xvZWQ6IGJvb2xlYW47XHJcbiAgICBjb2xvcjogc3RyaW5nO1xyXG4gICAgaXNWaWRlb0F1ZGlvPzogYm9vbGVhbjsgLy8gRmxhZyBmb3IgdGhlIGV4dHJhY3RlZCBhdWRpbyBmcm9tIHZpZGVvXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgU29uZyB7XHJcbiAgICBpZDogc3RyaW5nO1xyXG4gICAgdGl0bGU6IHN0cmluZztcclxuICAgIGFydGlzdDogc3RyaW5nO1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICBicG06IG51bWJlcjtcclxuICAgIHN0ZW1GaWxlczogRmlsZVtdO1xyXG4gICAgdmlkZW9GaWxlPzogRmlsZTtcclxufVxyXG5cclxuaW50ZXJmYWNlIEF1ZGlvRW5naW5lQ29udGV4dFR5cGUge1xyXG4gICAgdHJhY2tzOiBUcmFja1tdO1xyXG4gICAgaXNQbGF5aW5nOiBib29sZWFuO1xyXG4gICAgY3VycmVudFRpbWU6IG51bWJlcjtcclxuICAgIGR1cmF0aW9uOiBudW1iZXI7XHJcbiAgICBhZGRUcmFjazogKGZpbGU6IEZpbGUsIG5hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcclxuICAgIGFkZFZpZGVvVHJhY2s6IChmaWxlOiBGaWxlKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG4gICAgcmVtb3ZlVHJhY2s6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xyXG4gICAgY2xlYXJUcmFja3M6ICgpID0+IHZvaWQ7XHJcbiAgICB0b2dnbGVQbGF5OiAoKSA9PiB2b2lkO1xyXG4gICAgc3RvcDogKCkgPT4gdm9pZDtcclxuICAgIHNlZWs6ICh0aW1lOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgICBzZXRUcmFja1ZvbHVtZTogKGlkOiBzdHJpbmcsIHZvbHVtZTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gICAgdG9nZ2xlVHJhY2tNdXRlOiAoaWQ6IHN0cmluZykgPT4gdm9pZDtcclxuICAgIHRvZ2dsZVRyYWNrU29sbzogKGlkOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgICBzZXRWaWRlb0VsZW1lbnQ6IChlbGVtZW50OiBIVE1MVmlkZW9FbGVtZW50IHwgbnVsbCkgPT4gdm9pZDtcclxuICAgIG1hc3RlclZvbHVtZTogbnVtYmVyO1xyXG4gICAgc2V0TWFzdGVyVm9sdW1lOiAodmFsOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgICB2aWRlb0R1cmF0aW9uOiBudW1iZXI7IC8vIE9yaWdpbmFsIHZpZGVvIGR1cmF0aW9uIChtYXkgYmUgbG9uZ2VyIHRoYW4gYXVkaW8pXHJcbiAgICB0cmltVmlkZW9Ub0F1ZGlvOiAoKSA9PiB2b2lkOyAvLyBUcmltIHZpZGVvIHRvIG1hdGNoIGF1ZGlvIGR1cmF0aW9uXHJcbiAgICAvLyBQbGF5bGlzdFxyXG4gICAgcGxheWxpc3Q6IFNvbmdbXTtcclxuICAgIGFjdGl2ZVNvbmdJZDogc3RyaW5nIHwgbnVsbDtcclxuICAgIGFkZFNvbmdUb1BsYXlsaXN0OiAoc29uZzogU29uZykgPT4gdm9pZDtcclxuICAgIHJlbW92ZVNvbmdGcm9tUGxheWxpc3Q6IChpZDogc3RyaW5nKSA9PiB2b2lkO1xyXG4gICAgbG9hZFNvbmc6IChpZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xyXG59XHJcblxyXG5jb25zdCBBdWRpb0VuZ2luZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PEF1ZGlvRW5naW5lQ29udGV4dFR5cGUgfCBudWxsPihudWxsKTtcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VBdWRpb0VuZ2luZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEF1ZGlvRW5naW5lQ29udGV4dCk7XHJcbiAgICBpZiAoIWNvbnRleHQpIHRocm93IG5ldyBFcnJvcigndXNlQXVkaW9FbmdpbmUgbXVzdCBiZSB1c2VkIHdpdGhpbiBBdWRpb0VuZ2luZVByb3ZpZGVyJyk7XHJcbiAgICByZXR1cm4gY29udGV4dDtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBBdWRpb0VuZ2luZVByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XHJcbiAgICBjb25zdCBbdHJhY2tzLCBzZXRUcmFja3NdID0gdXNlU3RhdGU8VHJhY2tbXT4oW10pO1xyXG4gICAgY29uc3QgW2lzUGxheWluZywgc2V0SXNQbGF5aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtjdXJyZW50VGltZSwgc2V0Q3VycmVudFRpbWVdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbZHVyYXRpb24sIHNldER1cmF0aW9uXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW21hc3RlclZvbHVtZSwgc2V0TWFzdGVyVm9sdW1lXSA9IHVzZVN0YXRlKDEpO1xyXG4gICAgY29uc3QgW3ZpZGVvRHVyYXRpb24sIHNldFZpZGVvRHVyYXRpb25dID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbcGxheWxpc3QsIHNldFBsYXlsaXN0XSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pO1xyXG4gICAgY29uc3QgW2FjdGl2ZVNvbmdJZCwgc2V0QWN0aXZlU29uZ0lkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IGF1ZGlvQ29udGV4dFJlZiA9IHVzZVJlZjxBdWRpb0NvbnRleHQgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IHNvdXJjZU5vZGVzUmVmID0gdXNlUmVmPE1hcDxzdHJpbmcsIEF1ZGlvQnVmZmVyU291cmNlTm9kZT4+KG5ldyBNYXAoKSk7XHJcbiAgICBjb25zdCBnYWluTm9kZXNSZWYgPSB1c2VSZWY8TWFwPHN0cmluZywgR2Fpbk5vZGU+PihuZXcgTWFwKCkpO1xyXG4gICAgY29uc3QgbWFzdGVyR2FpblJlZiA9IHVzZVJlZjxHYWluTm9kZSB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWY8SFRNTFZpZGVvRWxlbWVudCB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3Qgc3RhcnRUaW1lUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgICBjb25zdCBwYXVzZVRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICAgIGNvbnN0IGFuaW1hdGlvbkZyYW1lUmVmID0gdXNlUmVmPG51bWJlcj4oKTtcclxuICAgIGNvbnN0IGR1cmF0aW9uUmVmID0gdXNlUmVmPG51bWJlcj4oMCk7XHJcbiAgICBjb25zdCBpc1BsYXlpbmdSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgQXVkaW9Db250ZXh0XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IEF1ZGlvQ3R4ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCAod2luZG93IGFzIGFueSkud2Via2l0QXVkaW9Db250ZXh0O1xyXG4gICAgICAgIGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50ID0gbmV3IEF1ZGlvQ3R4KCk7XHJcbiAgICAgICAgbWFzdGVyR2FpblJlZi5jdXJyZW50ID0gYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIG1hc3RlckdhaW5SZWYuY3VycmVudC5jb25uZWN0KGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICBhdWRpb0NvbnRleHRSZWYuY3VycmVudD8uY2xvc2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIEtlZXAgcmVmcyBpbiBzeW5jIHdpdGggc3RhdGVcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7IGR1cmF0aW9uUmVmLmN1cnJlbnQgPSBkdXJhdGlvbjsgfSwgW2R1cmF0aW9uXSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4geyBpc1BsYXlpbmdSZWYuY3VycmVudCA9IGlzUGxheWluZzsgfSwgW2lzUGxheWluZ10pO1xyXG5cclxuICAgIC8vIE1hc3RlciBWb2x1bWUgRWZmZWN0XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChtYXN0ZXJHYWluUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgbWFzdGVyR2FpblJlZi5jdXJyZW50LmdhaW4udmFsdWUgPSBtYXN0ZXJWb2x1bWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW21hc3RlclZvbHVtZV0pO1xyXG5cclxuICAgIC8vIENvbG9yIGhlbHBlclxyXG4gICAgY29uc3QgZ2V0VHJhY2tDb2xvciA9IChuYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCBuID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChuLmluY2x1ZGVzKCdkcnVtJykgfHwgbi5pbmNsdWRlcygnYmF0ZXJpYScpKSByZXR1cm4gJyMwNmI2ZDQnO1xyXG4gICAgICAgIGlmIChuLmluY2x1ZGVzKCdiYXNzJykgfHwgbi5pbmNsdWRlcygnYmFqbycpKSByZXR1cm4gJyMwZDk0ODgnO1xyXG4gICAgICAgIGlmIChuLmluY2x1ZGVzKCd2b3gnKSB8fCBuLmluY2x1ZGVzKCd2b3onKSB8fCBuLmluY2x1ZGVzKCd2b2NhbCcpKSByZXR1cm4gJyMyNTYzZWInO1xyXG4gICAgICAgIGlmIChuLmluY2x1ZGVzKCdjbGljaycpKSByZXR1cm4gJyNkYzI2MjYnO1xyXG4gICAgICAgIGlmIChuLmluY2x1ZGVzKCdrZXknKSB8fCBuLmluY2x1ZGVzKCdwaWFubycpIHx8IG4uaW5jbHVkZXMoJ3N5bnRoJykpIHJldHVybiAnI2Q5NDZlZic7XHJcbiAgICAgICAgaWYgKG4uaW5jbHVkZXMoJ2d1aXRhcicpIHx8IG4uaW5jbHVkZXMoJ2d1aXQnKSkgcmV0dXJuICcjZjU5ZTBiJztcclxuICAgICAgICBpZiAobi5pbmNsdWRlcygndmlkZW8nKSkgcmV0dXJuICcjYTg1NWY3JztcclxuICAgICAgICByZXR1cm4gJyM5NGEzYjgnO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBhZGRUcmFjayA9IHVzZUNhbGxiYWNrKGFzeW5jIChmaWxlOiBGaWxlLCBuYW1lOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBpZiAoIWF1ZGlvQ29udGV4dFJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBhdWRpb0J1ZmZlciA9IGF3YWl0IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LmRlY29kZUF1ZGlvRGF0YShhcnJheUJ1ZmZlcik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBuZXdUcmFjazogVHJhY2sgPSB7XHJcbiAgICAgICAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICBmaWxlLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyOiBhdWRpb0J1ZmZlcixcclxuICAgICAgICAgICAgICAgIHZvbHVtZTogMSxcclxuICAgICAgICAgICAgICAgIG11dGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHNvbG9lZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogZ2V0VHJhY2tDb2xvcihuYW1lKVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgc2V0VHJhY2tzKHByZXYgPT4gWy4uLnByZXYsIG5ld1RyYWNrXSk7XHJcbiAgICAgICAgICAgIHNldER1cmF0aW9uKHByZXYgPT4gTWF0aC5tYXgocHJldiwgYXVkaW9CdWZmZXIuZHVyYXRpb24pKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkZWNvZGluZyBhdWRpb1wiLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgYWRkVmlkZW9UcmFjayA9IHVzZUNhbGxiYWNrKGFzeW5jICh2aWRlb0ZpbGU6IEZpbGUpID0+IHtcclxuICAgICAgICBpZiAoIWF1ZGlvQ29udGV4dFJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwodmlkZW9GaWxlKTtcclxuXHJcbiAgICAgICAgLy8gMS4gQ3JlYXRlIHRoZSB2aXN1YWwgVklERU8gVFJBQ0sgKG5vIGJ1ZmZlciwgZm9yIHRpbWVsaW5lIHRodW1ibmFpbHMpXHJcbiAgICAgICAgY29uc3QgdmlkZW9UcmFjazogVHJhY2sgPSB7XHJcbiAgICAgICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgICAgICBuYW1lOiBcIlZJREVPIFRSQUNLXCIsXHJcbiAgICAgICAgICAgIGZpbGU6IHZpZGVvRmlsZSxcclxuICAgICAgICAgICAgYnVmZmVyOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHZvbHVtZTogMSxcclxuICAgICAgICAgICAgbXV0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBzb2xvZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb2xvcjogJyNhODU1ZjcnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gMi4gVHJ5IHRvIGV4dHJhY3QgYXVkaW8gZnJvbSB2aWRlbyBhbmQgY3JlYXRlIGEgc2VwYXJhdGUgYXVkaW8gY2hhbm5lbFxyXG4gICAgICAgIGxldCBhdWRpb1RyYWNrOiBUcmFjayB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgdmlkZW9GaWxlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvQnVmZmVyID0gYXdhaXQgYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQuZGVjb2RlQXVkaW9EYXRhKGFycmF5QnVmZmVyLnNsaWNlKDApKTtcclxuXHJcbiAgICAgICAgICAgIGF1ZGlvVHJhY2sgPSB7XHJcbiAgICAgICAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IFwiVklERU8gQVVESU9cIixcclxuICAgICAgICAgICAgICAgIGZpbGU6IHZpZGVvRmlsZSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogYXVkaW9CdWZmZXIsXHJcbiAgICAgICAgICAgICAgICB2b2x1bWU6IDEsXHJcbiAgICAgICAgICAgICAgICBtdXRlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBzb2xvZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjYzA4NGZjJyxcclxuICAgICAgICAgICAgICAgIGlzVmlkZW9BdWRpbzogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmlkZW8gaGFzIG5vIGV4dHJhY3RhYmxlIGF1ZGlvIG9yIGRlY29kZSBmYWlsZWQ6XCIsIGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2V0VHJhY2tzKHByZXYgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdUcmFja3MgPSBbLi4ucHJldiwgdmlkZW9UcmFja107XHJcbiAgICAgICAgICAgIGlmIChhdWRpb1RyYWNrKSBuZXdUcmFja3MucHVzaChhdWRpb1RyYWNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld1RyYWNrcztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gRW1pdCBldmVudCBmb3IgdGhlIFVJIHRvIGNhdGNoIGFuZCBzZXQgdmlkZW8gc3JjXHJcbiAgICAgICAgY29uc3QgY3VzdG9tRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3ZpZGVvLXVwbG9hZGVkJywgeyBkZXRhaWw6IHVybCB9KTtcclxuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChjdXN0b21FdmVudCk7XHJcblxyXG4gICAgICAgIC8vIEdldCB2aWRlbyBkdXJhdGlvbiAoc3RvcmUgc2VwYXJhdGVseSwgZG8gTk9UIGV4dGVuZCBtYXN0ZXIgZHVyYXRpb24pXHJcbiAgICAgICAgY29uc3QgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuICAgICAgICB0ZW1wVmlkZW8uc3JjID0gdXJsO1xyXG4gICAgICAgIHRlbXBWaWRlby5vbmxvYWRlZG1ldGFkYXRhID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRWaWRlb0R1cmF0aW9uKHRlbXBWaWRlby5kdXJhdGlvbik7XHJcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIHZpZGVvIGR1cmF0aW9uIGlmIHRoZXJlIGFyZSBOTyBhdWRpbyB0cmFja3MgeWV0XHJcbiAgICAgICAgICAgIHNldER1cmF0aW9uKHByZXYgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYgPT09IDApIHJldHVybiB0ZW1wVmlkZW8uZHVyYXRpb247IC8vIE5vIGF1ZGlvLCB1c2UgdmlkZW8gZHVyYXRpb25cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2OyAvLyBBdWRpbyBleGlzdHMsIGtlZXAgYXVkaW8gZHVyYXRpb24gYXMgbWFzdGVyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY2xlYXJUcmFja3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc3RvcEF1ZGlvSW50ZXJuYWwoKTtcclxuICAgICAgICBzZXRUcmFja3MoW10pO1xyXG4gICAgICAgIHNldER1cmF0aW9uKDApO1xyXG4gICAgICAgIHNldFZpZGVvRHVyYXRpb24oMCk7XHJcbiAgICAgICAgc2V0Q3VycmVudFRpbWUoMCk7XHJcbiAgICAgICAgcGF1c2VUaW1lUmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3Qgc3RvcEF1ZGlvSW50ZXJuYWwgPSAoKSA9PiB7XHJcbiAgICAgICAgc291cmNlTm9kZXNSZWYuY3VycmVudC5mb3JFYWNoKHNvdXJjZSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7IHNvdXJjZS5zdG9wKCk7IH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNvdXJjZU5vZGVzUmVmLmN1cnJlbnQuY2xlYXIoKTtcclxuICAgICAgICBnYWluTm9kZXNSZWYuY3VycmVudC5jbGVhcigpO1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBwbGF5QXVkaW8gPSB1c2VDYWxsYmFjaygoc3RhcnRPZmZzZXQ6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGlmICghYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQgfHwgIW1hc3RlckdhaW5SZWYuY3VycmVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XHJcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50LnJlc3VtZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYW55U29sbyA9IHRyYWNrcy5zb21lKHQgPT4gdC5zb2xvZWQpO1xyXG5cclxuICAgICAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdHJhY2suYnVmZmVyKSByZXR1cm47IC8vIFNraXAgVklERU8gVFJBQ0sgKG5vIGJ1ZmZlcilcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50IS5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgc291cmNlLmJ1ZmZlciA9IHRyYWNrLmJ1ZmZlcjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGdhaW5Ob2RlID0gYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQhLmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkTG9naWNhbGx5TXV0ZSA9IHRyYWNrLm11dGVkIHx8IChhbnlTb2xvICYmICF0cmFjay5zb2xvZWQpO1xyXG4gICAgICAgICAgICBnYWluTm9kZS5nYWluLnZhbHVlID0gc2hvdWxkTG9naWNhbGx5TXV0ZSA/IDAgOiB0cmFjay52b2x1bWU7XHJcblxyXG4gICAgICAgICAgICBzb3VyY2UuY29ubmVjdChnYWluTm9kZSk7XHJcbiAgICAgICAgICAgIGdhaW5Ob2RlLmNvbm5lY3QobWFzdGVyR2FpblJlZi5jdXJyZW50ISk7XHJcbiAgICAgICAgICAgIHNvdXJjZS5zdGFydCgwLCBzdGFydE9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICBzb3VyY2VOb2Rlc1JlZi5jdXJyZW50LnNldCh0cmFjay5pZCwgc291cmNlKTtcclxuICAgICAgICAgICAgZ2Fpbk5vZGVzUmVmLmN1cnJlbnQuc2V0KHRyYWNrLmlkLCBnYWluTm9kZSk7XHJcblxyXG4gICAgICAgICAgICBzb3VyY2Uub25lbmRlZCA9ICgpID0+IHsgfTtcclxuICAgICAgICB9KTtcclxuICAgIH0sIFt0cmFja3NdKTtcclxuXHJcbiAgICBjb25zdCBzdG9wQXVkaW8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc3RvcEF1ZGlvSW50ZXJuYWwoKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB0b2dnbGVQbGF5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmIChpc1BsYXlpbmdSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBzdG9wQXVkaW9JbnRlcm5hbCgpO1xyXG4gICAgICAgICAgICBwYXVzZVRpbWVSZWYuY3VycmVudCA9IGN1cnJlbnRUaW1lO1xyXG4gICAgICAgICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkgdmlkZW9SZWYuY3VycmVudC5wYXVzZSgpO1xyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ISk7XHJcbiAgICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgIGlzUGxheWluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcGF1c2VUaW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChzdGFydCA+PSBkdXJhdGlvblJlZi5jdXJyZW50ICYmIGR1cmF0aW9uUmVmLmN1cnJlbnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICBwYXVzZVRpbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBsYXlBdWRpbyhzdGFydCk7XHJcbiAgICAgICAgICAgIHN0YXJ0VGltZVJlZi5jdXJyZW50ID0gYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQhLmN1cnJlbnRUaW1lIC0gc3RhcnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmlkZW9SZWYuY3VycmVudC5jdXJyZW50VGltZSA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdmlkZW9SZWYuY3VycmVudC5wbGF5KCkuY2F0Y2goZSA9PiBjb25zb2xlLmVycm9yKFwiVmlkZW8gcGxheSBmYWlsZWRcIiwgZSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBzZXRJc1BsYXlpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGlzUGxheWluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNQbGF5aW5nUmVmLmN1cnJlbnQpIHJldHVybjsgLy8gR3VhcmQ6IGlmIHN0b3BwZWQgZXh0ZXJuYWxseVxyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50Py5jdXJyZW50VGltZTtcclxuICAgICAgICAgICAgICAgIGlmIChub3cgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZFRpbWUgPSBub3cgLSBzdGFydFRpbWVSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGR1ciA9IGR1cmF0aW9uUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWRUaW1lID49IGR1ciAmJiBkdXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU29uZyBlbmRlZCDigJQgc3RvcCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcEF1ZGlvSW50ZXJuYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LnBhdXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXVzZVRpbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFRpbWUoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpc1BsYXlpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VGltZShjYWxjdWxhdGVkVGltZSk7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbY3VycmVudFRpbWUsIHBsYXlBdWRpb10pO1xyXG5cclxuICAgIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgc3RvcEF1ZGlvSW50ZXJuYWwoKTtcclxuICAgICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB2aWRlb1JlZi5jdXJyZW50LnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXVzZVRpbWVSZWYuY3VycmVudCA9IDA7XHJcbiAgICAgICAgc2V0Q3VycmVudFRpbWUoMCk7XHJcbiAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKTtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZVJlZi5jdXJyZW50ISk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3Qgc2VlayA9IHVzZUNhbGxiYWNrKCh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgICAgICBjb25zdCB3YXNQbGF5aW5nID0gaXNQbGF5aW5nO1xyXG4gICAgICAgIGlmICh3YXNQbGF5aW5nKSBzdG9wQXVkaW9JbnRlcm5hbCgpO1xyXG5cclxuICAgICAgICBwYXVzZVRpbWVSZWYuY3VycmVudCA9IHRpbWU7XHJcbiAgICAgICAgc2V0Q3VycmVudFRpbWUodGltZSk7XHJcblxyXG4gICAgICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSB0aW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHdhc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgcGxheUF1ZGlvKHRpbWUpO1xyXG4gICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9IGF1ZGlvQ29udGV4dFJlZi5jdXJyZW50IS5jdXJyZW50VGltZSAtIHRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2lzUGxheWluZywgcGxheUF1ZGlvXSk7XHJcblxyXG4gICAgLy8gTGl2ZSBWb2x1bWUvTXV0ZS9Tb2xvIHVwZGF0ZXNcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYW55U29sbyA9IHRyYWNrcy5zb21lKHQgPT4gdC5zb2xvZWQpO1xyXG5cclxuICAgICAgICB0cmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZExvZ2ljYWxseU11dGUgPSB0cmFjay5tdXRlZCB8fCAoYW55U29sbyAmJiAhdHJhY2suc29sb2VkKTtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Vm9sdW1lID0gc2hvdWxkTG9naWNhbGx5TXV0ZSA/IDAgOiB0cmFjay52b2x1bWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodHJhY2submFtZSA9PT0gXCJWSURFTyBUUkFDS1wiICYmIHZpZGVvUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZpZGVvUmVmLmN1cnJlbnQudm9sdW1lID0gdGFyZ2V0Vm9sdW1lICogbWFzdGVyVm9sdW1lO1xyXG4gICAgICAgICAgICAgICAgdmlkZW9SZWYuY3VycmVudC5tdXRlZCA9IHNob3VsZExvZ2ljYWxseU11dGU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnYWluTm9kZSA9IGdhaW5Ob2Rlc1JlZi5jdXJyZW50LmdldCh0cmFjay5pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2Fpbk5vZGUgJiYgYXVkaW9Db250ZXh0UmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBnYWluTm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhdWRpb0NvbnRleHRSZWYuY3VycmVudC5jdXJyZW50VGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2Fpbk5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUodGFyZ2V0Vm9sdW1lLCBhdWRpb0NvbnRleHRSZWYuY3VycmVudC5jdXJyZW50VGltZSwgMC4wNSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sIFt0cmFja3MsIG1hc3RlclZvbHVtZV0pO1xyXG5cclxuICAgIGNvbnN0IHNldFRyYWNrVm9sdW1lID0gKGlkOiBzdHJpbmcsIHZvbHVtZTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgc2V0VHJhY2tzKHByZXYgPT4gcHJldi5tYXAodCA9PiB0LmlkID09PSBpZCA/IHsgLi4udCwgdm9sdW1lIH0gOiB0KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHRvZ2dsZVRyYWNrTXV0ZSA9IChpZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgc2V0VHJhY2tzKHByZXYgPT4gcHJldi5tYXAodCA9PiB0LmlkID09PSBpZCA/IHsgLi4udCwgbXV0ZWQ6ICF0Lm11dGVkIH0gOiB0KSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHRvZ2dsZVRyYWNrU29sbyA9IChpZDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgc2V0VHJhY2tzKHByZXYgPT4gcHJldi5tYXAodCA9PiB0LmlkID09PSBpZCA/IHsgLi4udCwgc29sb2VkOiAhdC5zb2xvZWQgfSA6IHQpKTtcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcmVtb3ZlVHJhY2sgPSAoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHNldFRyYWNrcyhwcmV2ID0+IHByZXYuZmlsdGVyKHQgPT4gdC5pZCAhPT0gaWQpKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gVHJpbSB2aWRlbyB0byBtYXRjaCBhdWRpbyBkdXJhdGlvblxyXG4gICAgY29uc3QgdHJpbVZpZGVvVG9BdWRpbyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAvLyBSZWNhbGN1bGF0ZSBkdXJhdGlvbiBiYXNlZCBvbmx5IG9uIGF1ZGlvIHRyYWNrc1xyXG4gICAgICAgIGNvbnN0IGF1ZGlvVHJhY2tzID0gdHJhY2tzLmZpbHRlcih0ID0+IHQuYnVmZmVyICYmICF0Lm5hbWUuaW5jbHVkZXMoXCJWSURFT1wiKSk7XHJcbiAgICAgICAgaWYgKGF1ZGlvVHJhY2tzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgYXVkaW9EdXIgPSBNYXRoLm1heCguLi5hdWRpb1RyYWNrcy5tYXAodCA9PiB0LmJ1ZmZlciEuZHVyYXRpb24pKTtcclxuICAgICAgICAgICAgc2V0RHVyYXRpb24oYXVkaW9EdXIpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0cmFja3NdKTtcclxuXHJcbiAgICAvLyBQbGF5bGlzdCBtYW5hZ2VtZW50XHJcbiAgICBjb25zdCBhZGRTb25nVG9QbGF5bGlzdCA9IHVzZUNhbGxiYWNrKChzb25nOiBTb25nKSA9PiB7XHJcbiAgICAgICAgc2V0UGxheWxpc3QocHJldiA9PiBbLi4ucHJldiwgc29uZ10pO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHJlbW92ZVNvbmdGcm9tUGxheWxpc3QgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHNldFBsYXlsaXN0KHByZXYgPT4gcHJldi5maWx0ZXIocyA9PiBzLmlkICE9PSBpZCkpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGxvYWRTb25nID0gdXNlQ2FsbGJhY2soYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCBzb25nID0gcGxheWxpc3QuZmluZChzID0+IHMuaWQgPT09IGlkKTtcclxuICAgICAgICBpZiAoIXNvbmcpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gU3RvcCBjdXJyZW50IHBsYXliYWNrIGFuZCBjbGVhciB0cmFja3NcclxuICAgICAgICBzdG9wQXVkaW9JbnRlcm5hbCgpO1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lUmVmLmN1cnJlbnQhKTtcclxuICAgICAgICBzZXRJc1BsYXlpbmcoZmFsc2UpO1xyXG4gICAgICAgIHNldEN1cnJlbnRUaW1lKDApO1xyXG4gICAgICAgIHBhdXNlVGltZVJlZi5jdXJyZW50ID0gMDtcclxuICAgICAgICBzZXREdXJhdGlvbigwKTtcclxuICAgICAgICBzZXRUcmFja3MoW10pO1xyXG4gICAgICAgIHNldEFjdGl2ZVNvbmdJZChpZCk7XHJcblxyXG4gICAgICAgIC8vIExvYWQgYWxsIHN0ZW0gZmlsZXNcclxuICAgICAgICBmb3IgKGNvbnN0IHN0ZW1GaWxlIG9mIHNvbmcuc3RlbUZpbGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrTmFtZSA9IHN0ZW1GaWxlLm5hbWUucmVwbGFjZSgvXFwuKHdhdnxtcDMpJC9pLCAnJyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGFkZFRyYWNrKHN0ZW1GaWxlLCB0cmFja05hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTG9hZCB2aWRlbyBpZiBwcmVzZW50XHJcbiAgICAgICAgaWYgKHNvbmcudmlkZW9GaWxlKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGFkZFZpZGVvVHJhY2soc29uZy52aWRlb0ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtwbGF5bGlzdCwgYWRkVHJhY2ssIGFkZFZpZGVvVHJhY2tdKTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxBdWRpb0VuZ2luZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3tcclxuICAgICAgICAgICAgdHJhY2tzLFxyXG4gICAgICAgICAgICBpc1BsYXlpbmcsXHJcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLFxyXG4gICAgICAgICAgICBkdXJhdGlvbixcclxuICAgICAgICAgICAgYWRkVHJhY2ssXHJcbiAgICAgICAgICAgIGFkZFZpZGVvVHJhY2ssXHJcbiAgICAgICAgICAgIHJlbW92ZVRyYWNrLFxyXG4gICAgICAgICAgICBjbGVhclRyYWNrcyxcclxuICAgICAgICAgICAgdG9nZ2xlUGxheSxcclxuICAgICAgICAgICAgc3RvcCxcclxuICAgICAgICAgICAgc2VlayxcclxuICAgICAgICAgICAgc2V0VHJhY2tWb2x1bWUsXHJcbiAgICAgICAgICAgIHRvZ2dsZVRyYWNrTXV0ZSxcclxuICAgICAgICAgICAgdG9nZ2xlVHJhY2tTb2xvLFxyXG4gICAgICAgICAgICBzZXRWaWRlb0VsZW1lbnQ6IChlbCkgPT4gdmlkZW9SZWYuY3VycmVudCA9IGVsLFxyXG4gICAgICAgICAgICBtYXN0ZXJWb2x1bWUsXHJcbiAgICAgICAgICAgIHNldE1hc3RlclZvbHVtZSxcclxuICAgICAgICAgICAgcGxheWxpc3QsXHJcbiAgICAgICAgICAgIGFjdGl2ZVNvbmdJZCxcclxuICAgICAgICAgICAgYWRkU29uZ1RvUGxheWxpc3QsXHJcbiAgICAgICAgICAgIHJlbW92ZVNvbmdGcm9tUGxheWxpc3QsXHJcbiAgICAgICAgICAgIGxvYWRTb25nLFxyXG4gICAgICAgICAgICB2aWRlb0R1cmF0aW9uLFxyXG4gICAgICAgICAgICB0cmltVmlkZW9Ub0F1ZGlvXHJcbiAgICAgICAgfX0+XHJcbiAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICA8L0F1ZGlvRW5naW5lQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICk7XHJcbn07XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIkF1ZGlvRW5naW5lQ29udGV4dCIsInVzZUF1ZGlvRW5naW5lIiwiY29udGV4dCIsIkVycm9yIiwiQXVkaW9FbmdpbmVQcm92aWRlciIsImNoaWxkcmVuIiwidHJhY2tzIiwic2V0VHJhY2tzIiwiaXNQbGF5aW5nIiwic2V0SXNQbGF5aW5nIiwiY3VycmVudFRpbWUiLCJzZXRDdXJyZW50VGltZSIsImR1cmF0aW9uIiwic2V0RHVyYXRpb24iLCJtYXN0ZXJWb2x1bWUiLCJzZXRNYXN0ZXJWb2x1bWUiLCJ2aWRlb0R1cmF0aW9uIiwic2V0VmlkZW9EdXJhdGlvbiIsInBsYXlsaXN0Iiwic2V0UGxheWxpc3QiLCJhY3RpdmVTb25nSWQiLCJzZXRBY3RpdmVTb25nSWQiLCJhdWRpb0NvbnRleHRSZWYiLCJzb3VyY2VOb2Rlc1JlZiIsIk1hcCIsImdhaW5Ob2Rlc1JlZiIsIm1hc3RlckdhaW5SZWYiLCJ2aWRlb1JlZiIsInN0YXJ0VGltZVJlZiIsInBhdXNlVGltZVJlZiIsImFuaW1hdGlvbkZyYW1lUmVmIiwiZHVyYXRpb25SZWYiLCJpc1BsYXlpbmdSZWYiLCJBdWRpb0N0eCIsIndpbmRvdyIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsImN1cnJlbnQiLCJjcmVhdGVHYWluIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwiY2xvc2UiLCJnYWluIiwidmFsdWUiLCJnZXRUcmFja0NvbG9yIiwibmFtZSIsIm4iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiYWRkVHJhY2siLCJmaWxlIiwiYXJyYXlCdWZmZXIiLCJhdWRpb0J1ZmZlciIsImRlY29kZUF1ZGlvRGF0YSIsIm5ld1RyYWNrIiwiaWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwiYnVmZmVyIiwidm9sdW1lIiwibXV0ZWQiLCJzb2xvZWQiLCJjb2xvciIsInByZXYiLCJNYXRoIiwibWF4IiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImFkZFZpZGVvVHJhY2siLCJ2aWRlb0ZpbGUiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJ2aWRlb1RyYWNrIiwidW5kZWZpbmVkIiwiYXVkaW9UcmFjayIsInNsaWNlIiwiaXNWaWRlb0F1ZGlvIiwid2FybiIsIm5ld1RyYWNrcyIsInB1c2giLCJjdXN0b21FdmVudCIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiZGlzcGF0Y2hFdmVudCIsInRlbXBWaWRlbyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsIm9ubG9hZGVkbWV0YWRhdGEiLCJjbGVhclRyYWNrcyIsInN0b3BBdWRpb0ludGVybmFsIiwiZm9yRWFjaCIsInNvdXJjZSIsInN0b3AiLCJjbGVhciIsInBsYXlBdWRpbyIsInN0YXJ0T2Zmc2V0Iiwic3RhdGUiLCJyZXN1bWUiLCJhbnlTb2xvIiwic29tZSIsInQiLCJ0cmFjayIsImNyZWF0ZUJ1ZmZlclNvdXJjZSIsImdhaW5Ob2RlIiwic2hvdWxkTG9naWNhbGx5TXV0ZSIsInN0YXJ0Iiwic2V0Iiwib25lbmRlZCIsInN0b3BBdWRpbyIsInRvZ2dsZVBsYXkiLCJwYXVzZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicGxheSIsImNhdGNoIiwidXBkYXRlIiwibm93IiwiY2FsY3VsYXRlZFRpbWUiLCJkdXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzZWVrIiwidGltZSIsIndhc1BsYXlpbmciLCJ0YXJnZXRWb2x1bWUiLCJnZXQiLCJjYW5jZWxTY2hlZHVsZWRWYWx1ZXMiLCJzZXRUYXJnZXRBdFRpbWUiLCJzZXRUcmFja1ZvbHVtZSIsIm1hcCIsInRvZ2dsZVRyYWNrTXV0ZSIsInRvZ2dsZVRyYWNrU29sbyIsInJlbW92ZVRyYWNrIiwiZmlsdGVyIiwidHJpbVZpZGVvVG9BdWRpbyIsImF1ZGlvVHJhY2tzIiwibGVuZ3RoIiwiYXVkaW9EdXIiLCJhZGRTb25nVG9QbGF5bGlzdCIsInNvbmciLCJyZW1vdmVTb25nRnJvbVBsYXlsaXN0IiwicyIsImxvYWRTb25nIiwiZmluZCIsInN0ZW1GaWxlIiwic3RlbUZpbGVzIiwidHJhY2tOYW1lIiwicmVwbGFjZSIsIlByb3ZpZGVyIiwic2V0VmlkZW9FbGVtZW50IiwiZWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useAudioEngine.tsx\n"));

/***/ })

});