"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_twick_live-player_dist_internal-KYB5ZQ5E-Be1ZlZZg_mjs"],{

/***/ "(app-pages-browser)/./node_modules/@twick/live-player/dist/internal-KYB5ZQ5E-Be1ZlZZg.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@twick/live-player/dist/internal-KYB5ZQ5E-Be1ZlZZg.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nconst parseNumber = (color, len) => {\n  if (typeof color !== \"number\") return;\n  if (len === 3) {\n    return {\n      mode: \"rgb\",\n      r: (color >> 8 & 15 | color >> 4 & 240) / 255,\n      g: (color >> 4 & 15 | color & 240) / 255,\n      b: (color & 15 | color << 4 & 240) / 255\n    };\n  }\n  if (len === 4) {\n    return {\n      mode: \"rgb\",\n      r: (color >> 12 & 15 | color >> 8 & 240) / 255,\n      g: (color >> 8 & 15 | color >> 4 & 240) / 255,\n      b: (color >> 4 & 15 | color & 240) / 255,\n      alpha: (color & 15 | color << 4 & 240) / 255\n    };\n  }\n  if (len === 6) {\n    return {\n      mode: \"rgb\",\n      r: (color >> 16 & 255) / 255,\n      g: (color >> 8 & 255) / 255,\n      b: (color & 255) / 255\n    };\n  }\n  if (len === 8) {\n    return {\n      mode: \"rgb\",\n      r: (color >> 24 & 255) / 255,\n      g: (color >> 16 & 255) / 255,\n      b: (color >> 8 & 255) / 255,\n      alpha: (color & 255) / 255\n    };\n  }\n};\nconst named = {\n  aliceblue: 15792383,\n  antiquewhite: 16444375,\n  aqua: 65535,\n  aquamarine: 8388564,\n  azure: 15794175,\n  beige: 16119260,\n  bisque: 16770244,\n  black: 0,\n  blanchedalmond: 16772045,\n  blue: 255,\n  blueviolet: 9055202,\n  brown: 10824234,\n  burlywood: 14596231,\n  cadetblue: 6266528,\n  chartreuse: 8388352,\n  chocolate: 13789470,\n  coral: 16744272,\n  cornflowerblue: 6591981,\n  cornsilk: 16775388,\n  crimson: 14423100,\n  cyan: 65535,\n  darkblue: 139,\n  darkcyan: 35723,\n  darkgoldenrod: 12092939,\n  darkgray: 11119017,\n  darkgreen: 25600,\n  darkgrey: 11119017,\n  darkkhaki: 12433259,\n  darkmagenta: 9109643,\n  darkolivegreen: 5597999,\n  darkorange: 16747520,\n  darkorchid: 10040012,\n  darkred: 9109504,\n  darksalmon: 15308410,\n  darkseagreen: 9419919,\n  darkslateblue: 4734347,\n  darkslategray: 3100495,\n  darkslategrey: 3100495,\n  darkturquoise: 52945,\n  darkviolet: 9699539,\n  deeppink: 16716947,\n  deepskyblue: 49151,\n  dimgray: 6908265,\n  dimgrey: 6908265,\n  dodgerblue: 2003199,\n  firebrick: 11674146,\n  floralwhite: 16775920,\n  forestgreen: 2263842,\n  fuchsia: 16711935,\n  gainsboro: 14474460,\n  ghostwhite: 16316671,\n  gold: 16766720,\n  goldenrod: 14329120,\n  gray: 8421504,\n  green: 32768,\n  greenyellow: 11403055,\n  grey: 8421504,\n  honeydew: 15794160,\n  hotpink: 16738740,\n  indianred: 13458524,\n  indigo: 4915330,\n  ivory: 16777200,\n  khaki: 15787660,\n  lavender: 15132410,\n  lavenderblush: 16773365,\n  lawngreen: 8190976,\n  lemonchiffon: 16775885,\n  lightblue: 11393254,\n  lightcoral: 15761536,\n  lightcyan: 14745599,\n  lightgoldenrodyellow: 16448210,\n  lightgray: 13882323,\n  lightgreen: 9498256,\n  lightgrey: 13882323,\n  lightpink: 16758465,\n  lightsalmon: 16752762,\n  lightseagreen: 2142890,\n  lightskyblue: 8900346,\n  lightslategray: 7833753,\n  lightslategrey: 7833753,\n  lightsteelblue: 11584734,\n  lightyellow: 16777184,\n  lime: 65280,\n  limegreen: 3329330,\n  linen: 16445670,\n  magenta: 16711935,\n  maroon: 8388608,\n  mediumaquamarine: 6737322,\n  mediumblue: 205,\n  mediumorchid: 12211667,\n  mediumpurple: 9662683,\n  mediumseagreen: 3978097,\n  mediumslateblue: 8087790,\n  mediumspringgreen: 64154,\n  mediumturquoise: 4772300,\n  mediumvioletred: 13047173,\n  midnightblue: 1644912,\n  mintcream: 16121850,\n  mistyrose: 16770273,\n  moccasin: 16770229,\n  navajowhite: 16768685,\n  navy: 128,\n  oldlace: 16643558,\n  olive: 8421376,\n  olivedrab: 7048739,\n  orange: 16753920,\n  orangered: 16729344,\n  orchid: 14315734,\n  palegoldenrod: 15657130,\n  palegreen: 10025880,\n  paleturquoise: 11529966,\n  palevioletred: 14381203,\n  papayawhip: 16773077,\n  peachpuff: 16767673,\n  peru: 13468991,\n  pink: 16761035,\n  plum: 14524637,\n  powderblue: 11591910,\n  purple: 8388736,\n  // Added in CSS Colors Level 4:\n  // https://drafts.csswg.org/css-color/#changes-from-3\n  rebeccapurple: 6697881,\n  red: 16711680,\n  rosybrown: 12357519,\n  royalblue: 4286945,\n  saddlebrown: 9127187,\n  salmon: 16416882,\n  sandybrown: 16032864,\n  seagreen: 3050327,\n  seashell: 16774638,\n  sienna: 10506797,\n  silver: 12632256,\n  skyblue: 8900331,\n  slateblue: 6970061,\n  slategray: 7372944,\n  slategrey: 7372944,\n  snow: 16775930,\n  springgreen: 65407,\n  steelblue: 4620980,\n  tan: 13808780,\n  teal: 32896,\n  thistle: 14204888,\n  tomato: 16737095,\n  turquoise: 4251856,\n  violet: 15631086,\n  wheat: 16113331,\n  white: 16777215,\n  whitesmoke: 16119285,\n  yellow: 16776960,\n  yellowgreen: 10145074\n};\nconst parseNamed = (color) => {\n  return parseNumber(named[color.toLowerCase()], 6);\n};\nconst hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;\nconst parseHex = (color) => {\n  let match;\n  return (match = color.match(hex)) ? parseNumber(parseInt(match[1], 16), match[1].length) : void 0;\n};\nconst num$1 = \"([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\";\nconst per = `${num$1}%`;\nconst num_per = `(?:${num$1}%|${num$1})`;\nconst hue$1 = `(?:${num$1}(deg|grad|rad|turn)|${num$1})`;\nconst c = `\\\\s*,\\\\s*`;\nconst rgb_num_old = new RegExp(\n  `^rgba?\\\\(\\\\s*${num$1}${c}${num$1}${c}${num$1}\\\\s*(?:,\\\\s*${num_per}\\\\s*)?\\\\)$`\n);\nconst rgb_per_old = new RegExp(\n  `^rgba?\\\\(\\\\s*${per}${c}${per}${c}${per}\\\\s*(?:,\\\\s*${num_per}\\\\s*)?\\\\)$`\n);\nconst parseRgbLegacy = (color) => {\n  let res = { mode: \"rgb\" };\n  let match;\n  if (match = color.match(rgb_num_old)) {\n    if (match[1] !== void 0) {\n      res.r = match[1] / 255;\n    }\n    if (match[2] !== void 0) {\n      res.g = match[2] / 255;\n    }\n    if (match[3] !== void 0) {\n      res.b = match[3] / 255;\n    }\n  } else if (match = color.match(rgb_per_old)) {\n    if (match[1] !== void 0) {\n      res.r = match[1] / 100;\n    }\n    if (match[2] !== void 0) {\n      res.g = match[2] / 100;\n    }\n    if (match[3] !== void 0) {\n      res.b = match[3] / 100;\n    }\n  } else {\n    return void 0;\n  }\n  if (match[4] !== void 0) {\n    res.alpha = Math.max(0, Math.min(1, match[4] / 100));\n  } else if (match[5] !== void 0) {\n    res.alpha = Math.max(0, Math.min(1, +match[5]));\n  }\n  return res;\n};\nconst prepare = (color, mode) => color === void 0 ? void 0 : typeof color !== \"object\" ? parse(color) : color.mode !== void 0 ? color : mode ? { ...color, mode } : void 0;\nconst converter = (target_mode = \"rgb\") => (color) => (color = prepare(color, target_mode)) !== void 0 ? (\n  // if the color's mode corresponds to our target mode\n  color.mode === target_mode ? (\n    // then just return the color\n    color\n  ) : (\n    // otherwise check to see if we have a dedicated\n    // converter for the target mode\n    converters[color.mode][target_mode] ? (\n      // and return its result...\n      converters[color.mode][target_mode](color)\n    ) : (\n      // ...otherwise pass through RGB as an intermediary step.\n      // if the target mode is RGB...\n      target_mode === \"rgb\" ? (\n        // just return the RGB\n        converters[color.mode].rgb(color)\n      ) : (\n        // otherwise convert color.mode -> RGB -> target_mode\n        converters.rgb[target_mode](converters[color.mode].rgb(color))\n      )\n    )\n  )\n) : void 0;\nconst converters = {};\nconst modes = {};\nconst parsers = [];\nconst colorProfiles = {};\nconst identity = (v) => v;\nconst useMode = (definition2) => {\n  converters[definition2.mode] = {\n    ...converters[definition2.mode],\n    ...definition2.toMode\n  };\n  Object.keys(definition2.fromMode || {}).forEach((k2) => {\n    if (!converters[k2]) {\n      converters[k2] = {};\n    }\n    converters[k2][definition2.mode] = definition2.fromMode[k2];\n  });\n  if (!definition2.ranges) {\n    definition2.ranges = {};\n  }\n  if (!definition2.difference) {\n    definition2.difference = {};\n  }\n  definition2.channels.forEach((channel) => {\n    if (definition2.ranges[channel] === void 0) {\n      definition2.ranges[channel] = [0, 1];\n    }\n    if (!definition2.interpolate[channel]) {\n      throw new Error(`Missing interpolator for: ${channel}`);\n    }\n    if (typeof definition2.interpolate[channel] === \"function\") {\n      definition2.interpolate[channel] = {\n        use: definition2.interpolate[channel]\n      };\n    }\n    if (!definition2.interpolate[channel].fixup) {\n      definition2.interpolate[channel].fixup = identity;\n    }\n  });\n  modes[definition2.mode] = definition2;\n  (definition2.parse || []).forEach((parser) => {\n    useParser(parser, definition2.mode);\n  });\n  return converter(definition2.mode);\n};\nconst getMode = (mode) => modes[mode];\nconst useParser = (parser, mode) => {\n  if (typeof parser === \"string\") {\n    if (!mode) {\n      throw new Error(`'mode' required when 'parser' is a string`);\n    }\n    colorProfiles[parser] = mode;\n  } else if (typeof parser === \"function\") {\n    if (parsers.indexOf(parser) < 0) {\n      parsers.push(parser);\n    }\n  }\n};\nconst IdentStartCodePoint = /[^\\x00-\\x7F]|[a-zA-Z_]/;\nconst IdentCodePoint = /[^\\x00-\\x7F]|[-\\w]/;\nconst Tok = {\n  Function: \"function\",\n  Ident: \"ident\",\n  Number: \"number\",\n  Percentage: \"percentage\",\n  ParenClose: \")\",\n  None: \"none\",\n  Hue: \"hue\",\n  Alpha: \"alpha\"\n};\nlet _i = 0;\nfunction is_num(chars) {\n  let ch = chars[_i];\n  let ch1 = chars[_i + 1];\n  if (ch === \"-\" || ch === \"+\") {\n    return /\\d/.test(ch1) || ch1 === \".\" && /\\d/.test(chars[_i + 2]);\n  }\n  if (ch === \".\") {\n    return /\\d/.test(ch1);\n  }\n  return /\\d/.test(ch);\n}\nfunction is_ident(chars) {\n  if (_i >= chars.length) {\n    return false;\n  }\n  let ch = chars[_i];\n  if (IdentStartCodePoint.test(ch)) {\n    return true;\n  }\n  if (ch === \"-\") {\n    if (chars.length - _i < 2) {\n      return false;\n    }\n    let ch1 = chars[_i + 1];\n    if (ch1 === \"-\" || IdentStartCodePoint.test(ch1)) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n}\nconst huenits = {\n  deg: 1,\n  rad: 180 / Math.PI,\n  grad: 9 / 10,\n  turn: 360\n};\nfunction num(chars) {\n  let value = \"\";\n  if (chars[_i] === \"-\" || chars[_i] === \"+\") {\n    value += chars[_i++];\n  }\n  value += digits(chars);\n  if (chars[_i] === \".\" && /\\d/.test(chars[_i + 1])) {\n    value += chars[_i++] + digits(chars);\n  }\n  if (chars[_i] === \"e\" || chars[_i] === \"E\") {\n    if ((chars[_i + 1] === \"-\" || chars[_i + 1] === \"+\") && /\\d/.test(chars[_i + 2])) {\n      value += chars[_i++] + chars[_i++] + digits(chars);\n    } else if (/\\d/.test(chars[_i + 1])) {\n      value += chars[_i++] + digits(chars);\n    }\n  }\n  if (is_ident(chars)) {\n    let id = ident(chars);\n    if (id === \"deg\" || id === \"rad\" || id === \"turn\" || id === \"grad\") {\n      return { type: Tok.Hue, value: value * huenits[id] };\n    }\n    return void 0;\n  }\n  if (chars[_i] === \"%\") {\n    _i++;\n    return { type: Tok.Percentage, value: +value };\n  }\n  return { type: Tok.Number, value: +value };\n}\nfunction digits(chars) {\n  let v = \"\";\n  while (/\\d/.test(chars[_i])) {\n    v += chars[_i++];\n  }\n  return v;\n}\nfunction ident(chars) {\n  let v = \"\";\n  while (_i < chars.length && IdentCodePoint.test(chars[_i])) {\n    v += chars[_i++];\n  }\n  return v;\n}\nfunction identlike(chars) {\n  let v = ident(chars);\n  if (chars[_i] === \"(\") {\n    _i++;\n    return { type: Tok.Function, value: v };\n  }\n  if (v === \"none\") {\n    return { type: Tok.None, value: void 0 };\n  }\n  return { type: Tok.Ident, value: v };\n}\nfunction tokenize(str = \"\") {\n  let chars = str.trim();\n  let tokens = [];\n  let ch;\n  _i = 0;\n  while (_i < chars.length) {\n    ch = chars[_i++];\n    if (ch === \"\\n\" || ch === \"\t\" || ch === \" \") {\n      while (_i < chars.length && (chars[_i] === \"\\n\" || chars[_i] === \"\t\" || chars[_i] === \" \")) {\n        _i++;\n      }\n      continue;\n    }\n    if (ch === \",\") {\n      return void 0;\n    }\n    if (ch === \")\") {\n      tokens.push({ type: Tok.ParenClose });\n      continue;\n    }\n    if (ch === \"+\") {\n      _i--;\n      if (is_num(chars)) {\n        tokens.push(num(chars));\n        continue;\n      }\n      return void 0;\n    }\n    if (ch === \"-\") {\n      _i--;\n      if (is_num(chars)) {\n        tokens.push(num(chars));\n        continue;\n      }\n      if (is_ident(chars)) {\n        tokens.push({ type: Tok.Ident, value: ident(chars) });\n        continue;\n      }\n      return void 0;\n    }\n    if (ch === \".\") {\n      _i--;\n      if (is_num(chars)) {\n        tokens.push(num(chars));\n        continue;\n      }\n      return void 0;\n    }\n    if (ch === \"/\") {\n      while (_i < chars.length && (chars[_i] === \"\\n\" || chars[_i] === \"\t\" || chars[_i] === \" \")) {\n        _i++;\n      }\n      let alpha;\n      if (is_num(chars)) {\n        alpha = num(chars);\n        if (alpha.type !== Tok.Hue) {\n          tokens.push({ type: Tok.Alpha, value: alpha });\n          continue;\n        }\n      }\n      if (is_ident(chars)) {\n        if (ident(chars) === \"none\") {\n          tokens.push({\n            type: Tok.Alpha,\n            value: { type: Tok.None, value: void 0 }\n          });\n          continue;\n        }\n      }\n      return void 0;\n    }\n    if (/\\d/.test(ch)) {\n      _i--;\n      tokens.push(num(chars));\n      continue;\n    }\n    if (IdentStartCodePoint.test(ch)) {\n      _i--;\n      tokens.push(identlike(chars));\n      continue;\n    }\n    return void 0;\n  }\n  return tokens;\n}\nfunction parseColorSyntax(tokens) {\n  tokens._i = 0;\n  let token = tokens[tokens._i++];\n  if (!token || token.type !== Tok.Function || token.value !== \"color\") {\n    return void 0;\n  }\n  token = tokens[tokens._i++];\n  if (token.type !== Tok.Ident) {\n    return void 0;\n  }\n  const mode = colorProfiles[token.value];\n  if (!mode) {\n    return void 0;\n  }\n  const res = { mode };\n  const coords = consumeCoords(tokens, false);\n  if (!coords) {\n    return void 0;\n  }\n  const channels = getMode(mode).channels;\n  for (let ii = 0, c2, ch; ii < channels.length; ii++) {\n    c2 = coords[ii];\n    ch = channels[ii];\n    if (c2.type !== Tok.None) {\n      res[ch] = c2.type === Tok.Number ? c2.value : c2.value / 100;\n      if (ch === \"alpha\") {\n        res[ch] = Math.max(0, Math.min(1, res[ch]));\n      }\n    }\n  }\n  return res;\n}\nfunction consumeCoords(tokens, includeHue) {\n  const coords = [];\n  let token;\n  while (tokens._i < tokens.length) {\n    token = tokens[tokens._i++];\n    if (token.type === Tok.None || token.type === Tok.Number || token.type === Tok.Alpha || token.type === Tok.Percentage || includeHue && token.type === Tok.Hue) {\n      coords.push(token);\n      continue;\n    }\n    if (token.type === Tok.ParenClose) {\n      if (tokens._i < tokens.length) {\n        return void 0;\n      }\n      continue;\n    }\n    return void 0;\n  }\n  if (coords.length < 3 || coords.length > 4) {\n    return void 0;\n  }\n  if (coords.length === 4) {\n    if (coords[3].type !== Tok.Alpha) {\n      return void 0;\n    }\n    coords[3] = coords[3].value;\n  }\n  if (coords.length === 3) {\n    coords.push({ type: Tok.None, value: void 0 });\n  }\n  return coords.every((c2) => c2.type !== Tok.Alpha) ? coords : void 0;\n}\nfunction parseModernSyntax(tokens, includeHue) {\n  tokens._i = 0;\n  let token = tokens[tokens._i++];\n  if (!token || token.type !== Tok.Function) {\n    return void 0;\n  }\n  let coords = consumeCoords(tokens, includeHue);\n  if (!coords) {\n    return void 0;\n  }\n  coords.unshift(token.value);\n  return coords;\n}\nconst parse = (color) => {\n  if (typeof color !== \"string\") {\n    return void 0;\n  }\n  const tokens = tokenize(color);\n  const parsed = tokens ? parseModernSyntax(tokens, true) : void 0;\n  let result = void 0;\n  let i = 0;\n  let len = parsers.length;\n  while (i < len) {\n    if ((result = parsers[i++](color, parsed)) !== void 0) {\n      return result;\n    }\n  }\n  return tokens ? parseColorSyntax(tokens) : void 0;\n};\nfunction parseRgb(color, parsed) {\n  if (!parsed || parsed[0] !== \"rgb\" && parsed[0] !== \"rgba\") {\n    return void 0;\n  }\n  const res = { mode: \"rgb\" };\n  const [, r, g, b, alpha] = parsed;\n  if (r.type === Tok.Hue || g.type === Tok.Hue || b.type === Tok.Hue) {\n    return void 0;\n  }\n  if (r.type !== Tok.None) {\n    res.r = r.type === Tok.Number ? r.value / 255 : r.value / 100;\n  }\n  if (g.type !== Tok.None) {\n    res.g = g.type === Tok.Number ? g.value / 255 : g.value / 100;\n  }\n  if (b.type !== Tok.None) {\n    res.b = b.type === Tok.Number ? b.value / 255 : b.value / 100;\n  }\n  if (alpha.type !== Tok.None) {\n    res.alpha = Math.min(\n      1,\n      Math.max(\n        0,\n        alpha.type === Tok.Number ? alpha.value : alpha.value / 100\n      )\n    );\n  }\n  return res;\n}\nconst parseTransparent = (c2) => c2 === \"transparent\" ? { mode: \"rgb\", r: 0, g: 0, b: 0, alpha: 0 } : void 0;\nconst lerp = (a, b, t) => a + t * (b - a);\nconst get_classes = (arr) => {\n  let classes = [];\n  for (let i = 0; i < arr.length - 1; i++) {\n    let a = arr[i];\n    let b = arr[i + 1];\n    if (a === void 0 && b === void 0) {\n      classes.push(void 0);\n    } else if (a !== void 0 && b !== void 0) {\n      classes.push([a, b]);\n    } else {\n      classes.push(a !== void 0 ? [a, a] : [b, b]);\n    }\n  }\n  return classes;\n};\nconst interpolatorPiecewise = (interpolator) => (arr) => {\n  let classes = get_classes(arr);\n  return (t) => {\n    let cls = t * classes.length;\n    let idx = t >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);\n    let pair = classes[idx];\n    return pair === void 0 ? void 0 : interpolator(pair[0], pair[1], cls - idx);\n  };\n};\nconst interpolatorLinear = interpolatorPiecewise(lerp);\nconst fixupAlpha = (arr) => {\n  let some_defined = false;\n  let res = arr.map((v) => {\n    if (v !== void 0) {\n      some_defined = true;\n      return v;\n    }\n    return 1;\n  });\n  return some_defined ? res : arr;\n};\nconst definition$r = {\n  mode: \"rgb\",\n  channels: [\"r\", \"g\", \"b\", \"alpha\"],\n  parse: [\n    parseRgb,\n    parseHex,\n    parseRgbLegacy,\n    parseNamed,\n    parseTransparent,\n    \"srgb\"\n  ],\n  serialize: \"srgb\",\n  interpolate: {\n    r: interpolatorLinear,\n    g: interpolatorLinear,\n    b: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  gamut: true,\n  white: { r: 1, g: 1, b: 1 },\n  black: { r: 0, g: 0, b: 0 }\n};\nconst linearize$2 = (v = 0) => Math.pow(Math.abs(v), 563 / 256) * Math.sign(v);\nconst convertA98ToXyz65 = (a98) => {\n  let r = linearize$2(a98.r);\n  let g = linearize$2(a98.g);\n  let b = linearize$2(a98.b);\n  let res = {\n    mode: \"xyz65\",\n    x: 0.5766690429101305 * r + 0.1855582379065463 * g + 0.1882286462349947 * b,\n    y: 0.297344975250536 * r + 0.6273635662554661 * g + 0.0752914584939979 * b,\n    z: 0.0270313613864123 * r + 0.0706888525358272 * g + 0.9913375368376386 * b\n  };\n  if (a98.alpha !== void 0) {\n    res.alpha = a98.alpha;\n  }\n  return res;\n};\nconst gamma$2 = (v) => Math.pow(Math.abs(v), 256 / 563) * Math.sign(v);\nconst convertXyz65ToA98 = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = {\n    mode: \"a98\",\n    r: gamma$2(\n      x * 2.0415879038107465 - y * 0.5650069742788597 - 0.3447313507783297 * z\n    ),\n    g: gamma$2(\n      x * -0.9692436362808798 + y * 1.8759675015077206 + 0.0415550574071756 * z\n    ),\n    b: gamma$2(\n      x * 0.0134442806320312 - y * 0.1183623922310184 + 1.0151749943912058 * z\n    )\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst fn$3 = (c2 = 0) => {\n  const abs2 = Math.abs(c2);\n  if (abs2 <= 0.04045) {\n    return c2 / 12.92;\n  }\n  return (Math.sign(c2) || 1) * Math.pow((abs2 + 0.055) / 1.055, 2.4);\n};\nconst convertRgbToLrgb = ({ r, g, b, alpha }) => {\n  let res = {\n    mode: \"lrgb\",\n    r: fn$3(r),\n    g: fn$3(g),\n    b: fn$3(b)\n  };\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst convertRgbToXyz65 = (rgb) => {\n  let { r, g, b, alpha } = convertRgbToLrgb(rgb);\n  let res = {\n    mode: \"xyz65\",\n    x: 0.4123907992659593 * r + 0.357584339383878 * g + 0.1804807884018343 * b,\n    y: 0.2126390058715102 * r + 0.715168678767756 * g + 0.0721923153607337 * b,\n    z: 0.0193308187155918 * r + 0.119194779794626 * g + 0.9505321522496607 * b\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst fn$2 = (c2 = 0) => {\n  const abs2 = Math.abs(c2);\n  if (abs2 > 31308e-7) {\n    return (Math.sign(c2) || 1) * (1.055 * Math.pow(abs2, 1 / 2.4) - 0.055);\n  }\n  return c2 * 12.92;\n};\nconst convertLrgbToRgb = ({ r, g, b, alpha }, mode = \"rgb\") => {\n  let res = {\n    mode,\n    r: fn$2(r),\n    g: fn$2(g),\n    b: fn$2(b)\n  };\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst convertXyz65ToRgb = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = convertLrgbToRgb({\n    r: x * 3.2409699419045226 - y * 1.537383177570094 - 0.4986107602930034 * z,\n    g: x * -0.9692436362808796 + y * 1.8759675015077204 + 0.0415550574071756 * z,\n    b: x * 0.0556300796969936 - y * 0.2039769588889765 + 1.0569715142428784 * z\n  });\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst definition$q = {\n  ...definition$r,\n  mode: \"a98\",\n  parse: [\"a98-rgb\"],\n  serialize: \"a98-rgb\",\n  fromMode: {\n    rgb: (color) => convertXyz65ToA98(convertRgbToXyz65(color)),\n    xyz65: convertXyz65ToA98\n  },\n  toMode: {\n    rgb: (color) => convertXyz65ToRgb(convertA98ToXyz65(color)),\n    xyz65: convertA98ToXyz65\n  }\n};\nconst normalizeHue = (hue2) => (hue2 = hue2 % 360) < 0 ? hue2 + 360 : hue2;\nconst hue = (hues, fn2) => {\n  return hues.map((hue2, idx, arr) => {\n    if (hue2 === void 0) {\n      return hue2;\n    }\n    let normalized = normalizeHue(hue2);\n    if (idx === 0 || hues[idx - 1] === void 0) {\n      return normalized;\n    }\n    return fn2(normalized - normalizeHue(arr[idx - 1]));\n  }).reduce((acc, curr) => {\n    if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {\n      acc.push(curr);\n      return acc;\n    }\n    acc.push(curr + acc[acc.length - 1]);\n    return acc;\n  }, []);\n};\nconst fixupHueShorter = (arr) => hue(arr, (d) => Math.abs(d) <= 180 ? d : d - 360 * Math.sign(d));\nconst M = [-0.14861, 1.78277, -0.29227, -0.90649, 1.97294, 0];\nconst degToRad = Math.PI / 180;\nconst radToDeg = 180 / Math.PI;\nlet DE = M[3] * M[4];\nlet BE = M[1] * M[4];\nlet BCAD = M[1] * M[2] - M[0] * M[3];\nconst convertRgbToCubehelix = ({ r, g, b, alpha }) => {\n  if (r === void 0) r = 0;\n  if (g === void 0) g = 0;\n  if (b === void 0) b = 0;\n  let l = (BCAD * b + r * DE - g * BE) / (BCAD + DE - BE);\n  let x = b - l;\n  let y = (M[4] * (g - l) - M[2] * x) / M[3];\n  let res = {\n    mode: \"cubehelix\",\n    l,\n    s: l === 0 || l === 1 ? void 0 : Math.sqrt(x * x + y * y) / (M[4] * l * (1 - l))\n  };\n  if (res.s) res.h = Math.atan2(y, x) * radToDeg - 120;\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst convertCubehelixToRgb = ({ h, s, l, alpha }) => {\n  let res = { mode: \"rgb\" };\n  h = (h === void 0 ? 0 : h + 120) * degToRad;\n  if (l === void 0) l = 0;\n  let amp = s === void 0 ? 0 : s * l * (1 - l);\n  let cosh = Math.cos(h);\n  let sinh = Math.sin(h);\n  res.r = l + amp * (M[0] * cosh + M[1] * sinh);\n  res.g = l + amp * (M[2] * cosh + M[3] * sinh);\n  res.b = l + amp * (M[4] * cosh + M[5] * sinh);\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst differenceHueSaturation = (std, smp) => {\n  if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) {\n    return 0;\n  }\n  let std_h = normalizeHue(std.h);\n  let smp_h = normalizeHue(smp.h);\n  let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);\n  return 2 * Math.sqrt(std.s * smp.s) * dH;\n};\nconst differenceHueNaive = (std, smp) => {\n  if (std.h === void 0 || smp.h === void 0) {\n    return 0;\n  }\n  let std_h = normalizeHue(std.h);\n  let smp_h = normalizeHue(smp.h);\n  if (Math.abs(smp_h - std_h) > 180) {\n    return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));\n  }\n  return smp_h - std_h;\n};\nconst differenceHueChroma = (std, smp) => {\n  if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) {\n    return 0;\n  }\n  let std_h = normalizeHue(std.h);\n  let smp_h = normalizeHue(smp.h);\n  let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);\n  return 2 * Math.sqrt(std.c * smp.c) * dH;\n};\nconst averageAngle = (val) => {\n  let sum = val.reduce(\n    (sum2, val2) => {\n      if (val2 !== void 0) {\n        let rad = val2 * Math.PI / 180;\n        sum2.sin += Math.sin(rad);\n        sum2.cos += Math.cos(rad);\n      }\n      return sum2;\n    },\n    { sin: 0, cos: 0 }\n  );\n  let angle = Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;\n  return angle < 0 ? 360 + angle : angle;\n};\nconst definition$p = {\n  mode: \"cubehelix\",\n  channels: [\"h\", \"s\", \"l\", \"alpha\"],\n  parse: [\"--cubehelix\"],\n  serialize: \"--cubehelix\",\n  ranges: {\n    h: [0, 360],\n    s: [0, 4.614],\n    l: [0, 1]\n  },\n  fromMode: {\n    rgb: convertRgbToCubehelix\n  },\n  toMode: {\n    rgb: convertCubehelixToRgb\n  },\n  interpolate: {\n    h: {\n      use: interpolatorLinear,\n      fixup: fixupHueShorter\n    },\n    s: interpolatorLinear,\n    l: interpolatorLinear,\n    alpha: {\n      use: interpolatorLinear,\n      fixup: fixupAlpha\n    }\n  },\n  difference: {\n    h: differenceHueSaturation\n  },\n  average: {\n    h: averageAngle\n  }\n};\nconst convertLabToLch = ({ l, a, b, alpha }, mode = \"lch\") => {\n  if (a === void 0) a = 0;\n  if (b === void 0) b = 0;\n  let c2 = Math.sqrt(a * a + b * b);\n  let res = { mode, l, c: c2 };\n  if (c2) res.h = normalizeHue(Math.atan2(b, a) * 180 / Math.PI);\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst convertLchToLab = ({ l, c: c2, h, alpha }, mode = \"lab\") => {\n  if (h === void 0) h = 0;\n  let res = {\n    mode,\n    l,\n    a: c2 ? c2 * Math.cos(h / 180 * Math.PI) : 0,\n    b: c2 ? c2 * Math.sin(h / 180 * Math.PI) : 0\n  };\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst k$1 = Math.pow(29, 3) / Math.pow(3, 3);\nconst e$1 = Math.pow(6, 3) / Math.pow(29, 3);\nconst D50 = {\n  X: 0.3457 / 0.3585,\n  Y: 1,\n  Z: (1 - 0.3457 - 0.3585) / 0.3585\n};\nconst D65 = {\n  X: 0.3127 / 0.329,\n  Y: 1,\n  Z: (1 - 0.3127 - 0.329) / 0.329\n};\nlet fn$1 = (v) => Math.pow(v, 3) > e$1 ? Math.pow(v, 3) : (116 * v - 16) / k$1;\nconst convertLab65ToXyz65 = ({ l, a, b, alpha }) => {\n  if (l === void 0) l = 0;\n  if (a === void 0) a = 0;\n  if (b === void 0) b = 0;\n  let fy = (l + 16) / 116;\n  let fx = a / 500 + fy;\n  let fz = fy - b / 200;\n  let res = {\n    mode: \"xyz65\",\n    x: fn$1(fx) * D65.X,\n    y: fn$1(fy) * D65.Y,\n    z: fn$1(fz) * D65.Z\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertLab65ToRgb = (lab) => convertXyz65ToRgb(convertLab65ToXyz65(lab));\nconst f$1 = (value) => value > e$1 ? Math.cbrt(value) : (k$1 * value + 16) / 116;\nconst convertXyz65ToLab65 = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let f0 = f$1(x / D65.X);\n  let f1 = f$1(y / D65.Y);\n  let f2 = f$1(z / D65.Z);\n  let res = {\n    mode: \"lab65\",\n    l: 116 * f1 - 16,\n    a: 500 * (f0 - f1),\n    b: 200 * (f1 - f2)\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertRgbToLab65 = (rgb) => {\n  let res = convertXyz65ToLab65(convertRgbToXyz65(rgb));\n  if (rgb.r === rgb.b && rgb.b === rgb.g) {\n    res.a = res.b = 0;\n  }\n  return res;\n};\nconst kE = 1;\nconst kCH = 1;\nconst θ = 26 / 180 * Math.PI;\nconst cosθ = Math.cos(θ);\nconst sinθ = Math.sin(θ);\nconst factor = 100 / Math.log(139 / 100);\nconst convertDlchToLab65 = ({ l, c: c2, h, alpha }) => {\n  if (l === void 0) l = 0;\n  if (c2 === void 0) c2 = 0;\n  if (h === void 0) h = 0;\n  let res = {\n    mode: \"lab65\",\n    l: (Math.exp(l * kE / factor) - 1) / 39e-4\n  };\n  let G = (Math.exp(0.0435 * c2 * kCH * kE) - 1) / 0.075;\n  let e2 = G * Math.cos(h / 180 * Math.PI - θ);\n  let f2 = G * Math.sin(h / 180 * Math.PI - θ);\n  res.a = e2 * cosθ - f2 / 0.83 * sinθ;\n  res.b = e2 * sinθ + f2 / 0.83 * cosθ;\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst convertLab65ToDlch = ({ l, a, b, alpha }) => {\n  if (l === void 0) l = 0;\n  if (a === void 0) a = 0;\n  if (b === void 0) b = 0;\n  let e2 = a * cosθ + b * sinθ;\n  let f2 = 0.83 * (b * cosθ - a * sinθ);\n  let G = Math.sqrt(e2 * e2 + f2 * f2);\n  let res = {\n    mode: \"dlch\",\n    l: factor / kE * Math.log(1 + 39e-4 * l),\n    c: Math.log(1 + 0.075 * G) / (0.0435 * kCH * kE)\n  };\n  if (res.c) {\n    res.h = normalizeHue((Math.atan2(f2, e2) + θ) / Math.PI * 180);\n  }\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst convertDlabToLab65 = (c2) => convertDlchToLab65(convertLabToLch(c2, \"dlch\"));\nconst convertLab65ToDlab = (c2) => convertLchToLab(convertLab65ToDlch(c2), \"dlab\");\nconst definition$o = {\n  mode: \"dlab\",\n  parse: [\"--din99o-lab\"],\n  serialize: \"--din99o-lab\",\n  toMode: {\n    lab65: convertDlabToLab65,\n    rgb: (c2) => convertLab65ToRgb(convertDlabToLab65(c2))\n  },\n  fromMode: {\n    lab65: convertLab65ToDlab,\n    rgb: (c2) => convertLab65ToDlab(convertRgbToLab65(c2))\n  },\n  channels: [\"l\", \"a\", \"b\", \"alpha\"],\n  ranges: {\n    l: [0, 100],\n    a: [-40.09, 45.501],\n    b: [-40.469, 44.344]\n  },\n  interpolate: {\n    l: interpolatorLinear,\n    a: interpolatorLinear,\n    b: interpolatorLinear,\n    alpha: {\n      use: interpolatorLinear,\n      fixup: fixupAlpha\n    }\n  }\n};\nconst definition$n = {\n  mode: \"dlch\",\n  parse: [\"--din99o-lch\"],\n  serialize: \"--din99o-lch\",\n  toMode: {\n    lab65: convertDlchToLab65,\n    dlab: (c2) => convertLchToLab(c2, \"dlab\"),\n    rgb: (c2) => convertLab65ToRgb(convertDlchToLab65(c2))\n  },\n  fromMode: {\n    lab65: convertLab65ToDlch,\n    dlab: (c2) => convertLabToLch(c2, \"dlch\"),\n    rgb: (c2) => convertLab65ToDlch(convertRgbToLab65(c2))\n  },\n  channels: [\"l\", \"c\", \"h\", \"alpha\"],\n  ranges: {\n    l: [0, 100],\n    c: [0, 51.484],\n    h: [0, 360]\n  },\n  interpolate: {\n    l: interpolatorLinear,\n    c: interpolatorLinear,\n    h: {\n      use: interpolatorLinear,\n      fixup: fixupHueShorter\n    },\n    alpha: {\n      use: interpolatorLinear,\n      fixup: fixupAlpha\n    }\n  },\n  difference: {\n    h: differenceHueChroma\n  },\n  average: {\n    h: averageAngle\n  }\n};\nfunction convertHsiToRgb({ h, s, i, alpha }) {\n  h = normalizeHue(h !== void 0 ? h : 0);\n  if (s === void 0) s = 0;\n  if (i === void 0) i = 0;\n  let f2 = Math.abs(h / 60 % 2 - 1);\n  let res;\n  switch (Math.floor(h / 60)) {\n    case 0:\n      res = {\n        r: i * (1 + s * (3 / (2 - f2) - 1)),\n        g: i * (1 + s * (3 * (1 - f2) / (2 - f2) - 1)),\n        b: i * (1 - s)\n      };\n      break;\n    case 1:\n      res = {\n        r: i * (1 + s * (3 * (1 - f2) / (2 - f2) - 1)),\n        g: i * (1 + s * (3 / (2 - f2) - 1)),\n        b: i * (1 - s)\n      };\n      break;\n    case 2:\n      res = {\n        r: i * (1 - s),\n        g: i * (1 + s * (3 / (2 - f2) - 1)),\n        b: i * (1 + s * (3 * (1 - f2) / (2 - f2) - 1))\n      };\n      break;\n    case 3:\n      res = {\n        r: i * (1 - s),\n        g: i * (1 + s * (3 * (1 - f2) / (2 - f2) - 1)),\n        b: i * (1 + s * (3 / (2 - f2) - 1))\n      };\n      break;\n    case 4:\n      res = {\n        r: i * (1 + s * (3 * (1 - f2) / (2 - f2) - 1)),\n        g: i * (1 - s),\n        b: i * (1 + s * (3 / (2 - f2) - 1))\n      };\n      break;\n    case 5:\n      res = {\n        r: i * (1 + s * (3 / (2 - f2) - 1)),\n        g: i * (1 - s),\n        b: i * (1 + s * (3 * (1 - f2) / (2 - f2) - 1))\n      };\n      break;\n    default:\n      res = { r: i * (1 - s), g: i * (1 - s), b: i * (1 - s) };\n  }\n  res.mode = \"rgb\";\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n}\nfunction convertRgbToHsi({ r, g, b, alpha }) {\n  if (r === void 0) r = 0;\n  if (g === void 0) g = 0;\n  if (b === void 0) b = 0;\n  let M3 = Math.max(r, g, b), m = Math.min(r, g, b);\n  let res = {\n    mode: \"hsi\",\n    s: r + g + b === 0 ? 0 : 1 - 3 * m / (r + g + b),\n    i: (r + g + b) / 3\n  };\n  if (M3 - m !== 0)\n    res.h = (M3 === r ? (g - b) / (M3 - m) + (g < b) * 6 : M3 === g ? (b - r) / (M3 - m) + 2 : (r - g) / (M3 - m) + 4) * 60;\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n}\nconst definition$m = {\n  mode: \"hsi\",\n  toMode: {\n    rgb: convertHsiToRgb\n  },\n  parse: [\"--hsi\"],\n  serialize: \"--hsi\",\n  fromMode: {\n    rgb: convertRgbToHsi\n  },\n  channels: [\"h\", \"s\", \"i\", \"alpha\"],\n  ranges: {\n    h: [0, 360]\n  },\n  gamut: \"rgb\",\n  interpolate: {\n    h: { use: interpolatorLinear, fixup: fixupHueShorter },\n    s: interpolatorLinear,\n    i: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  difference: {\n    h: differenceHueSaturation\n  },\n  average: {\n    h: averageAngle\n  }\n};\nfunction convertHslToRgb({ h, s, l, alpha }) {\n  h = normalizeHue(h !== void 0 ? h : 0);\n  if (s === void 0) s = 0;\n  if (l === void 0) l = 0;\n  let m1 = l + s * (l < 0.5 ? l : 1 - l);\n  let m2 = m1 - (m1 - l) * 2 * Math.abs(h / 60 % 2 - 1);\n  let res;\n  switch (Math.floor(h / 60)) {\n    case 0:\n      res = { r: m1, g: m2, b: 2 * l - m1 };\n      break;\n    case 1:\n      res = { r: m2, g: m1, b: 2 * l - m1 };\n      break;\n    case 2:\n      res = { r: 2 * l - m1, g: m1, b: m2 };\n      break;\n    case 3:\n      res = { r: 2 * l - m1, g: m2, b: m1 };\n      break;\n    case 4:\n      res = { r: m2, g: 2 * l - m1, b: m1 };\n      break;\n    case 5:\n      res = { r: m1, g: 2 * l - m1, b: m2 };\n      break;\n    default:\n      res = { r: 2 * l - m1, g: 2 * l - m1, b: 2 * l - m1 };\n  }\n  res.mode = \"rgb\";\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n}\nfunction convertRgbToHsl({ r, g, b, alpha }) {\n  if (r === void 0) r = 0;\n  if (g === void 0) g = 0;\n  if (b === void 0) b = 0;\n  let M3 = Math.max(r, g, b), m = Math.min(r, g, b);\n  let res = {\n    mode: \"hsl\",\n    s: M3 === m ? 0 : (M3 - m) / (1 - Math.abs(M3 + m - 1)),\n    l: 0.5 * (M3 + m)\n  };\n  if (M3 - m !== 0)\n    res.h = (M3 === r ? (g - b) / (M3 - m) + (g < b) * 6 : M3 === g ? (b - r) / (M3 - m) + 2 : (r - g) / (M3 - m) + 4) * 60;\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n}\nconst hueToDeg = (val, unit) => {\n  switch (unit) {\n    case \"deg\":\n      return +val;\n    case \"rad\":\n      return val / Math.PI * 180;\n    case \"grad\":\n      return val / 10 * 9;\n    case \"turn\":\n      return val * 360;\n  }\n};\nconst hsl_old = new RegExp(\n  `^hsla?\\\\(\\\\s*${hue$1}${c}${per}${c}${per}\\\\s*(?:,\\\\s*${num_per}\\\\s*)?\\\\)$`\n);\nconst parseHslLegacy = (color) => {\n  let match = color.match(hsl_old);\n  if (!match) return;\n  let res = { mode: \"hsl\" };\n  if (match[3] !== void 0) {\n    res.h = +match[3];\n  } else if (match[1] !== void 0 && match[2] !== void 0) {\n    res.h = hueToDeg(match[1], match[2]);\n  }\n  if (match[4] !== void 0) {\n    res.s = Math.min(Math.max(0, match[4] / 100), 1);\n  }\n  if (match[5] !== void 0) {\n    res.l = Math.min(Math.max(0, match[5] / 100), 1);\n  }\n  if (match[6] !== void 0) {\n    res.alpha = Math.max(0, Math.min(1, match[6] / 100));\n  } else if (match[7] !== void 0) {\n    res.alpha = Math.max(0, Math.min(1, +match[7]));\n  }\n  return res;\n};\nfunction parseHsl(color, parsed) {\n  if (!parsed || parsed[0] !== \"hsl\" && parsed[0] !== \"hsla\") {\n    return void 0;\n  }\n  const res = { mode: \"hsl\" };\n  const [, h, s, l, alpha] = parsed;\n  if (h.type !== Tok.None) {\n    if (h.type === Tok.Percentage) {\n      return void 0;\n    }\n    res.h = h.value;\n  }\n  if (s.type !== Tok.None) {\n    if (s.type === Tok.Hue) {\n      return void 0;\n    }\n    res.s = s.value / 100;\n  }\n  if (l.type !== Tok.None) {\n    if (l.type === Tok.Hue) {\n      return void 0;\n    }\n    res.l = l.value / 100;\n  }\n  if (alpha.type !== Tok.None) {\n    res.alpha = Math.min(\n      1,\n      Math.max(\n        0,\n        alpha.type === Tok.Number ? alpha.value : alpha.value / 100\n      )\n    );\n  }\n  return res;\n}\nconst definition$l = {\n  mode: \"hsl\",\n  toMode: {\n    rgb: convertHslToRgb\n  },\n  fromMode: {\n    rgb: convertRgbToHsl\n  },\n  channels: [\"h\", \"s\", \"l\", \"alpha\"],\n  ranges: {\n    h: [0, 360]\n  },\n  gamut: \"rgb\",\n  parse: [parseHsl, parseHslLegacy],\n  serialize: (c2) => `hsl(${c2.h !== void 0 ? c2.h : \"none\"} ${c2.s !== void 0 ? c2.s * 100 + \"%\" : \"none\"} ${c2.l !== void 0 ? c2.l * 100 + \"%\" : \"none\"}${c2.alpha < 1 ? ` / ${c2.alpha}` : \"\"})`,\n  interpolate: {\n    h: { use: interpolatorLinear, fixup: fixupHueShorter },\n    s: interpolatorLinear,\n    l: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  difference: {\n    h: differenceHueSaturation\n  },\n  average: {\n    h: averageAngle\n  }\n};\nfunction convertHsvToRgb({ h, s, v, alpha }) {\n  h = normalizeHue(h !== void 0 ? h : 0);\n  if (s === void 0) s = 0;\n  if (v === void 0) v = 0;\n  let f2 = Math.abs(h / 60 % 2 - 1);\n  let res;\n  switch (Math.floor(h / 60)) {\n    case 0:\n      res = { r: v, g: v * (1 - s * f2), b: v * (1 - s) };\n      break;\n    case 1:\n      res = { r: v * (1 - s * f2), g: v, b: v * (1 - s) };\n      break;\n    case 2:\n      res = { r: v * (1 - s), g: v, b: v * (1 - s * f2) };\n      break;\n    case 3:\n      res = { r: v * (1 - s), g: v * (1 - s * f2), b: v };\n      break;\n    case 4:\n      res = { r: v * (1 - s * f2), g: v * (1 - s), b: v };\n      break;\n    case 5:\n      res = { r: v, g: v * (1 - s), b: v * (1 - s * f2) };\n      break;\n    default:\n      res = { r: v * (1 - s), g: v * (1 - s), b: v * (1 - s) };\n  }\n  res.mode = \"rgb\";\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n}\nfunction convertRgbToHsv({ r, g, b, alpha }) {\n  if (r === void 0) r = 0;\n  if (g === void 0) g = 0;\n  if (b === void 0) b = 0;\n  let M3 = Math.max(r, g, b), m = Math.min(r, g, b);\n  let res = {\n    mode: \"hsv\",\n    s: M3 === 0 ? 0 : 1 - m / M3,\n    v: M3\n  };\n  if (M3 - m !== 0)\n    res.h = (M3 === r ? (g - b) / (M3 - m) + (g < b) * 6 : M3 === g ? (b - r) / (M3 - m) + 2 : (r - g) / (M3 - m) + 4) * 60;\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n}\nconst definition$k = {\n  mode: \"hsv\",\n  toMode: {\n    rgb: convertHsvToRgb\n  },\n  parse: [\"--hsv\"],\n  serialize: \"--hsv\",\n  fromMode: {\n    rgb: convertRgbToHsv\n  },\n  channels: [\"h\", \"s\", \"v\", \"alpha\"],\n  ranges: {\n    h: [0, 360]\n  },\n  gamut: \"rgb\",\n  interpolate: {\n    h: { use: interpolatorLinear, fixup: fixupHueShorter },\n    s: interpolatorLinear,\n    v: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  difference: {\n    h: differenceHueSaturation\n  },\n  average: {\n    h: averageAngle\n  }\n};\nfunction convertHwbToRgb({ h, w, b, alpha }) {\n  if (w === void 0) w = 0;\n  if (b === void 0) b = 0;\n  if (w + b > 1) {\n    let s = w + b;\n    w /= s;\n    b /= s;\n  }\n  return convertHsvToRgb({\n    h,\n    s: b === 1 ? 1 : 1 - w / (1 - b),\n    v: 1 - b,\n    alpha\n  });\n}\nfunction convertRgbToHwb(rgba) {\n  let hsv = convertRgbToHsv(rgba);\n  if (hsv === void 0) return void 0;\n  let s = hsv.s !== void 0 ? hsv.s : 0;\n  let v = hsv.v !== void 0 ? hsv.v : 0;\n  let res = {\n    mode: \"hwb\",\n    w: (1 - s) * v,\n    b: 1 - v\n  };\n  if (hsv.h !== void 0) res.h = hsv.h;\n  if (hsv.alpha !== void 0) res.alpha = hsv.alpha;\n  return res;\n}\nfunction ParseHwb(color, parsed) {\n  if (!parsed || parsed[0] !== \"hwb\") {\n    return void 0;\n  }\n  const res = { mode: \"hwb\" };\n  const [, h, w, b, alpha] = parsed;\n  if (h.type !== Tok.None) {\n    if (h.type === Tok.Percentage) {\n      return void 0;\n    }\n    res.h = h.value;\n  }\n  if (w.type !== Tok.None) {\n    if (w.type === Tok.Hue) {\n      return void 0;\n    }\n    res.w = w.value / 100;\n  }\n  if (b.type !== Tok.None) {\n    if (b.type === Tok.Hue) {\n      return void 0;\n    }\n    res.b = b.value / 100;\n  }\n  if (alpha.type !== Tok.None) {\n    res.alpha = Math.min(\n      1,\n      Math.max(\n        0,\n        alpha.type === Tok.Number ? alpha.value : alpha.value / 100\n      )\n    );\n  }\n  return res;\n}\nconst definition$j = {\n  mode: \"hwb\",\n  toMode: {\n    rgb: convertHwbToRgb\n  },\n  fromMode: {\n    rgb: convertRgbToHwb\n  },\n  channels: [\"h\", \"w\", \"b\", \"alpha\"],\n  ranges: {\n    h: [0, 360]\n  },\n  gamut: \"rgb\",\n  parse: [ParseHwb],\n  serialize: (c2) => `hwb(${c2.h !== void 0 ? c2.h : \"none\"} ${c2.w !== void 0 ? c2.w * 100 + \"%\" : \"none\"} ${c2.b !== void 0 ? c2.b * 100 + \"%\" : \"none\"}${c2.alpha < 1 ? ` / ${c2.alpha}` : \"\"})`,\n  interpolate: {\n    h: { use: interpolatorLinear, fixup: fixupHueShorter },\n    w: interpolatorLinear,\n    b: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  difference: {\n    h: differenceHueNaive\n  },\n  average: {\n    h: averageAngle\n  }\n};\nconst YW = 203;\nconst M1 = 0.1593017578125;\nconst M2 = 78.84375;\nconst C1 = 0.8359375;\nconst C2 = 18.8515625;\nconst C3 = 18.6875;\nfunction transferPqDecode(v) {\n  if (v < 0) return 0;\n  const c2 = Math.pow(v, 1 / M2);\n  return 1e4 * Math.pow(Math.max(0, c2 - C1) / (C2 - C3 * c2), 1 / M1);\n}\nfunction transferPqEncode(v) {\n  if (v < 0) return 0;\n  const c2 = Math.pow(v / 1e4, M1);\n  return Math.pow((C1 + C2 * c2) / (1 + C3 * c2), M2);\n}\nconst toRel = (c2) => Math.max(c2 / YW, 0);\nconst convertItpToXyz65 = ({ i, t, p: p2, alpha }) => {\n  if (i === void 0) i = 0;\n  if (t === void 0) t = 0;\n  if (p2 === void 0) p2 = 0;\n  const l = transferPqDecode(\n    i + 0.008609037037932761 * t + 0.11102962500302593 * p2\n  );\n  const m = transferPqDecode(\n    i - 0.00860903703793275 * t - 0.11102962500302599 * p2\n  );\n  const s = transferPqDecode(\n    i + 0.5600313357106791 * t - 0.32062717498731885 * p2\n  );\n  const res = {\n    mode: \"xyz65\",\n    x: toRel(\n      2.070152218389422 * l - 1.3263473389671556 * m + 0.2066510476294051 * s\n    ),\n    y: toRel(\n      0.3647385209748074 * l + 0.680566024947227 * m - 0.0453045459220346 * s\n    ),\n    z: toRel(\n      -0.049747207535812 * l - 0.0492609666966138 * m + 1.1880659249923042 * s\n    )\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst toAbs = (c2 = 0) => Math.max(c2 * YW, 0);\nconst convertXyz65ToItp = ({ x, y, z, alpha }) => {\n  const absX = toAbs(x);\n  const absY = toAbs(y);\n  const absZ = toAbs(z);\n  const l = transferPqEncode(\n    0.3592832590121217 * absX + 0.6976051147779502 * absY - 0.0358915932320289 * absZ\n  );\n  const m = transferPqEncode(\n    -0.1920808463704995 * absX + 1.1004767970374323 * absY + 0.0753748658519118 * absZ\n  );\n  const s = transferPqEncode(\n    0.0070797844607477 * absX + 0.0748396662186366 * absY + 0.8433265453898765 * absZ\n  );\n  const i = 0.5 * l + 0.5 * m;\n  const t = 1.61376953125 * l - 3.323486328125 * m + 1.709716796875 * s;\n  const p2 = 4.378173828125 * l - 4.24560546875 * m - 0.132568359375 * s;\n  const res = { mode: \"itp\", i, t, p: p2 };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst definition$i = {\n  mode: \"itp\",\n  channels: [\"i\", \"t\", \"p\", \"alpha\"],\n  parse: [\"--ictcp\"],\n  serialize: \"--ictcp\",\n  toMode: {\n    xyz65: convertItpToXyz65,\n    rgb: (color) => convertXyz65ToRgb(convertItpToXyz65(color))\n  },\n  fromMode: {\n    xyz65: convertXyz65ToItp,\n    rgb: (color) => convertXyz65ToItp(convertRgbToXyz65(color))\n  },\n  ranges: {\n    i: [0, 0.581],\n    t: [-0.369, 0.272],\n    p: [-0.164, 0.331]\n  },\n  interpolate: {\n    i: interpolatorLinear,\n    t: interpolatorLinear,\n    p: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nconst p$1 = 134.03437499999998;\nconst d0$1 = 16295499532821565e-27;\nconst jabPqEncode = (v) => {\n  if (v < 0) return 0;\n  let vn2 = Math.pow(v / 1e4, M1);\n  return Math.pow((C1 + C2 * vn2) / (1 + C3 * vn2), p$1);\n};\nconst abs = (v = 0) => Math.max(v * 203, 0);\nconst convertXyz65ToJab = ({ x, y, z, alpha }) => {\n  x = abs(x);\n  y = abs(y);\n  z = abs(z);\n  let xp = 1.15 * x - 0.15 * z;\n  let yp = 0.66 * y + 0.34 * x;\n  let l = jabPqEncode(0.41478972 * xp + 0.579999 * yp + 0.014648 * z);\n  let m = jabPqEncode(-0.20151 * xp + 1.120649 * yp + 0.0531008 * z);\n  let s = jabPqEncode(-0.0166008 * xp + 0.2648 * yp + 0.6684799 * z);\n  let i = (l + m) / 2;\n  let res = {\n    mode: \"jab\",\n    j: 0.44 * i / (1 - 0.56 * i) - d0$1,\n    a: 3.524 * l - 4.066708 * m + 0.542708 * s,\n    b: 0.199076 * l + 1.096799 * m - 1.295875 * s\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst p = 134.03437499999998;\nconst d0 = 16295499532821565e-27;\nconst jabPqDecode = (v) => {\n  if (v < 0) return 0;\n  let vp = Math.pow(v, 1 / p);\n  return 1e4 * Math.pow((C1 - vp) / (C3 * vp - C2), 1 / M1);\n};\nconst rel = (v) => v / 203;\nconst convertJabToXyz65 = ({ j, a, b, alpha }) => {\n  if (j === void 0) j = 0;\n  if (a === void 0) a = 0;\n  if (b === void 0) b = 0;\n  let i = (j + d0) / (0.44 + 0.56 * (j + d0));\n  let l = jabPqDecode(i + 0.13860504 * a + 0.058047316 * b);\n  let m = jabPqDecode(i - 0.13860504 * a - 0.058047316 * b);\n  let s = jabPqDecode(i - 0.096019242 * a - 0.8118919 * b);\n  let res = {\n    mode: \"xyz65\",\n    x: rel(\n      1.661373024652174 * l - 0.914523081304348 * m + 0.23136208173913045 * s\n    ),\n    y: rel(\n      -0.3250758611844533 * l + 1.571847026732543 * m - 0.21825383453227928 * s\n    ),\n    z: rel(-0.090982811 * l - 0.31272829 * m + 1.5227666 * s)\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertRgbToJab = (rgb) => {\n  let res = convertXyz65ToJab(convertRgbToXyz65(rgb));\n  if (rgb.r === rgb.b && rgb.b === rgb.g) {\n    res.a = res.b = 0;\n  }\n  return res;\n};\nconst convertJabToRgb = (color) => convertXyz65ToRgb(convertJabToXyz65(color));\nconst definition$h = {\n  mode: \"jab\",\n  channels: [\"j\", \"a\", \"b\", \"alpha\"],\n  parse: [\"--jzazbz\"],\n  serialize: \"--jzazbz\",\n  fromMode: {\n    rgb: convertRgbToJab,\n    xyz65: convertXyz65ToJab\n  },\n  toMode: {\n    rgb: convertJabToRgb,\n    xyz65: convertJabToXyz65\n  },\n  ranges: {\n    j: [0, 0.222],\n    a: [-0.109, 0.129],\n    b: [-0.185, 0.134]\n  },\n  interpolate: {\n    j: interpolatorLinear,\n    a: interpolatorLinear,\n    b: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nconst convertJabToJch = ({ j, a, b, alpha }) => {\n  if (a === void 0) a = 0;\n  if (b === void 0) b = 0;\n  let c2 = Math.sqrt(a * a + b * b);\n  let res = {\n    mode: \"jch\",\n    j,\n    c: c2\n  };\n  if (c2) {\n    res.h = normalizeHue(Math.atan2(b, a) * 180 / Math.PI);\n  }\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertJchToJab = ({ j, c: c2, h, alpha }) => {\n  if (h === void 0) h = 0;\n  let res = {\n    mode: \"jab\",\n    j,\n    a: c2 ? c2 * Math.cos(h / 180 * Math.PI) : 0,\n    b: c2 ? c2 * Math.sin(h / 180 * Math.PI) : 0\n  };\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst definition$g = {\n  mode: \"jch\",\n  parse: [\"--jzczhz\"],\n  serialize: \"--jzczhz\",\n  toMode: {\n    jab: convertJchToJab,\n    rgb: (c2) => convertJabToRgb(convertJchToJab(c2))\n  },\n  fromMode: {\n    rgb: (c2) => convertJabToJch(convertRgbToJab(c2)),\n    jab: convertJabToJch\n  },\n  channels: [\"j\", \"c\", \"h\", \"alpha\"],\n  ranges: {\n    j: [0, 0.221],\n    c: [0, 0.19],\n    h: [0, 360]\n  },\n  interpolate: {\n    h: { use: interpolatorLinear, fixup: fixupHueShorter },\n    c: interpolatorLinear,\n    j: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  difference: {\n    h: differenceHueChroma\n  },\n  average: {\n    h: averageAngle\n  }\n};\nconst k = Math.pow(29, 3) / Math.pow(3, 3);\nconst e = Math.pow(6, 3) / Math.pow(29, 3);\nlet fn = (v) => Math.pow(v, 3) > e ? Math.pow(v, 3) : (116 * v - 16) / k;\nconst convertLabToXyz50 = ({ l, a, b, alpha }) => {\n  if (l === void 0) l = 0;\n  if (a === void 0) a = 0;\n  if (b === void 0) b = 0;\n  let fy = (l + 16) / 116;\n  let fx = a / 500 + fy;\n  let fz = fy - b / 200;\n  let res = {\n    mode: \"xyz50\",\n    x: fn(fx) * D50.X,\n    y: fn(fy) * D50.Y,\n    z: fn(fz) * D50.Z\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertXyz50ToRgb = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = convertLrgbToRgb({\n    r: x * 3.1341359569958707 - y * 1.6173863321612538 - 0.4906619460083532 * z,\n    g: x * -0.978795502912089 + y * 1.916254567259524 + 0.03344273116131949 * z,\n    b: x * 0.07195537988411677 - y * 0.2289768264158322 + 1.405386058324125 * z\n  });\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertLabToRgb = (lab) => convertXyz50ToRgb(convertLabToXyz50(lab));\nconst convertRgbToXyz50 = (rgb) => {\n  let { r, g, b, alpha } = convertRgbToLrgb(rgb);\n  let res = {\n    mode: \"xyz50\",\n    x: 0.436065742824811 * r + 0.3851514688337912 * g + 0.14307845442264197 * b,\n    y: 0.22249319175623702 * r + 0.7168870538238823 * g + 0.06061979053616537 * b,\n    z: 0.013923904500943465 * r + 0.09708128566574634 * g + 0.7140993584005155 * b\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst f = (value) => value > e ? Math.cbrt(value) : (k * value + 16) / 116;\nconst convertXyz50ToLab = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let f0 = f(x / D50.X);\n  let f1 = f(y / D50.Y);\n  let f2 = f(z / D50.Z);\n  let res = {\n    mode: \"lab\",\n    l: 116 * f1 - 16,\n    a: 500 * (f0 - f1),\n    b: 200 * (f1 - f2)\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertRgbToLab = (rgb) => {\n  let res = convertXyz50ToLab(convertRgbToXyz50(rgb));\n  if (rgb.r === rgb.b && rgb.b === rgb.g) {\n    res.a = res.b = 0;\n  }\n  return res;\n};\nfunction parseLab(color, parsed) {\n  if (!parsed || parsed[0] !== \"lab\") {\n    return void 0;\n  }\n  const res = { mode: \"lab\" };\n  const [, l, a, b, alpha] = parsed;\n  if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) {\n    return void 0;\n  }\n  if (l.type !== Tok.None) {\n    res.l = Math.min(Math.max(0, l.value), 100);\n  }\n  if (a.type !== Tok.None) {\n    res.a = a.type === Tok.Number ? a.value : a.value * 125 / 100;\n  }\n  if (b.type !== Tok.None) {\n    res.b = b.type === Tok.Number ? b.value : b.value * 125 / 100;\n  }\n  if (alpha.type !== Tok.None) {\n    res.alpha = Math.min(\n      1,\n      Math.max(\n        0,\n        alpha.type === Tok.Number ? alpha.value : alpha.value / 100\n      )\n    );\n  }\n  return res;\n}\nconst definition$f = {\n  mode: \"lab\",\n  toMode: {\n    xyz50: convertLabToXyz50,\n    rgb: convertLabToRgb\n  },\n  fromMode: {\n    xyz50: convertXyz50ToLab,\n    rgb: convertRgbToLab\n  },\n  channels: [\"l\", \"a\", \"b\", \"alpha\"],\n  ranges: {\n    l: [0, 100],\n    a: [-125, 125],\n    b: [-125, 125]\n  },\n  parse: [parseLab],\n  serialize: (c2) => `lab(${c2.l !== void 0 ? c2.l : \"none\"} ${c2.a !== void 0 ? c2.a : \"none\"} ${c2.b !== void 0 ? c2.b : \"none\"}${c2.alpha < 1 ? ` / ${c2.alpha}` : \"\"})`,\n  interpolate: {\n    l: interpolatorLinear,\n    a: interpolatorLinear,\n    b: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nconst definition$e = {\n  ...definition$f,\n  mode: \"lab65\",\n  parse: [\"--lab-d65\"],\n  serialize: \"--lab-d65\",\n  toMode: {\n    xyz65: convertLab65ToXyz65,\n    rgb: convertLab65ToRgb\n  },\n  fromMode: {\n    xyz65: convertXyz65ToLab65,\n    rgb: convertRgbToLab65\n  },\n  ranges: {\n    l: [0, 100],\n    a: [-125, 125],\n    b: [-125, 125]\n  }\n};\nfunction parseLch(color, parsed) {\n  if (!parsed || parsed[0] !== \"lch\") {\n    return void 0;\n  }\n  const res = { mode: \"lch\" };\n  const [, l, c2, h, alpha] = parsed;\n  if (l.type !== Tok.None) {\n    if (l.type === Tok.Hue) {\n      return void 0;\n    }\n    res.l = Math.min(Math.max(0, l.value), 100);\n  }\n  if (c2.type !== Tok.None) {\n    res.c = Math.max(\n      0,\n      c2.type === Tok.Number ? c2.value : c2.value * 150 / 100\n    );\n  }\n  if (h.type !== Tok.None) {\n    if (h.type === Tok.Percentage) {\n      return void 0;\n    }\n    res.h = h.value;\n  }\n  if (alpha.type !== Tok.None) {\n    res.alpha = Math.min(\n      1,\n      Math.max(\n        0,\n        alpha.type === Tok.Number ? alpha.value : alpha.value / 100\n      )\n    );\n  }\n  return res;\n}\nconst definition$d = {\n  mode: \"lch\",\n  toMode: {\n    lab: convertLchToLab,\n    rgb: (c2) => convertLabToRgb(convertLchToLab(c2))\n  },\n  fromMode: {\n    rgb: (c2) => convertLabToLch(convertRgbToLab(c2)),\n    lab: convertLabToLch\n  },\n  channels: [\"l\", \"c\", \"h\", \"alpha\"],\n  ranges: {\n    l: [0, 100],\n    c: [0, 150],\n    h: [0, 360]\n  },\n  parse: [parseLch],\n  serialize: (c2) => `lch(${c2.l !== void 0 ? c2.l : \"none\"} ${c2.c !== void 0 ? c2.c : \"none\"} ${c2.h !== void 0 ? c2.h : \"none\"}${c2.alpha < 1 ? ` / ${c2.alpha}` : \"\"})`,\n  interpolate: {\n    h: { use: interpolatorLinear, fixup: fixupHueShorter },\n    c: interpolatorLinear,\n    l: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  difference: {\n    h: differenceHueChroma\n  },\n  average: {\n    h: averageAngle\n  }\n};\nconst definition$c = {\n  ...definition$d,\n  mode: \"lch65\",\n  parse: [\"--lch-d65\"],\n  serialize: \"--lch-d65\",\n  toMode: {\n    lab65: (c2) => convertLchToLab(c2, \"lab65\"),\n    rgb: (c2) => convertLab65ToRgb(convertLchToLab(c2, \"lab65\"))\n  },\n  fromMode: {\n    rgb: (c2) => convertLabToLch(convertRgbToLab65(c2), \"lch65\"),\n    lab65: (c2) => convertLabToLch(c2, \"lch65\")\n  },\n  ranges: {\n    l: [0, 100],\n    c: [0, 150],\n    h: [0, 360]\n  }\n};\nconst convertLuvToLchuv = ({ l, u, v, alpha }) => {\n  if (u === void 0) u = 0;\n  if (v === void 0) v = 0;\n  let c2 = Math.sqrt(u * u + v * v);\n  let res = {\n    mode: \"lchuv\",\n    l,\n    c: c2\n  };\n  if (c2) {\n    res.h = normalizeHue(Math.atan2(v, u) * 180 / Math.PI);\n  }\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertLchuvToLuv = ({ l, c: c2, h, alpha }) => {\n  if (h === void 0) h = 0;\n  let res = {\n    mode: \"luv\",\n    l,\n    u: c2 ? c2 * Math.cos(h / 180 * Math.PI) : 0,\n    v: c2 ? c2 * Math.sin(h / 180 * Math.PI) : 0\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst u_fn$1 = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);\nconst v_fn$1 = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);\nconst un$1 = u_fn$1(D50.X, D50.Y, D50.Z);\nconst vn$1 = v_fn$1(D50.X, D50.Y, D50.Z);\nconst l_fn = (value) => value <= e ? k * value : 116 * Math.cbrt(value) - 16;\nconst convertXyz50ToLuv = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let l = l_fn(y / D50.Y);\n  let u = u_fn$1(x, y, z);\n  let v = v_fn$1(x, y, z);\n  if (!isFinite(u) || !isFinite(v)) {\n    l = u = v = 0;\n  } else {\n    u = 13 * l * (u - un$1);\n    v = 13 * l * (v - vn$1);\n  }\n  let res = {\n    mode: \"luv\",\n    l,\n    u,\n    v\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst u_fn = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);\nconst v_fn = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);\nconst un = u_fn(D50.X, D50.Y, D50.Z);\nconst vn = v_fn(D50.X, D50.Y, D50.Z);\nconst convertLuvToXyz50 = ({ l, u, v, alpha }) => {\n  if (l === void 0) l = 0;\n  if (l === 0) {\n    return { mode: \"xyz50\", x: 0, y: 0, z: 0 };\n  }\n  if (u === void 0) u = 0;\n  if (v === void 0) v = 0;\n  let up = u / (13 * l) + un;\n  let vp = v / (13 * l) + vn;\n  let y = D50.Y * (l <= 8 ? l / k : Math.pow((l + 16) / 116, 3));\n  let x = y * (9 * up) / (4 * vp);\n  let z = y * (12 - 3 * up - 20 * vp) / (4 * vp);\n  let res = { mode: \"xyz50\", x, y, z };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertRgbToLchuv = (rgb) => convertLuvToLchuv(convertXyz50ToLuv(convertRgbToXyz50(rgb)));\nconst convertLchuvToRgb = (lchuv) => convertXyz50ToRgb(convertLuvToXyz50(convertLchuvToLuv(lchuv)));\nconst definition$b = {\n  mode: \"lchuv\",\n  toMode: {\n    luv: convertLchuvToLuv,\n    rgb: convertLchuvToRgb\n  },\n  fromMode: {\n    rgb: convertRgbToLchuv,\n    luv: convertLuvToLchuv\n  },\n  channels: [\"l\", \"c\", \"h\", \"alpha\"],\n  parse: [\"--lchuv\"],\n  serialize: \"--lchuv\",\n  ranges: {\n    l: [0, 100],\n    c: [0, 176.956],\n    h: [0, 360]\n  },\n  interpolate: {\n    h: { use: interpolatorLinear, fixup: fixupHueShorter },\n    c: interpolatorLinear,\n    l: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  },\n  difference: {\n    h: differenceHueChroma\n  },\n  average: {\n    h: averageAngle\n  }\n};\nconst definition$a = {\n  ...definition$r,\n  mode: \"lrgb\",\n  toMode: {\n    rgb: convertLrgbToRgb\n  },\n  fromMode: {\n    rgb: convertRgbToLrgb\n  },\n  parse: [\"srgb-linear\"],\n  serialize: \"srgb-linear\"\n};\nconst definition$9 = {\n  mode: \"luv\",\n  toMode: {\n    xyz50: convertLuvToXyz50,\n    rgb: (luv) => convertXyz50ToRgb(convertLuvToXyz50(luv))\n  },\n  fromMode: {\n    xyz50: convertXyz50ToLuv,\n    rgb: (rgb) => convertXyz50ToLuv(convertRgbToXyz50(rgb))\n  },\n  channels: [\"l\", \"u\", \"v\", \"alpha\"],\n  parse: [\"--luv\"],\n  serialize: \"--luv\",\n  ranges: {\n    l: [0, 100],\n    u: [-84.936, 175.042],\n    v: [-125.882, 87.243]\n  },\n  interpolate: {\n    l: interpolatorLinear,\n    u: interpolatorLinear,\n    v: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nconst convertLrgbToOklab = ({ r, g, b, alpha }) => {\n  if (r === void 0) r = 0;\n  if (g === void 0) g = 0;\n  if (b === void 0) b = 0;\n  let L = Math.cbrt(\n    0.412221469470763 * r + 0.5363325372617348 * g + 0.0514459932675022 * b\n  );\n  let M3 = Math.cbrt(\n    0.2119034958178252 * r + 0.6806995506452344 * g + 0.1073969535369406 * b\n  );\n  let S = Math.cbrt(\n    0.0883024591900564 * r + 0.2817188391361215 * g + 0.6299787016738222 * b\n  );\n  let res = {\n    mode: \"oklab\",\n    l: 0.210454268309314 * L + 0.7936177747023054 * M3 - 0.0040720430116193 * S,\n    a: 1.9779985324311684 * L - 2.42859224204858 * M3 + 0.450593709617411 * S,\n    b: 0.0259040424655478 * L + 0.7827717124575296 * M3 - 0.8086757549230774 * S\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertRgbToOklab = (rgb) => {\n  let res = convertLrgbToOklab(convertRgbToLrgb(rgb));\n  if (rgb.r === rgb.b && rgb.b === rgb.g) {\n    res.a = res.b = 0;\n  }\n  return res;\n};\nconst convertOklabToLrgb = ({ l, a, b, alpha }) => {\n  if (l === void 0) l = 0;\n  if (a === void 0) a = 0;\n  if (b === void 0) b = 0;\n  let L = Math.pow(l + 0.3963377773761749 * a + 0.2158037573099136 * b, 3);\n  let M3 = Math.pow(l - 0.1055613458156586 * a - 0.0638541728258133 * b, 3);\n  let S = Math.pow(l - 0.0894841775298119 * a - 1.2914855480194092 * b, 3);\n  let res = {\n    mode: \"lrgb\",\n    r: 4.076741636075957 * L - 3.3077115392580616 * M3 + 0.2309699031821044 * S,\n    g: -1.2684379732850317 * L + 2.6097573492876887 * M3 - 0.3413193760026573 * S,\n    b: -0.0041960761386756 * L - 0.7034186179359362 * M3 + 1.7076146940746117 * S\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertOklabToRgb = (c2) => convertLrgbToRgb(convertOklabToLrgb(c2));\nfunction toe(x) {\n  const k_1 = 0.206;\n  const k_2 = 0.03;\n  const k_3 = (1 + k_1) / (1 + k_2);\n  return 0.5 * (k_3 * x - k_1 + Math.sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4 * k_2 * k_3 * x));\n}\nfunction toe_inv(x) {\n  const k_1 = 0.206;\n  const k_2 = 0.03;\n  const k_3 = (1 + k_1) / (1 + k_2);\n  return (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\nfunction compute_max_saturation(a, b) {\n  let k0, k1, k2, k3, k4, wl, wm, ws;\n  if (-1.88170328 * a - 0.80936493 * b > 1) {\n    k0 = 1.19086277;\n    k1 = 1.76576728;\n    k2 = 0.59662641;\n    k3 = 0.75515197;\n    k4 = 0.56771245;\n    wl = 4.0767416621;\n    wm = -3.3077115913;\n    ws = 0.2309699292;\n  } else if (1.81444104 * a - 1.19445276 * b > 1) {\n    k0 = 0.73956515;\n    k1 = -0.45954404;\n    k2 = 0.08285427;\n    k3 = 0.1254107;\n    k4 = 0.14503204;\n    wl = -1.2684380046;\n    wm = 2.6097574011;\n    ws = -0.3413193965;\n  } else {\n    k0 = 1.35733652;\n    k1 = -915799e-8;\n    k2 = -1.1513021;\n    k3 = -0.50559606;\n    k4 = 692167e-8;\n    wl = -0.0041960863;\n    wm = -0.7034186147;\n    ws = 1.707614701;\n  }\n  let S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n  let k_l = 0.3963377774 * a + 0.2158037573 * b;\n  let k_m = -0.1055613458 * a - 0.0638541728 * b;\n  let k_s = -0.0894841775 * a - 1.291485548 * b;\n  {\n    let l_ = 1 + S * k_l;\n    let m_ = 1 + S * k_m;\n    let s_ = 1 + S * k_s;\n    let l = l_ * l_ * l_;\n    let m = m_ * m_ * m_;\n    let s = s_ * s_ * s_;\n    let l_dS = 3 * k_l * l_ * l_;\n    let m_dS = 3 * k_m * m_ * m_;\n    let s_dS = 3 * k_s * s_ * s_;\n    let l_dS2 = 6 * k_l * k_l * l_;\n    let m_dS2 = 6 * k_m * k_m * m_;\n    let s_dS2 = 6 * k_s * k_s * s_;\n    let f2 = wl * l + wm * m + ws * s;\n    let f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n    let f22 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n    S = S - f2 * f1 / (f1 * f1 - 0.5 * f2 * f22);\n  }\n  return S;\n}\nfunction find_cusp(a, b) {\n  let S_cusp = compute_max_saturation(a, b);\n  let rgb = convertOklabToLrgb({ l: 1, a: S_cusp * a, b: S_cusp * b });\n  let L_cusp = Math.cbrt(1 / Math.max(rgb.r, rgb.g, rgb.b));\n  let C_cusp = L_cusp * S_cusp;\n  return [L_cusp, C_cusp];\n}\nfunction find_gamut_intersection(a, b, L1, C12, L0, cusp = null) {\n  if (!cusp) {\n    cusp = find_cusp(a, b);\n  }\n  let t;\n  if ((L1 - L0) * cusp[1] - (cusp[0] - L0) * C12 <= 0) {\n    t = cusp[1] * L0 / (C12 * cusp[0] + cusp[1] * (L0 - L1));\n  } else {\n    t = cusp[1] * (L0 - 1) / (C12 * (cusp[0] - 1) + cusp[1] * (L0 - L1));\n    {\n      let dL = L1 - L0;\n      let dC = C12;\n      let k_l = 0.3963377774 * a + 0.2158037573 * b;\n      let k_m = -0.1055613458 * a - 0.0638541728 * b;\n      let k_s = -0.0894841775 * a - 1.291485548 * b;\n      let l_dt = dL + dC * k_l;\n      let m_dt = dL + dC * k_m;\n      let s_dt = dL + dC * k_s;\n      {\n        let L = L0 * (1 - t) + t * L1;\n        let C = t * C12;\n        let l_ = L + C * k_l;\n        let m_ = L + C * k_m;\n        let s_ = L + C * k_s;\n        let l = l_ * l_ * l_;\n        let m = m_ * m_ * m_;\n        let s = s_ * s_ * s_;\n        let ldt = 3 * l_dt * l_ * l_;\n        let mdt = 3 * m_dt * m_ * m_;\n        let sdt = 3 * s_dt * s_ * s_;\n        let ldt2 = 6 * l_dt * l_dt * l_;\n        let mdt2 = 6 * m_dt * m_dt * m_;\n        let sdt2 = 6 * s_dt * s_dt * s_;\n        let r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1;\n        let r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt;\n        let r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2;\n        let u_r = r1 / (r1 * r1 - 0.5 * r * r2);\n        let t_r = -r * u_r;\n        let g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1;\n        let g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt;\n        let g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2;\n        let u_g = g1 / (g1 * g1 - 0.5 * g * g2);\n        let t_g = -g * u_g;\n        let b2 = -0.0041960863 * l - 0.7034186147 * m + 1.707614701 * s - 1;\n        let b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.707614701 * sdt;\n        let b22 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.707614701 * sdt2;\n        let u_b = b1 / (b1 * b1 - 0.5 * b2 * b22);\n        let t_b = -b2 * u_b;\n        t_r = u_r >= 0 ? t_r : 1e6;\n        t_g = u_g >= 0 ? t_g : 1e6;\n        t_b = u_b >= 0 ? t_b : 1e6;\n        t += Math.min(t_r, Math.min(t_g, t_b));\n      }\n    }\n  }\n  return t;\n}\nfunction get_ST_max(a_, b_, cusp = null) {\n  if (!cusp) {\n    cusp = find_cusp(a_, b_);\n  }\n  let L = cusp[0];\n  let C = cusp[1];\n  return [C / L, C / (1 - L)];\n}\nfunction get_Cs(L, a_, b_) {\n  let cusp = find_cusp(a_, b_);\n  let C_max = find_gamut_intersection(a_, b_, L, 1, L, cusp);\n  let ST_max = get_ST_max(a_, b_, cusp);\n  let S_mid = 0.11516993 + 1 / (7.4477897 + 4.1590124 * b_ + a_ * (-2.19557347 + 1.75198401 * b_ + a_ * (-2.13704948 - 10.02301043 * b_ + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));\n  let T_mid = 0.11239642 + 1 / (1.6132032 - 0.68124379 * b_ + a_ * (0.40370612 + 0.90148123 * b_ + a_ * (-0.27087943 + 0.6122399 * b_ + a_ * (299215e-8 - 0.45399568 * b_ - 0.14661872 * a_))));\n  let k2 = C_max / Math.min(L * ST_max[0], (1 - L) * ST_max[1]);\n  let C_a = L * S_mid;\n  let C_b = (1 - L) * T_mid;\n  let C_mid = 0.9 * k2 * Math.sqrt(\n    Math.sqrt(\n      1 / (1 / (C_a * C_a * C_a * C_a) + 1 / (C_b * C_b * C_b * C_b))\n    )\n  );\n  C_a = L * 0.4;\n  C_b = (1 - L) * 0.8;\n  let C_0 = Math.sqrt(1 / (1 / (C_a * C_a) + 1 / (C_b * C_b)));\n  return [C_0, C_mid, C_max];\n}\nfunction convertOklabToOkhsl(lab) {\n  const l = lab.l !== void 0 ? lab.l : 0;\n  const a = lab.a !== void 0 ? lab.a : 0;\n  const b = lab.b !== void 0 ? lab.b : 0;\n  const ret = { mode: \"okhsl\", l: toe(l) };\n  if (lab.alpha !== void 0) {\n    ret.alpha = lab.alpha;\n  }\n  let c2 = Math.sqrt(a * a + b * b);\n  if (!c2) {\n    ret.s = 0;\n    return ret;\n  }\n  let [C_0, C_mid, C_max] = get_Cs(l, a / c2, b / c2);\n  let s;\n  if (c2 < C_mid) {\n    let k_0 = 0;\n    let k_1 = 0.8 * C_0;\n    let k_2 = 1 - k_1 / C_mid;\n    let t = (c2 - k_0) / (k_1 + k_2 * (c2 - k_0));\n    s = t * 0.8;\n  } else {\n    let k_0 = C_mid;\n    let k_1 = 0.2 * C_mid * C_mid * 1.25 * 1.25 / C_0;\n    let k_2 = 1 - k_1 / (C_max - C_mid);\n    let t = (c2 - k_0) / (k_1 + k_2 * (c2 - k_0));\n    s = 0.8 + 0.2 * t;\n  }\n  if (s) {\n    ret.s = s;\n    ret.h = normalizeHue(Math.atan2(b, a) * 180 / Math.PI);\n  }\n  return ret;\n}\nfunction convertOkhslToOklab(hsl) {\n  let h = hsl.h !== void 0 ? hsl.h : 0;\n  let s = hsl.s !== void 0 ? hsl.s : 0;\n  let l = hsl.l !== void 0 ? hsl.l : 0;\n  const ret = { mode: \"oklab\", l: toe_inv(l) };\n  if (hsl.alpha !== void 0) {\n    ret.alpha = hsl.alpha;\n  }\n  if (!s || l === 1) {\n    ret.a = ret.b = 0;\n    return ret;\n  }\n  let a_ = Math.cos(h / 180 * Math.PI);\n  let b_ = Math.sin(h / 180 * Math.PI);\n  let [C_0, C_mid, C_max] = get_Cs(ret.l, a_, b_);\n  let t, k_0, k_1, k_2;\n  if (s < 0.8) {\n    t = 1.25 * s;\n    k_0 = 0;\n    k_1 = 0.8 * C_0;\n    k_2 = 1 - k_1 / C_mid;\n  } else {\n    t = 5 * (s - 0.8);\n    k_0 = C_mid;\n    k_1 = 0.2 * C_mid * C_mid * 1.25 * 1.25 / C_0;\n    k_2 = 1 - k_1 / (C_max - C_mid);\n  }\n  let C = k_0 + t * k_1 / (1 - k_2 * t);\n  ret.a = C * a_;\n  ret.b = C * b_;\n  return ret;\n}\nconst modeOkhsl = {\n  ...definition$l,\n  mode: \"okhsl\",\n  channels: [\"h\", \"s\", \"l\", \"alpha\"],\n  parse: [\"--okhsl\"],\n  serialize: \"--okhsl\",\n  fromMode: {\n    oklab: convertOklabToOkhsl,\n    rgb: (c2) => convertOklabToOkhsl(convertRgbToOklab(c2))\n  },\n  toMode: {\n    oklab: convertOkhslToOklab,\n    rgb: (c2) => convertOklabToRgb(convertOkhslToOklab(c2))\n  }\n};\nfunction convertOklabToOkhsv(lab) {\n  let l = lab.l !== void 0 ? lab.l : 0;\n  let a = lab.a !== void 0 ? lab.a : 0;\n  let b = lab.b !== void 0 ? lab.b : 0;\n  let c2 = Math.sqrt(a * a + b * b);\n  let a_ = c2 ? a / c2 : 1;\n  let b_ = c2 ? b / c2 : 1;\n  let [S_max, T] = get_ST_max(a_, b_);\n  let S_0 = 0.5;\n  let k2 = 1 - S_0 / S_max;\n  let t = T / (c2 + l * T);\n  let L_v = t * l;\n  let C_v = t * c2;\n  let L_vt = toe_inv(L_v);\n  let C_vt = C_v * L_vt / L_v;\n  let rgb_scale = convertOklabToLrgb({ l: L_vt, a: a_ * C_vt, b: b_ * C_vt });\n  let scale_L = Math.cbrt(\n    1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0)\n  );\n  l = l / scale_L;\n  c2 = c2 / scale_L * toe(l) / l;\n  l = toe(l);\n  const ret = {\n    mode: \"okhsv\",\n    s: c2 ? (S_0 + T) * C_v / (T * S_0 + T * k2 * C_v) : 0,\n    v: l ? l / L_v : 0\n  };\n  if (ret.s) {\n    ret.h = normalizeHue(Math.atan2(b, a) * 180 / Math.PI);\n  }\n  if (lab.alpha !== void 0) {\n    ret.alpha = lab.alpha;\n  }\n  return ret;\n}\nfunction convertOkhsvToOklab(hsv) {\n  const ret = { mode: \"oklab\" };\n  if (hsv.alpha !== void 0) {\n    ret.alpha = hsv.alpha;\n  }\n  const h = hsv.h !== void 0 ? hsv.h : 0;\n  const s = hsv.s !== void 0 ? hsv.s : 0;\n  const v = hsv.v !== void 0 ? hsv.v : 0;\n  const a_ = Math.cos(h / 180 * Math.PI);\n  const b_ = Math.sin(h / 180 * Math.PI);\n  const [S_max, T] = get_ST_max(a_, b_);\n  const S_0 = 0.5;\n  const k2 = 1 - S_0 / S_max;\n  const L_v = 1 - s * S_0 / (S_0 + T - T * k2 * s);\n  const C_v = s * T * S_0 / (S_0 + T - T * k2 * s);\n  const L_vt = toe_inv(L_v);\n  const C_vt = C_v * L_vt / L_v;\n  const rgb_scale = convertOklabToLrgb({\n    l: L_vt,\n    a: a_ * C_vt,\n    b: b_ * C_vt\n  });\n  const scale_L = Math.cbrt(\n    1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0)\n  );\n  const L_new = toe_inv(v * L_v);\n  const C = C_v * L_new / L_v;\n  ret.l = L_new * scale_L;\n  ret.a = C * a_ * scale_L;\n  ret.b = C * b_ * scale_L;\n  return ret;\n}\nconst modeOkhsv = {\n  ...definition$k,\n  mode: \"okhsv\",\n  channels: [\"h\", \"s\", \"v\", \"alpha\"],\n  parse: [\"--okhsv\"],\n  serialize: \"--okhsv\",\n  fromMode: {\n    oklab: convertOklabToOkhsv,\n    rgb: (c2) => convertOklabToOkhsv(convertRgbToOklab(c2))\n  },\n  toMode: {\n    oklab: convertOkhsvToOklab,\n    rgb: (c2) => convertOklabToRgb(convertOkhsvToOklab(c2))\n  }\n};\nfunction parseOklab(color, parsed) {\n  if (!parsed || parsed[0] !== \"oklab\") {\n    return void 0;\n  }\n  const res = { mode: \"oklab\" };\n  const [, l, a, b, alpha] = parsed;\n  if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) {\n    return void 0;\n  }\n  if (l.type !== Tok.None) {\n    res.l = Math.min(\n      Math.max(0, l.type === Tok.Number ? l.value : l.value / 100),\n      1\n    );\n  }\n  if (a.type !== Tok.None) {\n    res.a = a.type === Tok.Number ? a.value : a.value * 0.4 / 100;\n  }\n  if (b.type !== Tok.None) {\n    res.b = b.type === Tok.Number ? b.value : b.value * 0.4 / 100;\n  }\n  if (alpha.type !== Tok.None) {\n    res.alpha = Math.min(\n      1,\n      Math.max(\n        0,\n        alpha.type === Tok.Number ? alpha.value : alpha.value / 100\n      )\n    );\n  }\n  return res;\n}\nconst definition$8 = {\n  ...definition$f,\n  mode: \"oklab\",\n  toMode: {\n    lrgb: convertOklabToLrgb,\n    rgb: convertOklabToRgb\n  },\n  fromMode: {\n    lrgb: convertLrgbToOklab,\n    rgb: convertRgbToOklab\n  },\n  ranges: {\n    l: [0, 1],\n    a: [-0.4, 0.4],\n    b: [-0.4, 0.4]\n  },\n  parse: [parseOklab],\n  serialize: (c2) => `oklab(${c2.l !== void 0 ? c2.l : \"none\"} ${c2.a !== void 0 ? c2.a : \"none\"} ${c2.b !== void 0 ? c2.b : \"none\"}${c2.alpha < 1 ? ` / ${c2.alpha}` : \"\"})`\n};\nfunction parseOklch(color, parsed) {\n  if (!parsed || parsed[0] !== \"oklch\") {\n    return void 0;\n  }\n  const res = { mode: \"oklch\" };\n  const [, l, c2, h, alpha] = parsed;\n  if (l.type !== Tok.None) {\n    if (l.type === Tok.Hue) {\n      return void 0;\n    }\n    res.l = Math.min(\n      Math.max(0, l.type === Tok.Number ? l.value : l.value / 100),\n      1\n    );\n  }\n  if (c2.type !== Tok.None) {\n    res.c = Math.max(\n      0,\n      c2.type === Tok.Number ? c2.value : c2.value * 0.4 / 100\n    );\n  }\n  if (h.type !== Tok.None) {\n    if (h.type === Tok.Percentage) {\n      return void 0;\n    }\n    res.h = h.value;\n  }\n  if (alpha.type !== Tok.None) {\n    res.alpha = Math.min(\n      1,\n      Math.max(\n        0,\n        alpha.type === Tok.Number ? alpha.value : alpha.value / 100\n      )\n    );\n  }\n  return res;\n}\nconst definition$7 = {\n  ...definition$d,\n  mode: \"oklch\",\n  toMode: {\n    oklab: (c2) => convertLchToLab(c2, \"oklab\"),\n    rgb: (c2) => convertOklabToRgb(convertLchToLab(c2, \"oklab\"))\n  },\n  fromMode: {\n    rgb: (c2) => convertLabToLch(convertRgbToOklab(c2), \"oklch\"),\n    oklab: (c2) => convertLabToLch(c2, \"oklch\")\n  },\n  parse: [parseOklch],\n  serialize: (c2) => `oklch(${c2.l !== void 0 ? c2.l : \"none\"} ${c2.c !== void 0 ? c2.c : \"none\"} ${c2.h !== void 0 ? c2.h : \"none\"}${c2.alpha < 1 ? ` / ${c2.alpha}` : \"\"})`,\n  ranges: {\n    l: [0, 1],\n    c: [0, 0.4],\n    h: [0, 360]\n  }\n};\nconst convertP3ToXyz65 = (rgb) => {\n  let { r, g, b, alpha } = convertRgbToLrgb(rgb);\n  let res = {\n    mode: \"xyz65\",\n    x: 0.486570948648216 * r + 0.265667693169093 * g + 0.1982172852343625 * b,\n    y: 0.2289745640697487 * r + 0.6917385218365062 * g + 0.079286914093745 * b,\n    z: 0 * r + 0.0451133818589026 * g + 1.043944368900976 * b\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertXyz65ToP3 = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = convertLrgbToRgb(\n    {\n      r: x * 2.4934969119414263 - y * 0.9313836179191242 - 0.402710784450717 * z,\n      g: x * -0.8294889695615749 + y * 1.7626640603183465 + 0.0236246858419436 * z,\n      b: x * 0.0358458302437845 - y * 0.0761723892680418 + 0.9568845240076871 * z\n    },\n    \"p3\"\n  );\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst definition$6 = {\n  ...definition$r,\n  mode: \"p3\",\n  parse: [\"display-p3\"],\n  serialize: \"display-p3\",\n  fromMode: {\n    rgb: (color) => convertXyz65ToP3(convertRgbToXyz65(color)),\n    xyz65: convertXyz65ToP3\n  },\n  toMode: {\n    rgb: (color) => convertXyz65ToRgb(convertP3ToXyz65(color)),\n    xyz65: convertP3ToXyz65\n  }\n};\nconst gamma$1 = (v) => {\n  let abs2 = Math.abs(v);\n  if (abs2 >= 1 / 512) {\n    return Math.sign(v) * Math.pow(abs2, 1 / 1.8);\n  }\n  return 16 * v;\n};\nconst convertXyz50ToProphoto = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = {\n    mode: \"prophoto\",\n    r: gamma$1(\n      x * 1.3457868816471585 - y * 0.2555720873797946 - 0.0511018649755453 * z\n    ),\n    g: gamma$1(\n      x * -0.5446307051249019 + y * 1.5082477428451466 + 0.0205274474364214 * z\n    ),\n    b: gamma$1(x * 0 + y * 0 + 1.2119675456389452 * z)\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst linearize$1 = (v = 0) => {\n  let abs2 = Math.abs(v);\n  if (abs2 >= 16 / 512) {\n    return Math.sign(v) * Math.pow(abs2, 1.8);\n  }\n  return v / 16;\n};\nconst convertProphotoToXyz50 = (prophoto) => {\n  let r = linearize$1(prophoto.r);\n  let g = linearize$1(prophoto.g);\n  let b = linearize$1(prophoto.b);\n  let res = {\n    mode: \"xyz50\",\n    x: 0.7977666449006423 * r + 0.1351812974005331 * g + 0.0313477341283922 * b,\n    y: 0.2880748288194013 * r + 0.7118352342418731 * g + 899369387256e-16 * b,\n    z: 0 * r + 0 * g + 0.8251046025104602 * b\n  };\n  if (prophoto.alpha !== void 0) {\n    res.alpha = prophoto.alpha;\n  }\n  return res;\n};\nconst definition$5 = {\n  ...definition$r,\n  mode: \"prophoto\",\n  parse: [\"prophoto-rgb\"],\n  serialize: \"prophoto-rgb\",\n  fromMode: {\n    xyz50: convertXyz50ToProphoto,\n    rgb: (color) => convertXyz50ToProphoto(convertRgbToXyz50(color))\n  },\n  toMode: {\n    xyz50: convertProphotoToXyz50,\n    rgb: (color) => convertXyz50ToRgb(convertProphotoToXyz50(color))\n  }\n};\nconst α$1 = 1.09929682680944;\nconst β$1 = 0.018053968510807;\nconst gamma = (v) => {\n  const abs2 = Math.abs(v);\n  if (abs2 > β$1) {\n    return (Math.sign(v) || 1) * (α$1 * Math.pow(abs2, 0.45) - (α$1 - 1));\n  }\n  return 4.5 * v;\n};\nconst convertXyz65ToRec2020 = ({ x, y, z, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = {\n    mode: \"rec2020\",\n    r: gamma(\n      x * 1.7166511879712683 - y * 0.3556707837763925 - 0.2533662813736599 * z\n    ),\n    g: gamma(\n      x * -0.6666843518324893 + y * 1.6164812366349395 + 0.0157685458139111 * z\n    ),\n    b: gamma(\n      x * 0.0176398574453108 - y * 0.0427706132578085 + 0.9421031212354739 * z\n    )\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst α = 1.09929682680944;\nconst β = 0.018053968510807;\nconst linearize = (v = 0) => {\n  let abs2 = Math.abs(v);\n  if (abs2 < β * 4.5) {\n    return v / 4.5;\n  }\n  return (Math.sign(v) || 1) * Math.pow((abs2 + α - 1) / α, 1 / 0.45);\n};\nconst convertRec2020ToXyz65 = (rec2020) => {\n  let r = linearize(rec2020.r);\n  let g = linearize(rec2020.g);\n  let b = linearize(rec2020.b);\n  let res = {\n    mode: \"xyz65\",\n    x: 0.6369580483012911 * r + 0.1446169035862083 * g + 0.1688809751641721 * b,\n    y: 0.262700212011267 * r + 0.6779980715188708 * g + 0.059301716469862 * b,\n    z: 0 * r + 0.0280726930490874 * g + 1.0609850577107909 * b\n  };\n  if (rec2020.alpha !== void 0) {\n    res.alpha = rec2020.alpha;\n  }\n  return res;\n};\nconst definition$4 = {\n  ...definition$r,\n  mode: \"rec2020\",\n  fromMode: {\n    xyz65: convertXyz65ToRec2020,\n    rgb: (color) => convertXyz65ToRec2020(convertRgbToXyz65(color))\n  },\n  toMode: {\n    xyz65: convertRec2020ToXyz65,\n    rgb: (color) => convertXyz65ToRgb(convertRec2020ToXyz65(color))\n  },\n  parse: [\"rec2020\"],\n  serialize: \"rec2020\"\n};\nconst bias = 0.0037930732552754493;\nconst bias_cbrt = Math.cbrt(bias);\nconst transfer$1 = (v) => Math.cbrt(v) - bias_cbrt;\nconst convertRgbToXyb = (color) => {\n  const { r, g, b, alpha } = convertRgbToLrgb(color);\n  const l = transfer$1(0.3 * r + 0.622 * g + 0.078 * b + bias);\n  const m = transfer$1(0.23 * r + 0.692 * g + 0.078 * b + bias);\n  const s = transfer$1(\n    0.2434226892454782 * r + 0.2047674442449682 * g + 0.5518098665095535 * b + bias\n  );\n  const res = {\n    mode: \"xyb\",\n    x: (l - m) / 2,\n    y: (l + m) / 2,\n    /* Apply default chroma from luma (subtract Y from B) */\n    b: s - (l + m) / 2\n  };\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst transfer = (v) => Math.pow(v + bias_cbrt, 3);\nconst convertXybToRgb = ({ x, y, b, alpha }) => {\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (b === void 0) b = 0;\n  const l = transfer(x + y) - bias;\n  const m = transfer(y - x) - bias;\n  const s = transfer(b + y) - bias;\n  const res = convertLrgbToRgb({\n    r: 11.031566904639861 * l - 9.866943908131562 * m - 0.16462299650829934 * s,\n    g: -3.2541473810744237 * l + 4.418770377582723 * m - 0.16462299650829934 * s,\n    b: -3.6588512867136815 * l + 2.7129230459360922 * m + 1.9459282407775895 * s\n  });\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst definition$3 = {\n  mode: \"xyb\",\n  channels: [\"x\", \"y\", \"b\", \"alpha\"],\n  parse: [\"--xyb\"],\n  serialize: \"--xyb\",\n  toMode: {\n    rgb: convertXybToRgb\n  },\n  fromMode: {\n    rgb: convertRgbToXyb\n  },\n  ranges: {\n    x: [-0.0154, 0.0281],\n    y: [0, 0.8453],\n    b: [-0.2778, 0.388]\n  },\n  interpolate: {\n    x: interpolatorLinear,\n    y: interpolatorLinear,\n    b: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nconst definition$2 = {\n  mode: \"xyz50\",\n  parse: [\"xyz-d50\"],\n  serialize: \"xyz-d50\",\n  toMode: {\n    rgb: convertXyz50ToRgb,\n    lab: convertXyz50ToLab\n  },\n  fromMode: {\n    rgb: convertRgbToXyz50,\n    lab: convertLabToXyz50\n  },\n  channels: [\"x\", \"y\", \"z\", \"alpha\"],\n  ranges: {\n    x: [0, 0.964],\n    y: [0, 0.999],\n    z: [0, 0.825]\n  },\n  interpolate: {\n    x: interpolatorLinear,\n    y: interpolatorLinear,\n    z: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nconst convertXyz65ToXyz50 = (xyz65) => {\n  let { x, y, z, alpha } = xyz65;\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = {\n    mode: \"xyz50\",\n    x: 1.0479298208405488 * x + 0.0229467933410191 * y - 0.0501922295431356 * z,\n    y: 0.0296278156881593 * x + 0.990434484573249 * y - 0.0170738250293851 * z,\n    z: -0.0092430581525912 * x + 0.0150551448965779 * y + 0.7518742899580008 * z\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst convertXyz50ToXyz65 = (xyz50) => {\n  let { x, y, z, alpha } = xyz50;\n  if (x === void 0) x = 0;\n  if (y === void 0) y = 0;\n  if (z === void 0) z = 0;\n  let res = {\n    mode: \"xyz65\",\n    x: 0.9554734527042182 * x - 0.0230985368742614 * y + 0.0632593086610217 * z,\n    y: -0.0283697069632081 * x + 1.0099954580058226 * y + 0.021041398966943 * z,\n    z: 0.0123140016883199 * x - 0.0205076964334779 * y + 1.3303659366080753 * z\n  };\n  if (alpha !== void 0) {\n    res.alpha = alpha;\n  }\n  return res;\n};\nconst definition$1 = {\n  mode: \"xyz65\",\n  toMode: {\n    rgb: convertXyz65ToRgb,\n    xyz50: convertXyz65ToXyz50\n  },\n  fromMode: {\n    rgb: convertRgbToXyz65,\n    xyz50: convertXyz50ToXyz65\n  },\n  ranges: {\n    x: [0, 0.95],\n    y: [0, 1],\n    z: [0, 1.088]\n  },\n  channels: [\"x\", \"y\", \"z\", \"alpha\"],\n  parse: [\"xyz\", \"xyz-d65\"],\n  serialize: \"xyz-d65\",\n  interpolate: {\n    x: interpolatorLinear,\n    y: interpolatorLinear,\n    z: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nconst convertRgbToYiq = ({ r, g, b, alpha }) => {\n  if (r === void 0) r = 0;\n  if (g === void 0) g = 0;\n  if (b === void 0) b = 0;\n  const res = {\n    mode: \"yiq\",\n    y: 0.29889531 * r + 0.58662247 * g + 0.11448223 * b,\n    i: 0.59597799 * r - 0.2741761 * g - 0.32180189 * b,\n    q: 0.21147017 * r - 0.52261711 * g + 0.31114694 * b\n  };\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst convertYiqToRgb = ({ y, i, q, alpha }) => {\n  if (y === void 0) y = 0;\n  if (i === void 0) i = 0;\n  if (q === void 0) q = 0;\n  const res = {\n    mode: \"rgb\",\n    r: y + 0.95608445 * i + 0.6208885 * q,\n    g: y - 0.27137664 * i - 0.6486059 * q,\n    b: y - 1.10561724 * i + 1.70250126 * q\n  };\n  if (alpha !== void 0) res.alpha = alpha;\n  return res;\n};\nconst definition = {\n  mode: \"yiq\",\n  toMode: {\n    rgb: convertYiqToRgb\n  },\n  fromMode: {\n    rgb: convertRgbToYiq\n  },\n  channels: [\"y\", \"i\", \"q\", \"alpha\"],\n  parse: [\"--yiq\"],\n  serialize: \"--yiq\",\n  ranges: {\n    i: [-0.595, 0.595],\n    q: [-0.522, 0.522]\n  },\n  interpolate: {\n    y: interpolatorLinear,\n    i: interpolatorLinear,\n    q: interpolatorLinear,\n    alpha: { use: interpolatorLinear, fixup: fixupAlpha }\n  }\n};\nuseMode(definition$q);\nuseMode(definition$p);\nuseMode(definition$o);\nuseMode(definition$n);\nuseMode(definition$m);\nuseMode(definition$l);\nuseMode(definition$k);\nuseMode(definition$j);\nuseMode(definition$i);\nuseMode(definition$h);\nuseMode(definition$g);\nuseMode(definition$f);\nuseMode(definition$e);\nuseMode(definition$d);\nuseMode(definition$c);\nuseMode(definition$b);\nuseMode(definition$a);\nuseMode(definition$9);\nuseMode(modeOkhsl);\nuseMode(modeOkhsv);\nuseMode(definition$8);\nuseMode(definition$7);\nuseMode(definition$6);\nuseMode(definition$5);\nuseMode(definition$4);\nuseMode(definition$r);\nuseMode(definition$3);\nuseMode(definition$2);\nuseMode(definition$1);\nuseMode(definition);\nvar EventDispatcherBase = class {\n  constructor() {\n    this.subscribable = new Subscribable(this);\n    this.subscribers = /* @__PURE__ */ new Set();\n  }\n  /**\n   * {@inheritDoc Subscribable.subscribe}\n   */\n  subscribe(handler) {\n    this.subscribers.add(handler);\n    return () => this.unsubscribe(handler);\n  }\n  /**\n   * {@inheritDoc Subscribable.unsubscribe}\n   */\n  unsubscribe(handler) {\n    this.subscribers.delete(handler);\n  }\n  /**\n   * Unsubscribe all subscribers from the event.\n   */\n  clear() {\n    this.subscribers.clear();\n  }\n  notifySubscribers(value) {\n    return [...this.subscribers].map((handler) => handler(value));\n  }\n};\nvar Subscribable = class {\n  constructor(dispatcher) {\n    this.dispatcher = dispatcher;\n  }\n  /**\n   * Subscribe to the event.\n   *\n   * @param handler - The handler to invoke when the event occurs.\n   *\n   * @returns A callback function that cancels the subscription.\n   */\n  subscribe(handler) {\n    return this.dispatcher.subscribe(handler);\n  }\n  /**\n   * Unsubscribe from the event.\n   *\n   * @param handler - The handler to unsubscribe.\n   */\n  unsubscribe(handler) {\n    this.dispatcher.unsubscribe(handler);\n  }\n};\nvar AsyncEventDispatcher = class extends EventDispatcherBase {\n  async dispatch(value) {\n    await Promise.all(this.notifySubscribers(value));\n  }\n};\nvar EventDispatcher = class extends EventDispatcherBase {\n  dispatch(value) {\n    this.notifySubscribers(value);\n  }\n};\nvar FlagDispatcher = class extends EventDispatcherBase {\n  constructor() {\n    super(...arguments);\n    this.value = false;\n  }\n  /**\n   * Notify all current and future subscribers.\n   */\n  raise() {\n    if (!this.value) {\n      this.value = true;\n      this.notifySubscribers();\n    }\n  }\n  /**\n   * Stop notifying future subscribers.\n   */\n  reset() {\n    this.value = false;\n  }\n  /**\n   * Are subscribers being notified?\n   */\n  isRaised() {\n    return this.value;\n  }\n  subscribe(handler) {\n    const unsubscribe = super.subscribe(handler);\n    if (this.value) {\n      handler();\n    }\n    return unsubscribe;\n  }\n};\nvar ValueDispatcher = class extends EventDispatcherBase {\n  /**\n   * @param value - The initial value.\n   */\n  constructor(value) {\n    super();\n    this.value = value;\n    this.subscribable = new SubscribableValueEvent(this);\n  }\n  /**\n   * {@inheritDoc SubscribableValueEvent.current}\n   */\n  get current() {\n    return this.value;\n  }\n  /**\n   * Set the current value of this dispatcher.\n   *\n   * @remarks\n   * Setting the value will immediately notify all subscribers.\n   *\n   * @param value - The new value.\n   */\n  set current(value) {\n    this.value = value;\n    this.notifySubscribers(value);\n  }\n  /**\n   * {@inheritDoc SubscribableValueEvent.subscribe}\n   */\n  subscribe(handler, dispatchImmediately = true) {\n    const unsubscribe = super.subscribe(handler);\n    if (dispatchImmediately) {\n      handler(this.value);\n    }\n    return unsubscribe;\n  }\n};\nvar SubscribableValueEvent = class extends Subscribable {\n  /**\n   * Get the most recent value of this dispatcher.\n   */\n  get current() {\n    return this.dispatcher.current;\n  }\n  /**\n   * Subscribe to the event.\n   *\n   * Subscribing will immediately invoke the handler with the most recent value.\n   *\n   * @param handler - The handler to invoke when the event occurs.\n   * @param dispatchImmediately - Whether the handler should be immediately\n   *                              invoked with the most recent value.\n   *\n   * @returns Callback function that cancels the subscription.\n   */\n  subscribe(handler, dispatchImmediately = true) {\n    return this.dispatcher.subscribe(\n      handler,\n      dispatchImmediately\n    );\n  }\n};\nnew EventDispatcher();\nfunction map(from, to, value) {\n  return from + (to - from) * value;\n}\nfunction clamp(min, max, value) {\n  return value < min ? min : value > max ? max : value;\n}\nvar SceneStack = [];\nfunction useLogger() {\n  var _a;\n  return ((_a = SceneStack.at(-1)) == null ? void 0 : _a.logger) ?? console;\n}\nvar DetailedError = class extends Error {\n  constructor(props, remarks) {\n    if (typeof props === \"string\") {\n      super(props);\n      this.remarks = remarks;\n    } else {\n      super(props.message);\n      this.remarks = props.remarks;\n      this.object = props.object;\n      this.durationMs = props.durationMs;\n      this.inspect = props.inspect;\n    }\n  }\n};\nvar ThreadStack = [];\nfunction useThread() {\n  const thread = ThreadStack.at(-1);\n  if (!thread) {\n    throw new DetailedError(\n      \"The thread is not available in the current context.\",\n      // language=markdown\n      `\\`useThread()\\` can only be called from within generator functions.\n      It's not available during rendering.`\n    );\n  }\n  return thread;\n}\nfunction startThread(thread) {\n  ThreadStack.push(thread);\n}\nfunction endThread(thread) {\n  if (ThreadStack.pop() !== thread) {\n    throw new Error(\"startThread/endThread was called out of order.\");\n  }\n}\nfunction errorToLog(error) {\n  return {\n    message: error.message,\n    stack: error.stack,\n    remarks: error.remarks\n  };\n}\nfunction getContext(options, canvas = document.createElement(\"canvas\")) {\n  const context = canvas.getContext(\"2d\", options);\n  if (!context) {\n    throw new Error(\"Could not create a 2D context.\");\n  }\n  return context;\n}\nvar RAD2DEG = 180 / Math.PI;\nvar DEG2RAD = Math.PI / 180;\nvar Semaphore = class {\n  constructor() {\n    this.resolveCurrent = null;\n    this.current = null;\n  }\n  async acquire() {\n    while (this.current) {\n      await this.current;\n    }\n    this.current = new Promise((resolve) => {\n      this.resolveCurrent = resolve;\n    });\n  }\n  release() {\n    var _a;\n    this.current = null;\n    (_a = this.resolveCurrent) == null ? void 0 : _a.call(this);\n    this.resolveCurrent = null;\n  }\n};\nvar PlaybackStack = [];\nfunction usePlayback() {\n  const playback = PlaybackStack.at(-1);\n  if (!playback) {\n    throw new Error(\"The playback is not available in the current context.\");\n  }\n  return playback;\n}\nfunction textLerp(from, to, value) {\n  if (to.length >= from.length) {\n    const current = Math.floor(to.length * value);\n    const currentLength = Math.floor(map(from.length - 1, to.length, value));\n    let text = \"\";\n    for (let i = 0; i < to.length; i++) {\n      if (i < current) {\n        text += to[i];\n      } else if (from[i] || i <= currentLength) {\n        text += from[i] ?? to[i];\n      }\n    }\n    return text;\n  } else {\n    const current = Math.round(from.length * (1 - value));\n    const currentLength = Math.floor(map(from.length + 1, to.length, value));\n    const text = [];\n    for (let i = from.length - 1; i >= 0; i--) {\n      if (i < current) {\n        text.unshift(from[i]);\n      } else if (to[i] || i < currentLength) {\n        text.unshift(to[i] ?? from[i]);\n      }\n    }\n    return text.join(\"\");\n  }\n}\nfunction deepLerp(from, to, value, suppressWarnings = false) {\n  if (value === 0) return from;\n  if (value === 1) return to;\n  if (from == null || to == null) {\n    if (!suppressWarnings) {\n      useLogger().warn(\n        `Attempting to lerp ${from} -> ${to} may result in unexpected behavior.`\n      );\n    }\n    return void 0;\n  }\n  if (typeof from === \"number\" && typeof to === \"number\") {\n    return map(from, to, value);\n  }\n  if (typeof from === \"string\" && typeof to === \"string\") {\n    return textLerp(from, to, value);\n  }\n  if (typeof from === \"boolean\" && typeof to === \"boolean\") {\n    return value < 0.5 ? from : to;\n  }\n  if (\"lerp\" in from) {\n    return from.lerp(to, value);\n  }\n  if (from && to && typeof from === \"object\" && typeof to === \"object\") {\n    if (Array.isArray(from) && Array.isArray(to)) {\n      if (from.length === to.length) {\n        return from.map((f2, i) => deepLerp(f2, to[i], value));\n      }\n    } else {\n      let toObject = false;\n      if (!(from instanceof Map) && !(to instanceof Map)) {\n        toObject = true;\n        from = new Map(Object.entries(from));\n        to = new Map(Object.entries(to));\n      }\n      if (from instanceof Map && to instanceof Map) {\n        const result = /* @__PURE__ */ new Map();\n        for (const key of /* @__PURE__ */ new Set([...from.keys(), ...to.keys()])) {\n          const inter = deepLerp(from.get(key), to.get(key), value, true);\n          if (inter !== void 0) result.set(key, inter);\n        }\n        return toObject ? Object.fromEntries(result) : result;\n      }\n    }\n  }\n  return to;\n}\nfunction arcLerp(value, reverse, ratio) {\n  let flip = reverse;\n  if (ratio > 1) {\n    ratio = 1 / ratio;\n  } else {\n    flip = !flip;\n  }\n  const normalized = flip ? Math.acos(clamp(-1, 1, 1 - value)) : Math.asin(value);\n  const radians = map(normalized, map(0, Math.PI / 2, value), ratio);\n  let xValue = Math.sin(radians);\n  let yValue = 1 - Math.cos(radians);\n  if (reverse) {\n    [xValue, yValue] = [yValue, xValue];\n  }\n  return { x: xValue, y: yValue };\n}\nfunction decorate(fn2, ...decorators) {\n  const target = { [fn2.name]: fn2 };\n  const descriptor = Object.getOwnPropertyDescriptor(target, fn2.name);\n  if (descriptor) {\n    for (let i = decorators.length - 1; i >= 0; i--) {\n      decorators[i](target, fn2.name, descriptor);\n    }\n  }\n}\nfunction threadable(customName) {\n  return function(_, propertyKey, descriptor) {\n    const value = descriptor == null ? void 0 : descriptor.value;\n    if (typeof value === \"function\" && value.prototype) {\n      const prototype = value.prototype;\n      try {\n        const nameDescriptor = Object.getOwnPropertyDescriptor(\n          prototype,\n          \"name\"\n        );\n        if (!nameDescriptor || nameDescriptor.writable) {\n          prototype.name = customName ?? propertyKey;\n        }\n      } catch {\n      }\n      prototype.threadable = true;\n    }\n  };\n}\ndecorate(spring, threadable());\nfunction* spring(spring2, from, to, settleToleranceOrOnProgress, onProgressOrOnEnd, onEnd) {\n  const settleTolerance = typeof settleToleranceOrOnProgress === \"number\" ? settleToleranceOrOnProgress : 1e-3;\n  onEnd = typeof settleToleranceOrOnProgress === \"number\" ? onEnd : onProgressOrOnEnd;\n  const onProgress = (value, time) => {\n    if (typeof settleToleranceOrOnProgress === \"function\") {\n      settleToleranceOrOnProgress(value, time);\n    } else if (typeof onProgressOrOnEnd === \"function\") {\n      onProgressOrOnEnd(value, time);\n    }\n  };\n  spring2 = spring2 ?? {\n    mass: 0.05,\n    stiffness: 10,\n    damping: 0.5\n  };\n  if (spring2.mass <= 0) {\n    useLogger().error(new Error(\"Spring mass must be greater than 0.\"));\n    return;\n  }\n  if (spring2.stiffness < 0) {\n    useLogger().error(\n      new Error(\"Spring stiffness must be greater or equal to 0.\")\n    );\n    return;\n  }\n  if (spring2.damping < 0) {\n    useLogger().error(\n      new Error(\"Spring damping must be greater or equal to 0.\")\n    );\n    return;\n  }\n  const thread = useThread();\n  let position = from;\n  let velocity = spring2.initialVelocity ?? 0;\n  const update = (dt) => {\n    if (spring2 === null) {\n      return;\n    }\n    const positionDelta = position - to;\n    const force = -spring2.stiffness * positionDelta - spring2.damping * velocity;\n    velocity += force / spring2.mass * dt;\n    position += velocity * dt;\n  };\n  const simulationFrames = 120;\n  const timeStep = 1 / simulationFrames;\n  onProgress(from, 0);\n  const startTime = thread.time();\n  let simulationTime = startTime;\n  let settled = false;\n  while (!settled) {\n    while (simulationTime < thread.fixed) {\n      const difference = thread.fixed - simulationTime;\n      if (timeStep > difference) {\n        update(difference);\n        simulationTime = thread.fixed;\n      } else {\n        update(timeStep);\n        simulationTime += timeStep;\n      }\n      if (Math.abs(to - position) < settleTolerance && Math.abs(velocity) < settleTolerance) {\n        thread.time(simulationTime);\n        settled = true;\n        break;\n      }\n    }\n    if (!settled) {\n      onProgress(position, thread.fixed - startTime);\n      yield;\n    }\n  }\n  onProgress(to, thread.fixed - startTime);\n  onEnd == null ? void 0 : onEnd(to, thread.fixed - startTime);\n}\nfunction easeInOutCubic(value, from = 0, to = 1) {\n  value = value < 0.5 ? 4 * value * value * value : 1 - Math.pow(-2 * value + 2, 3) / 2;\n  return map(from, to, value);\n}\ndecorate(tween, threadable());\nfunction* tween(seconds, onProgress, onEnd) {\n  const thread = useThread();\n  const startTime = thread.time();\n  const endTime = thread.time() + seconds;\n  onProgress(0, 0);\n  while (endTime > thread.fixed) {\n    const time = thread.fixed - startTime;\n    const value = time / seconds;\n    if (time > 0) {\n      onProgress(value, time);\n    }\n    yield;\n  }\n  thread.time(endTime);\n  onProgress(1, seconds);\n  onEnd == null ? void 0 : onEnd(1, seconds);\n}\nnew EventDispatcher();\ndecorate(join, threadable());\nfunction* join(first, ...tasks) {\n  let all2 = true;\n  if (typeof first === \"boolean\") {\n    all2 = first;\n  } else {\n    tasks.push(first);\n  }\n  const parent = useThread();\n  const threads2 = tasks.map((task) => parent.children.find((thread) => thread.runner === task)).filter((thread) => thread);\n  const startTime = parent.time();\n  let childTime;\n  if (all2) {\n    while (threads2.find((thread) => !thread.canceled)) {\n      yield;\n    }\n    childTime = Math.max(...threads2.map((thread) => thread.time()));\n  } else {\n    while (!threads2.find((thread) => thread.canceled)) {\n      yield;\n    }\n    const canceled = threads2.filter((thread) => thread.canceled);\n    childTime = Math.min(...canceled.map((thread) => thread.time()));\n  }\n  parent.time(Math.max(startTime, childTime));\n}\ndecorate(all, threadable());\nfunction* all(...tasks) {\n  for (const task of tasks) {\n    yield task;\n  }\n  yield* join(...tasks);\n}\ndecorate(any, threadable());\nfunction* any(...tasks) {\n  for (const task of tasks) {\n    yield task;\n  }\n  yield* join(false, ...tasks);\n}\ndecorate(chain, threadable());\nfunction* chain(...tasks) {\n  for (const generator of tasks) {\n    if (\"next\" in generator) {\n      yield* generator;\n    } else {\n      generator();\n    }\n  }\n}\ndecorate(waitFor, threadable());\nfunction* waitFor(seconds = 0, after) {\n  const thread = useThread();\n  const step = usePlayback().framesToSeconds(1);\n  const targetTime = thread.time() + seconds;\n  while (targetTime - step > thread.fixed) {\n    yield;\n  }\n  thread.time(targetTime);\n  if (after) {\n    yield* after;\n  }\n}\ndecorate(delay, threadable());\nfunction* delay(time, task) {\n  yield* waitFor(time);\n  if (\"next\" in task) {\n    yield* task;\n  } else {\n    task();\n  }\n}\nvar infiniteLoop = `\nMake sure to use \\`yield\\` or \\`spawn()\\` to execute the loop concurrently in a\nseparate thread:\n\n\\`\\`\\`ts wrong\n// prettier-ignore\nyield* loop(() => rect().opacity(0).opacity(1, 1));\n\\`\\`\\`\n\n\\`\\`\\`ts correct\nyield loop(() => rect().opacity(0).opacity(1, 1));\n// or\nspawn(loop(() => rect().opacity(0).opacity(1, 1)));\n\\`\\`\\`\n\nIf you want to execute the loop a finite number of times, specify the iteration\ncount as the first argument:\n\n\\`\\`\\`ts\n// prettier-ignore\nyield* loop(10, () => rect().opacity(0).opacity(1, 1));\n//          ^ iteration count\n\\`\\`\\`\n`;\ndecorate(loop, threadable());\nfunction* loop(iterations, factory) {\n  if (typeof iterations !== \"number\") {\n    factory = iterations;\n    iterations = Infinity;\n  }\n  if (iterations === Infinity && useThread().parent === null) {\n    useLogger().error({\n      message: \"Tried to execute an infinite loop in the main thread.\",\n      remarks: infiniteLoop,\n      stack: new Error().stack\n    });\n    return;\n  }\n  for (let i = 0; i < iterations; i++) {\n    const generator = factory(i);\n    if (generator) {\n      yield* generator;\n    } else {\n      yield;\n    }\n  }\n}\ndecorate(loopFor, threadable());\nfunction* loopFor(seconds, factory) {\n  const thread = useThread();\n  const step = usePlayback().framesToSeconds(1);\n  const targetTime = thread.time() + seconds;\n  let iteration = 0;\n  while (targetTime - step > thread.fixed) {\n    const generator = factory(iteration);\n    if (generator) {\n      yield* generator;\n    } else {\n      yield;\n    }\n    iteration += 1;\n  }\n  thread.time(targetTime);\n}\nfunction setTaskName(task, source) {\n  const prototype = Object.getPrototypeOf(task);\n  if (prototype && !prototype.threadable) {\n    prototype.threadable = true;\n    try {\n      const resolvedName = typeof source === \"string\" ? source : getTaskName(source);\n      const nameDescriptor = Object.getOwnPropertyDescriptor(\n        prototype,\n        \"name\"\n      );\n      if (!nameDescriptor || nameDescriptor.writable) {\n        prototype.name = resolvedName;\n      }\n    } catch {\n    }\n  }\n}\nfunction getTaskName(task) {\n  return Object.getPrototypeOf(task).name ?? null;\n}\nfunction run(firstArg, runner) {\n  let task;\n  if (typeof firstArg === \"string\") {\n    task = runner();\n    setTaskName(task, firstArg);\n  } else {\n    task = firstArg();\n    setTaskName(task, task);\n  }\n  return task;\n}\ndecorate(sequence, threadable());\nfunction* sequence(delay2, ...tasks) {\n  for (const task of tasks) {\n    yield task;\n    yield* waitFor(delay2);\n  }\n  yield* join(...tasks);\n}\nvar _DependencyContext = class _DependencyContext2 {\n  constructor(owner) {\n    this.owner = owner;\n    this.dependencies = /* @__PURE__ */ new Set();\n    this.event = new FlagDispatcher();\n    this.markDirty = () => this.event.raise();\n    this.invokable = this.invoke.bind(this);\n    Object.defineProperty(this.invokable, \"context\", {\n      value: this\n    });\n    Object.defineProperty(this.invokable, \"toPromise\", {\n      value: this.toPromise.bind(this)\n    });\n  }\n  static collectPromise(promise, initialValue = null) {\n    const handle = {\n      promise,\n      value: initialValue,\n      stack: new Error().stack\n    };\n    const context = this.collectionStack.at(-1);\n    if (context) {\n      handle.owner = context.owner;\n    }\n    promise.then((value) => {\n      handle.value = value;\n      context == null ? void 0 : context.markDirty();\n    });\n    this.promises.push(handle);\n    return handle;\n  }\n  static hasPromises() {\n    return this.promises.length > 0;\n  }\n  static async consumePromises() {\n    const promises = [...this.promises];\n    await Promise.all(promises.map((handle) => handle.promise));\n    this.promises = this.promises.filter((v) => !promises.includes(v));\n    return promises;\n  }\n  invoke() {\n  }\n  startCollecting() {\n    if (_DependencyContext2.collectionSet.has(this)) {\n      throw new DetailedError(\n        \"A circular dependency occurred between signals.\",\n        `This can happen when signals reference each other in a loop.\n        Try using the attached stack trace to locate said loop.`\n      );\n    }\n    _DependencyContext2.collectionSet.add(this);\n    _DependencyContext2.collectionStack.push(this);\n  }\n  finishCollecting() {\n    _DependencyContext2.collectionSet.delete(this);\n    if (_DependencyContext2.collectionStack.pop() !== this) {\n      throw new Error(\"collectStart/collectEnd was called out of order.\");\n    }\n  }\n  clearDependencies() {\n    this.dependencies.forEach((dep) => dep.unsubscribe(this.markDirty));\n    this.dependencies.clear();\n  }\n  collect() {\n    const signal = _DependencyContext2.collectionStack.at(-1);\n    if (signal) {\n      signal.dependencies.add(this.event.subscribable);\n      this.event.subscribe(signal.markDirty);\n    }\n  }\n  dispose() {\n    this.clearDependencies();\n    this.event.clear();\n    this.owner = null;\n  }\n  async toPromise() {\n    do {\n      await _DependencyContext2.consumePromises();\n      this.invokable();\n    } while (_DependencyContext2.hasPromises());\n    return this.invokable;\n  }\n};\n_DependencyContext.collectionSet = /* @__PURE__ */ new Set();\n_DependencyContext.collectionStack = [];\n_DependencyContext.promises = [];\nvar DependencyContext = _DependencyContext;\nvar DEFAULT = /* @__PURE__ */ Symbol.for(\"@twick/core/signals/default\");\nfunction isReactive(value) {\n  return typeof value === \"function\";\n}\nfunction modify(value, modification) {\n  return isReactive(value) ? () => modification(value()) : modification(value);\n}\nfunction unwrap(value) {\n  return isReactive(value) ? value() : value;\n}\nvar SignalContext = class extends DependencyContext {\n  constructor(initial, interpolation, owner = void 0, parser = (value) => value, extensions = {}) {\n    super(owner);\n    this.initial = initial;\n    this.interpolation = interpolation;\n    this.parser = parser;\n    this.tweening = false;\n    Object.defineProperty(this.invokable, \"reset\", {\n      value: this.reset.bind(this)\n    });\n    Object.defineProperty(this.invokable, \"save\", {\n      value: this.save.bind(this)\n    });\n    Object.defineProperty(this.invokable, \"isInitial\", {\n      value: this.isInitial.bind(this)\n    });\n    if (this.initial !== void 0) {\n      this.current = this.initial;\n      this.markDirty();\n      if (!isReactive(this.initial)) {\n        this.last = this.parse(this.initial);\n      }\n    }\n    this.extensions = {\n      getter: this.getter.bind(this),\n      setter: this.setter.bind(this),\n      tweener: this.tweener.bind(this),\n      ...extensions\n    };\n  }\n  toSignal() {\n    return this.invokable;\n  }\n  parse(value) {\n    return this.parser(value);\n  }\n  set(value) {\n    this.extensions.setter(value);\n    return this.owner;\n  }\n  setter(value) {\n    if (value === DEFAULT) {\n      value = this.initial;\n    }\n    if (this.current === value) {\n      return this.owner;\n    }\n    this.current = value;\n    this.markDirty();\n    this.clearDependencies();\n    if (!isReactive(value)) {\n      this.last = this.parse(value);\n    }\n    return this.owner;\n  }\n  get() {\n    return this.extensions.getter();\n  }\n  getter() {\n    var _a;\n    if (this.event.isRaised() && isReactive(this.current)) {\n      this.clearDependencies();\n      this.startCollecting();\n      try {\n        this.last = this.parse(this.current());\n      } catch (e2) {\n        useLogger().error({\n          ...errorToLog(e2),\n          inspect: (_a = this.owner) == null ? void 0 : _a.key\n        });\n      }\n      this.finishCollecting();\n    }\n    this.event.reset();\n    this.collect();\n    return this.last;\n  }\n  invoke(value, duration, timingFunction = easeInOutCubic, interpolationFunction = this.interpolation) {\n    if (value === void 0) {\n      return this.get();\n    }\n    if (duration === void 0) {\n      return this.set(value);\n    }\n    const queue = this.createQueue(timingFunction, interpolationFunction);\n    return queue.to(value, duration);\n  }\n  createQueue(defaultTimingFunction, defaultInterpolationFunction) {\n    const initial = this.get();\n    const queue = [];\n    const task = run(\"animation chain\", function* animate() {\n      while (queue.length > 0) {\n        yield* queue.shift();\n      }\n    });\n    task.to = (value, duration, timingFunction = defaultTimingFunction, interpolationFunction = defaultInterpolationFunction) => {\n      defaultTimingFunction = timingFunction;\n      defaultInterpolationFunction = interpolationFunction;\n      queue.push(\n        this.tween(value, duration, timingFunction, interpolationFunction)\n      );\n      return task;\n    };\n    task.back = (time, timingFunction = defaultTimingFunction, interpolationFunction = defaultInterpolationFunction) => {\n      defaultTimingFunction = timingFunction;\n      defaultInterpolationFunction = interpolationFunction;\n      queue.push(\n        this.tween(\n          initial,\n          time,\n          defaultTimingFunction,\n          defaultInterpolationFunction\n        )\n      );\n      return task;\n    };\n    task.wait = (duration) => {\n      queue.push(waitFor(duration));\n      return task;\n    };\n    task.run = (generator) => {\n      queue.push(generator);\n      return task;\n    };\n    task.do = (callback) => {\n      queue.push(\n        run(function* () {\n          callback();\n        })\n      );\n      return task;\n    };\n    return task;\n  }\n  *tween(value, duration, timingFunction, interpolationFunction) {\n    if (value === DEFAULT) {\n      value = this.initial;\n    }\n    this.tweening = true;\n    yield* this.extensions.tweener(\n      value,\n      duration,\n      timingFunction,\n      interpolationFunction\n    );\n    this.set(value);\n    this.tweening = false;\n  }\n  *tweener(value, duration, timingFunction, interpolationFunction) {\n    const from = this.get();\n    yield* tween(duration, (v) => {\n      this.set(\n        interpolationFunction(\n          from,\n          this.parse(unwrap(value)),\n          timingFunction(v)\n        )\n      );\n    });\n  }\n  dispose() {\n    super.dispose();\n    this.initial = void 0;\n    this.current = void 0;\n    this.last = void 0;\n  }\n  /**\n   * Reset the signal to its initial value (if one has been set).\n   *\n   * @example\n   * ```ts\n   * const signal = createSignal(7);\n   *\n   * signal.reset();\n   * // same as:\n   * signal(7);\n   * ```\n   */\n  reset() {\n    if (this.initial !== void 0) {\n      this.set(this.initial);\n    }\n    return this.owner;\n  }\n  /**\n   * Compute the current value of the signal and immediately set it.\n   *\n   * @remarks\n   * This method can be used to stop the signal from updating while keeping its\n   * current value.\n   *\n   * @example\n   * ```ts\n   * signal.save();\n   * // same as:\n   * signal(signal());\n   * ```\n   */\n  save() {\n    return this.set(this.get());\n  }\n  /**\n   * Check if the signal is currently using its initial value.\n   *\n   * @example\n   * ```ts\n   *\n   * const signal = createSignal(0);\n   * signal.isInitial(); // true\n   *\n   * signal(5);\n   * signal.isInitial(); // false\n   *\n   * signal(DEFAULT);\n   * signal.isInitial(); // true\n   * ```\n   */\n  isInitial() {\n    this.collect();\n    return this.current === this.initial;\n  }\n  /**\n   * Get the initial value of this signal.\n   */\n  getInitial() {\n    return this.initial;\n  }\n  /**\n   * Get the raw value of this signal.\n   *\n   * @remarks\n   * If the signal was provided with a factory function, the function itself\n   * will be returned, without invoking it.\n   *\n   * This method can be used to create copies of signals.\n   *\n   * @example\n   * ```ts\n   * const a = createSignal(2);\n   * const b = createSignal(() => a);\n   * // b() == 2\n   *\n   * const bClone = createSignal(b.raw());\n   * // bClone() == 2\n   *\n   * a(4);\n   * // b() == 4\n   * // bClone() == 4\n   * ```\n   */\n  raw() {\n    return this.current;\n  }\n  /**\n   * Is the signal undergoing a tween?\n   */\n  isTweening() {\n    return this.tweening;\n  }\n};\nvar CompoundSignalContext = class extends SignalContext {\n  constructor(entries, parser, initial, interpolation, owner = void 0, extensions = {}) {\n    var _a;\n    super(void 0, interpolation, owner, parser, extensions);\n    this.entries = entries;\n    this.signals = [];\n    this.parser = parser;\n    for (const entry of entries) {\n      let key;\n      let signal;\n      if (Array.isArray(entry)) {\n        [key, signal] = entry;\n        (_a = signal.context).owner ?? (_a.owner = this);\n      } else {\n        key = entry;\n        signal = new SignalContext(\n          modify(initial, (value) => parser(value)[entry]),\n          map,\n          owner ?? this.invokable\n        ).toSignal();\n      }\n      this.signals.push([key, signal]);\n      Object.defineProperty(this.invokable, key, { value: signal });\n    }\n  }\n  toSignal() {\n    return this.invokable;\n  }\n  parse(value) {\n    return this.parser(value);\n  }\n  getter() {\n    return this.parse(\n      Object.fromEntries(\n        this.signals.map(([key, property]) => [key, property()])\n      )\n    );\n  }\n  setter(value) {\n    if (isReactive(value)) {\n      for (const [key, property] of this.signals) {\n        property(() => this.parser(value())[key]);\n      }\n    } else {\n      const parsed = this.parse(value);\n      for (const [key, property] of this.signals) {\n        property(parsed[key]);\n      }\n    }\n    return this.owner;\n  }\n  reset() {\n    for (const [, signal] of this.signals) {\n      signal.reset();\n    }\n    return this.owner;\n  }\n  save() {\n    for (const [, signal] of this.signals) {\n      signal.save();\n    }\n    return this.owner;\n  }\n  isInitial() {\n    for (const [, signal] of this.signals) {\n      if (!signal.isInitial()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  raw() {\n    return Object.fromEntries(\n      this.signals.map(([key, property]) => [key, property.context.raw()])\n    );\n  }\n};\nfunction createSignal(initial, interpolation = deepLerp, owner) {\n  return new SignalContext(\n    initial,\n    interpolation,\n    owner\n  ).toSignal();\n}\nvar EPSILON = 1e-6;\nvar _Vector2 = class _Vector22 {\n  constructor(one, two) {\n    this.x = 0;\n    this.y = 0;\n    if (one === void 0 || one === null) {\n      return;\n    }\n    if (typeof one !== \"object\") {\n      this.x = one;\n      this.y = two ?? one;\n      return;\n    }\n    if (Array.isArray(one)) {\n      this.x = one[0];\n      this.y = one[1];\n      return;\n    }\n    if (\"width\" in one) {\n      this.x = one.width;\n      this.y = one.height;\n      return;\n    }\n    this.x = one.x;\n    this.y = one.y;\n  }\n  static createSignal(initial, interpolation = _Vector22.lerp, owner) {\n    return new CompoundSignalContext(\n      [\"x\", \"y\"],\n      (value) => new _Vector22(value),\n      initial,\n      interpolation,\n      owner\n    ).toSignal();\n  }\n  static lerp(from, to, value) {\n    let valueX;\n    let valueY;\n    if (typeof value === \"number\") {\n      valueX = valueY = value;\n    } else {\n      valueX = value.x;\n      valueY = value.y;\n    }\n    return new _Vector22(map(from.x, to.x, valueX), map(from.y, to.y, valueY));\n  }\n  static arcLerp(from, to, value, reverse = false, ratio) {\n    ratio ?? (ratio = from.sub(to).ctg);\n    return _Vector22.lerp(from, to, new _Vector22(arcLerp(value, reverse, ratio)));\n  }\n  static createArcLerp(reverse, ratio) {\n    return (from, to, value) => _Vector22.arcLerp(from, to, value, reverse, ratio);\n  }\n  /**\n   * Interpolates between two vectors on the polar plane by interpolating\n   * the angles and magnitudes of the vectors individually.\n   *\n   * @param from - The starting vector.\n   * @param to - The target vector.\n   * @param value - The t-value of the interpolation.\n   * @param counterclockwise - Whether the vector should get rotated\n   *                           counterclockwise. Defaults to `false`.\n   * @param origin - The center of rotation. Defaults to the origin.\n   *\n   * @remarks\n   * This function is useful when used in conjunction with {@link rotate} to\n   * animate an object's position on a circular arc (see examples).\n   *\n   * @example\n   * Animating an object in a circle around the origin\n   * ```tsx\n   * circle().position(\n   *   circle().position().rotate(180),\n   *   1,\n   *   easeInOutCubic,\n   *   Vector2.polarLerp\n   * );\n   * ```\n   * @example\n   * Rotating an object around the point `[-200, 100]`\n   * ```ts\n   * circle().position(\n   *   circle().position().rotate(180, [-200, 100]),\n   *   1,\n   *   easeInOutCubic,\n   *   Vector2.createPolarLerp(false, [-200, 100]),\n   * );\n   * ```\n   * @example\n   * Rotating an object counterclockwise around the origin\n   * ```ts\n   * circle().position(\n   *   circle().position().rotate(180),\n   *   1,\n   *   easeInOutCubic,\n   *   Vector2.createPolarLerp(true),\n   * );\n   * ```\n   */\n  static polarLerp(from, to, value, counterclockwise = false, origin = _Vector22.zero) {\n    from = from.sub(origin);\n    to = to.sub(origin);\n    const fromAngle = from.degrees;\n    let toAngle = to.degrees;\n    const isCounterclockwise = fromAngle > toAngle;\n    if (isCounterclockwise !== counterclockwise) {\n      toAngle = toAngle + (counterclockwise ? -360 : 360);\n    }\n    const angle = map(fromAngle, toAngle, value) * DEG2RAD;\n    const magnitude = map(from.magnitude, to.magnitude, value);\n    return new _Vector22(\n      magnitude * Math.cos(angle) + origin.x,\n      magnitude * Math.sin(angle) + origin.y\n    );\n  }\n  /**\n   * Helper function to create a {@link Vector2.polarLerp} interpolation\n   * function with additional parameters.\n   *\n   * @param counterclockwise - Whether the point should get rotated\n   *                           counterclockwise.\n   * @param center - The center of rotation. Defaults to the origin.\n   */\n  static createPolarLerp(counterclockwise = false, center = _Vector22.zero) {\n    return (from, to, value) => _Vector22.polarLerp(from, to, value, counterclockwise, new _Vector22(center));\n  }\n  static fromOrigin(origin) {\n    const position = new _Vector22();\n    if (origin === 3) {\n      return position;\n    }\n    if (origin & 16) {\n      position.x = -1;\n    } else if (origin & 32) {\n      position.x = 1;\n    }\n    if (origin & 4) {\n      position.y = -1;\n    } else if (origin & 8) {\n      position.y = 1;\n    }\n    return position;\n  }\n  static fromScalar(value) {\n    return new _Vector22(value, value);\n  }\n  static fromRadians(radians) {\n    return new _Vector22(Math.cos(radians), Math.sin(radians));\n  }\n  static fromDegrees(degrees) {\n    return _Vector22.fromRadians(degrees * DEG2RAD);\n  }\n  /**\n   * Return the angle in radians between the vector described by x and y and the\n   * positive x-axis.\n   *\n   * @param x - The x component of the vector.\n   * @param y - The y component of the vector.\n   */\n  static radians(x, y) {\n    return Math.atan2(y, x);\n  }\n  /**\n   * Return the angle in degrees between the vector described by x and y and the\n   * positive x-axis.\n   *\n   * @param x - The x component of the vector.\n   * @param y - The y component of the vector.\n   *\n   * @remarks\n   * The returned angle will be between -180 and 180 degrees.\n   */\n  static degrees(x, y) {\n    return _Vector22.radians(x, y) * RAD2DEG;\n  }\n  static magnitude(x, y) {\n    return Math.sqrt(x * x + y * y);\n  }\n  static squaredMagnitude(x, y) {\n    return x * x + y * y;\n  }\n  static angleBetween(u, v) {\n    return Math.acos(clamp(-1, 1, u.dot(v) / (u.magnitude * v.magnitude))) * (u.cross(v) >= 0 ? 1 : -1);\n  }\n  get width() {\n    return this.x;\n  }\n  set width(value) {\n    this.x = value;\n  }\n  get height() {\n    return this.y;\n  }\n  set height(value) {\n    this.y = value;\n  }\n  get magnitude() {\n    return _Vector22.magnitude(this.x, this.y);\n  }\n  get squaredMagnitude() {\n    return _Vector22.squaredMagnitude(this.x, this.y);\n  }\n  get normalized() {\n    return this.scale(1 / _Vector22.magnitude(this.x, this.y));\n  }\n  get safe() {\n    return new _Vector22(isNaN(this.x) ? 0 : this.x, isNaN(this.y) ? 0 : this.y);\n  }\n  get flipped() {\n    return new _Vector22(-this.x, -this.y);\n  }\n  get floored() {\n    return new _Vector22(Math.floor(this.x), Math.floor(this.y));\n  }\n  get perpendicular() {\n    return new _Vector22(this.y, -this.x);\n  }\n  /**\n   * Return the angle in radians between the vector and the positive x-axis.\n   */\n  get radians() {\n    return _Vector22.radians(this.x, this.y);\n  }\n  /**\n   * Return the angle in degrees between the vector and the positive x-axis.\n   *\n   * @remarks\n   * The returned angle will be between -180 and 180 degrees.\n   */\n  get degrees() {\n    return _Vector22.degrees(this.x, this.y);\n  }\n  get ctg() {\n    return this.x / this.y;\n  }\n  lerp(to, value) {\n    return _Vector22.lerp(this, to, value);\n  }\n  getOriginOffset(origin) {\n    const offset = _Vector22.fromOrigin(origin);\n    offset.x *= this.x / 2;\n    offset.y *= this.y / 2;\n    return offset;\n  }\n  scale(value) {\n    return new _Vector22(this.x * value, this.y * value);\n  }\n  mul(possibleVector) {\n    const vector = new _Vector22(possibleVector);\n    return new _Vector22(this.x * vector.x, this.y * vector.y);\n  }\n  div(possibleVector) {\n    const vector = new _Vector22(possibleVector);\n    return new _Vector22(this.x / vector.x, this.y / vector.y);\n  }\n  add(possibleVector) {\n    const vector = new _Vector22(possibleVector);\n    return new _Vector22(this.x + vector.x, this.y + vector.y);\n  }\n  sub(possibleVector) {\n    const vector = new _Vector22(possibleVector);\n    return new _Vector22(this.x - vector.x, this.y - vector.y);\n  }\n  dot(possibleVector) {\n    const vector = new _Vector22(possibleVector);\n    return this.x * vector.x + this.y * vector.y;\n  }\n  cross(possibleVector) {\n    const vector = new _Vector22(possibleVector);\n    return this.x * vector.y - this.y * vector.x;\n  }\n  mod(possibleVector) {\n    const vector = new _Vector22(possibleVector);\n    return new _Vector22(this.x % vector.x, this.y % vector.y);\n  }\n  addX(value) {\n    return new _Vector22(this.x + value, this.y);\n  }\n  addY(value) {\n    return new _Vector22(this.x, this.y + value);\n  }\n  toSymbol() {\n    return _Vector22.symbol;\n  }\n  toString() {\n    return `Vector2(${this.x}, ${this.y})`;\n  }\n  toUniform(gl, location) {\n    gl.uniform2f(location, this.x, this.y);\n  }\n  serialize() {\n    return { x: this.x, y: this.y };\n  }\n  /**\n   * Check if two vectors are exactly equal to each other.\n   *\n   * @remarks\n   * If you need to compensate for floating point inaccuracies, use the\n   * {@link equals} method, instead.\n   *\n   * @param other - The vector to compare.\n   */\n  exactlyEquals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n  /**\n   * Check if two vectors are equal to each other.\n   *\n   * @remarks\n   * This method allows passing an allowed error margin when comparing vectors\n   * to compensate for floating point inaccuracies. To check if two vectors are\n   * exactly equal, use the {@link exactlyEquals} method, instead.\n   *\n   * @param other - The vector to compare.\n   * @param threshold - The allowed error threshold when comparing the vectors.\n   */\n  equals(other, threshold = EPSILON) {\n    return Math.abs(this.x - other.x) <= threshold + Number.EPSILON && Math.abs(this.y - other.y) <= threshold + Number.EPSILON;\n  }\n};\n_Vector2.symbol = /* @__PURE__ */ Symbol.for(\"@twick/core/types/Vector2\");\n_Vector2.zero = new _Vector2();\n_Vector2.one = new _Vector2(1, 1);\n_Vector2.right = new _Vector2(1, 0);\n_Vector2.left = new _Vector2(-1, 0);\n_Vector2.up = new _Vector2(0, 1);\n_Vector2.down = new _Vector2(0, -1);\n_Vector2.top = new _Vector2(0, -1);\n_Vector2.bottom = new _Vector2(0, 1);\n_Vector2.topLeft = new _Vector2(-1, -1);\n_Vector2.topRight = new _Vector2(1, -1);\n_Vector2.bottomLeft = new _Vector2(-1, 1);\n_Vector2.bottomRight = new _Vector2(1, 1);\nvar Vector2 = _Vector2;\nvar _Matrix2D = class _Matrix2D2 {\n  constructor(a, b, c2, d, tx, ty) {\n    this.values = new Float32Array(6);\n    if (arguments.length === 0) {\n      this.values = new Float32Array([1, 0, 0, 1, 0, 0]);\n      return;\n    }\n    if (arguments.length === 6) {\n      this.values[0] = a;\n      this.values[1] = b;\n      this.values[2] = c2;\n      this.values[3] = d;\n      this.values[4] = tx;\n      this.values[5] = ty;\n      return;\n    }\n    if (a instanceof DOMMatrix) {\n      this.values[0] = a.m11;\n      this.values[1] = a.m12;\n      this.values[2] = a.m21;\n      this.values[3] = a.m22;\n      this.values[4] = a.m41;\n      this.values[5] = a.m42;\n      return;\n    }\n    if (a instanceof _Matrix2D2) {\n      this.values = a.values;\n      return;\n    }\n    if (Array.isArray(a)) {\n      if (a.length === 2) {\n        this.values[0] = a[0];\n        this.values[1] = a[1];\n        this.values[2] = b[0];\n        this.values[3] = b[1];\n        this.values[4] = c2[0];\n        this.values[5] = c2[1];\n        return;\n      }\n      if (a.length === 3) {\n        const x2 = new Vector2(a[0]);\n        const y2 = new Vector2(a[1]);\n        const z2 = new Vector2(a[2]);\n        this.values[0] = x2.x;\n        this.values[1] = x2.y;\n        this.values[2] = y2.x;\n        this.values[3] = y2.y;\n        this.values[4] = z2.x;\n        this.values[5] = z2.y;\n        return;\n      }\n      this.values[0] = a[0];\n      this.values[1] = a[1];\n      this.values[2] = a[2];\n      this.values[3] = a[3];\n      this.values[4] = a[4];\n      this.values[5] = a[5];\n      return;\n    }\n    const x = new Vector2(a);\n    const y = new Vector2(b);\n    const z = new Vector2(c2);\n    this.values[0] = x.x;\n    this.values[1] = x.y;\n    this.values[2] = y.x;\n    this.values[3] = y.y;\n    this.values[4] = z.x;\n    this.values[5] = z.y;\n  }\n  static fromRotation(angle) {\n    return _Matrix2D2.identity.rotate(angle);\n  }\n  static fromTranslation(translation) {\n    return _Matrix2D2.identity.translate(new Vector2(translation));\n  }\n  static fromScaling(scale) {\n    return _Matrix2D2.identity.scale(new Vector2(scale));\n  }\n  get x() {\n    return new Vector2(this.values[0], this.values[1]);\n  }\n  get y() {\n    return new Vector2(this.values[2], this.values[3]);\n  }\n  get scaleX() {\n    return this.values[0];\n  }\n  set scaleX(value) {\n    this.values[0] = this.x.normalized.scale(value).x;\n  }\n  get skewX() {\n    return this.values[1];\n  }\n  set skewX(value) {\n    this.values[1] = value;\n  }\n  get scaleY() {\n    return this.values[3];\n  }\n  set scaleY(value) {\n    this.values[3] = this.y.normalized.scale(value).y;\n  }\n  get skewY() {\n    return this.values[2];\n  }\n  set skewY(value) {\n    this.values[2] = value;\n  }\n  get translateX() {\n    return this.values[4];\n  }\n  set translateX(value) {\n    this.values[4] = value;\n  }\n  get translateY() {\n    return this.values[5];\n  }\n  set translateY(value) {\n    this.values[5] = value;\n  }\n  get rotation() {\n    return Vector2.degrees(this.values[0], this.values[1]);\n  }\n  set rotation(angle) {\n    const result = this.rotate(angle - this.rotation);\n    this.values[0] = result.values[0];\n    this.values[1] = result.values[1];\n    this.values[2] = result.values[2];\n    this.values[3] = result.values[3];\n  }\n  get translation() {\n    return new Vector2(this.values[4], this.values[5]);\n  }\n  set translation(translation) {\n    const vec = new Vector2(translation);\n    this.values[4] = vec.x;\n    this.values[5] = vec.y;\n  }\n  get scaling() {\n    return new Vector2(this.values[0], this.values[3]);\n  }\n  set scaling(value) {\n    const scale = new Vector2(value);\n    const x = new Vector2(this.values[0], this.values[1]).normalized;\n    const y = new Vector2(this.values[2], this.values[3]).normalized;\n    this.values[0] = x.x * scale.x;\n    this.values[1] = x.y * scale.y;\n    this.values[2] = y.x * scale.x;\n    this.values[3] = y.y * scale.y;\n  }\n  /**\n   * Get the inverse of the matrix.\n   *\n   * @remarks\n   * If the matrix is not invertible, i.e. its determinant is `0`, this will\n   * return `null`, instead.\n   *\n   * @example\n   * ```ts\n   * const matrix = new Matrix2D(\n   *   [1, 2],\n   *   [3, 4],\n   *   [5, 6],\n   * );\n   *\n   * const inverse = matrix.inverse;\n   * // => Matrix2D(\n   * //      [-2, 1],\n   * //      [1.5, -0.5],\n   * //      [1, -2],\n   * //   )\n   * ```\n   */\n  get inverse() {\n    const aa = this.values[0], ab = this.values[1], ac = this.values[2], ad = this.values[3];\n    const atx = this.values[4], aty = this.values[5];\n    let det = aa * ad - ab * ac;\n    if (!det) {\n      return null;\n    }\n    det = 1 / det;\n    return new _Matrix2D2(\n      ad * det,\n      -ab * det,\n      -ac * det,\n      aa * det,\n      (ac * aty - ad * atx) * det,\n      (ab * atx - aa * aty) * det\n    );\n  }\n  /**\n   * Get the determinant of the matrix.\n   */\n  get determinant() {\n    return this.values[0] * this.values[3] - this.values[1] * this.values[2];\n  }\n  get domMatrix() {\n    return new DOMMatrix([\n      this.values[0],\n      this.values[1],\n      this.values[2],\n      this.values[3],\n      this.values[4],\n      this.values[5]\n    ]);\n  }\n  /**\n   * Get the nth component vector of the matrix. Only defined for 0, 1, and 2.\n   *\n   * @example\n   * ```ts\n   * const matrix = new Matrix2D(\n   *   [1, 0],\n   *   [0, 0],\n   *   [1, 0],\n   * );\n   *\n   * const x = matrix.column(0);\n   * // Vector2(1, 0)\n   *\n   * const y = matrix.column(1);\n   * // Vector2(0, 0)\n   *\n   * const z = matrix.column(1);\n   * // Vector2(1, 0)\n   * ```\n   *\n   * @param index - The index of the component vector to retrieve.\n   */\n  column(index) {\n    return new Vector2(this.values[index * 2], this.values[index * 2 + 1]);\n  }\n  /**\n   * Returns the nth row of the matrix. Only defined for 0 and 1.\n   *\n   * @example\n   * ```ts\n   * const matrix = new Matrix2D(\n   *   [1, 0],\n   *   [0, 0],\n   *   [1, 0],\n   * );\n   *\n   * const firstRow = matrix.column(0);\n   * // [1, 0, 1]\n   *\n   * const secondRow = matrix.column(1);\n   * // [0, 0, 0]\n   * ```\n   *\n   * @param index - The index of the row to retrieve.\n   */\n  row(index) {\n    return [this.values[index], this.values[index + 2], this.values[index + 4]];\n  }\n  /**\n   * Returns the matrix product of this matrix with the provided matrix.\n   *\n   * @remarks\n   * This method returns a new matrix representing the result of the\n   * computation. It will not modify the source matrix.\n   *\n   * @example\n   * ```ts\n   * const a = new Matrix2D(\n   *   [1, 2],\n   *   [0, 1],\n   *   [1, 1],\n   * );\n   * const b = new Matrix2D(\n   *   [2, 1],\n   *   [1, 1],\n   *   [1, 1],\n   * );\n   *\n   * const result = a.mul(b);\n   * // => Matrix2D(\n   * //     [2, 5],\n   * //     [1, 3],\n   * //     [2, 4],\n   * //   )\n   * ```\n   *\n   * @param other - The matrix to multiply with\n   */\n  mul(other) {\n    const a0 = this.values[0], a1 = this.values[1], a2 = this.values[2], a3 = this.values[3], a4 = this.values[4], a5 = this.values[5];\n    const b0 = other.values[0], b1 = other.values[1], b2 = other.values[2], b3 = other.values[3], b4 = other.values[4], b5 = other.values[5];\n    return new _Matrix2D2(\n      a0 * b0 + a2 * b1,\n      a1 * b0 + a3 * b1,\n      a0 * b2 + a2 * b3,\n      a1 * b2 + a3 * b3,\n      a0 * b4 + a2 * b5 + a4,\n      a1 * b4 + a3 * b5 + a5\n    );\n  }\n  /**\n   * Rotate the matrix by the provided angle. By default, the angle is\n   * provided in degrees.\n   *\n   * @remarks\n   * This method returns a new matrix representing the result of the\n   * computation. It will not modify the source matrix.\n   *\n   * @example\n   * ```ts\n   * const a = new Matrix2D(\n   *   [1, 2],\n   *   [3, 4],\n   *   [5, 6],\n   * );\n   *\n   * const result = a.rotate(90);\n   * // => Matrix2D(\n   * //     [3, 4],\n   * //     [-1, -2],\n   * //     [5, 6],\n   * //   )\n   *\n   * // Provide the angle in radians\n   * const result = a.rotate(Math.PI * 0.5, true);\n   * // => Matrix2D(\n   * //     [3, 4],\n   * //     [-1, -2],\n   * //     [5, 6],\n   * //   )\n   * ```\n   *\n   * @param angle - The angle by which to rotate the matrix.\n   * @param degrees - Whether the angle is provided in degrees.\n   */\n  rotate(angle, degrees = true) {\n    if (degrees) {\n      angle *= DEG2RAD;\n    }\n    const a0 = this.values[0], a1 = this.values[1], a2 = this.values[2], a3 = this.values[3], a4 = this.values[4], a5 = this.values[5];\n    const s = Math.sin(angle);\n    const c2 = Math.cos(angle);\n    return new _Matrix2D2(\n      a0 * c2 + a2 * s,\n      a1 * c2 + a3 * s,\n      a0 * -s + a2 * c2,\n      a1 * -s + a3 * c2,\n      a4,\n      a5\n    );\n  }\n  /**\n   * Scale the x and y component vectors of the matrix.\n   *\n   * @remarks\n   * If `vec` is provided as a vector, the x and y component vectors of the\n   * matrix will be scaled by the x and y parts of the vector, respectively.\n   *\n   * If `vec` is provided as a scalar, the x and y component vectors will be\n   * scaled uniformly by this factor.\n   *\n   * This method returns a new matrix representing the result of the\n   * computation. It will not modify the source matrix.\n   *\n   * @example\n   * ```ts\n   * const matrix = new Matrix2D(\n   *   [1, 2],\n   *   [3, 4],\n   *   [5, 6],\n   * );\n   *\n   * const result1 = matrix.scale([2, 3]);\n   * // => new Matrix2D(\n   * //      [2, 4],\n   * //      [9, 12],\n   * //      [5, 6],\n   * //    )\n   *\n   * const result2 = matrix.scale(2);\n   * // => new Matrix2D(\n   * //      [2, 4],\n   * //      [6, 8],\n   * //      [5, 6],\n   * //    )\n   * ```\n   *\n   * @param vec - The factor by which to scale the matrix\n   */\n  scale(vec) {\n    const v = new Vector2(vec);\n    return new _Matrix2D2(\n      this.values[0] * v.x,\n      this.values[1] * v.x,\n      this.values[2] * v.y,\n      this.values[3] * v.y,\n      this.values[4],\n      this.values[5]\n    );\n  }\n  /**\n   * Multiply each value of the matrix by a scalar.\n   *\n   * * @example\n   * ```ts\n   * const matrix = new Matrix2D(\n   *   [1, 2],\n   *   [3, 4],\n   *   [5, 6],\n   * );\n   *\n   * const result1 = matrix.mulScalar(2);\n   * // => new Matrix2D(\n   * //      [2, 4],\n   * //      [6, 8],\n   * //      [10, 12],\n   * //    )\n   * ```\n   *\n   * @param s - The value by which to scale each term\n   */\n  mulScalar(s) {\n    return new _Matrix2D2(\n      this.values[0] * s,\n      this.values[1] * s,\n      this.values[2] * s,\n      this.values[3] * s,\n      this.values[4] * s,\n      this.values[5] * s\n    );\n  }\n  /**\n   * Translate the matrix by the dimensions of the provided vector.\n   *\n   * @remarks\n   * If `vec` is provided as a scalar, matrix will be translated uniformly\n   * by this factor.\n   *\n   * This method returns a new matrix representing the result of the\n   * computation. It will not modify the source matrix.\n   *\n   * @example\n   * ```ts\n   * const matrix = new Matrix2D(\n   *   [1, 2],\n   *   [3, 4],\n   *   [5, 6],\n   * );\n   *\n   * const result1 = matrix.translate([2, 3]);\n   * // => new Matrix2D(\n   * //      [1, 2],\n   * //      [3, 4],\n   * //      [16, 22],\n   * //    )\n   *\n   * const result2 = matrix.translate(2);\n   * // => new Matrix2D(\n   * //      [1, 2],\n   * //      [3, 4],\n   * //      [13, 18],\n   * //    )\n   * ```\n   *\n   * @param vec - The vector by which to translate the matrix\n   */\n  translate(vec) {\n    const v = new Vector2(vec);\n    return new _Matrix2D2(\n      this.values[0],\n      this.values[1],\n      this.values[2],\n      this.values[3],\n      this.values[0] * v.x + this.values[2] * v.y + this.values[4],\n      this.values[1] * v.x + this.values[3] * v.y + this.values[5]\n    );\n  }\n  /**\n   * Add the provided matrix to this matrix.\n   *\n   * @remarks\n   * This method returns a new matrix representing the result of the\n   * computation. It will not modify the source matrix.\n   *\n   * @example\n   * ```ts\n   * const a = new Matrix2D(\n   *   [1, 2],\n   *   [3, 4],\n   *   [5, 6],\n   * );\n   * const a = new Matrix2D(\n   *   [7, 8],\n   *   [9, 10],\n   *   [11, 12],\n   * );\n   *\n   * const result = a.add(b);\n   * // => Matrix2D(\n   * //      [8, 10],\n   * //      [12, 14],\n   * //      [16, 18],\n   * //    )\n   * ```\n   *\n   * @param other - The matrix to add\n   */\n  add(other) {\n    return new _Matrix2D2(\n      this.values[0] + other.values[0],\n      this.values[1] + other.values[1],\n      this.values[2] + other.values[2],\n      this.values[3] + other.values[3],\n      this.values[4] + other.values[4],\n      this.values[5] + other.values[5]\n    );\n  }\n  /**\n   * Subtract the provided matrix from this matrix.\n   *\n   * @remarks\n   * This method returns a new matrix representing the result of the\n   * computation. It will not modify the source matrix.\n   *\n   * @example\n   * ```ts\n   * const a = new Matrix2D(\n   *   [1, 2],\n   *   [3, 4],\n   *   [5, 6],\n   * );\n   * const a = new Matrix2D(\n   *   [7, 8],\n   *   [9, 10],\n   *   [11, 12],\n   * );\n   *\n   * const result = a.sub(b);\n   * // => Matrix2D(\n   * //      [-6, -6],\n   * //      [-6, -6],\n   * //      [-6, -6],\n   * //    )\n   * ```\n   *\n   * @param other - The matrix to subract\n   */\n  sub(other) {\n    return new _Matrix2D2(\n      this.values[0] - other.values[0],\n      this.values[1] - other.values[1],\n      this.values[2] - other.values[2],\n      this.values[3] - other.values[3],\n      this.values[4] - other.values[4],\n      this.values[5] - other.values[5]\n    );\n  }\n  toSymbol() {\n    return _Matrix2D2.symbol;\n  }\n  toUniform(gl, location) {\n    gl.uniformMatrix3x2fv(location, false, this.values);\n  }\n  equals(other, threshold = EPSILON) {\n    return Math.abs(this.values[0] - other.values[0]) <= threshold + Number.EPSILON && Math.abs(this.values[1] - other.values[1]) <= threshold + Number.EPSILON && Math.abs(this.values[2] - other.values[2]) <= threshold + Number.EPSILON && Math.abs(this.values[3] - other.values[3]) <= threshold + Number.EPSILON && Math.abs(this.values[4] - other.values[4]) <= threshold + Number.EPSILON && Math.abs(this.values[5] - other.values[5]) <= threshold + Number.EPSILON;\n  }\n  exactlyEquals(other) {\n    return this.values[0] === other.values[0] && this.values[1] === other.values[1] && this.values[2] === other.values[2] && this.values[3] === other.values[3] && this.values[4] === other.values[4] && this.values[5] === other.values[5];\n  }\n};\n_Matrix2D.symbol = /* @__PURE__ */ Symbol.for(\"@twick/core/types/Matrix2D\");\n_Matrix2D.identity = new _Matrix2D(1, 0, 0, 1, 0, 0);\n_Matrix2D.zero = new _Matrix2D(0, 0, 0, 0, 0, 0);\nvar PlaybackManager = class {\n  constructor() {\n    this.frame = 0;\n    this.speed = 1;\n    this.fps = 30;\n    this.duration = 0;\n    this.finished = false;\n    this.slides = [];\n    this.previousScene = null;\n    this.state = 2;\n    this.currentSceneReference = null;\n    this.scenes = new ValueDispatcher([]);\n  }\n  /**\n   * Triggered when the active scene changes.\n   *\n   * @eventProperty\n   */\n  get onSceneChanged() {\n    if (this.currentSceneReference === null) {\n      throw new Error(\"PlaybackManager has not been properly initialized\");\n    }\n    return this.currentSceneReference.subscribable;\n  }\n  /**\n   * Triggered when the scenes get recalculated.\n   *\n   * @remarks\n   * This event indicates that the timing of at least one scene has changed.\n   *\n   * @eventProperty\n   */\n  get onScenesRecalculated() {\n    return this.scenes.subscribable;\n  }\n  get currentScene() {\n    if (this.currentSceneReference === null) {\n      throw new Error(\"PlaybackManager has not been properly initialized\");\n    }\n    return this.currentSceneReference.current;\n  }\n  set currentScene(scene) {\n    if (!scene) {\n      throw new Error(\"Invalid scene.\");\n    }\n    this.currentSceneReference ?? (this.currentSceneReference = new ValueDispatcher(scene));\n    this.currentSceneReference.current = scene;\n  }\n  setup(scenes) {\n    this.scenes.current = scenes;\n    this.currentScene = scenes[0];\n  }\n  async progress() {\n    this.finished = await this.next();\n    return this.finished;\n  }\n  async seek(frame) {\n    if (frame <= this.frame || this.currentScene.isCached() && this.currentScene.lastFrame < frame) {\n      const scene = this.findBestScene(frame);\n      if (scene !== this.currentScene) {\n        this.currentScene.stopAllMedia();\n        this.previousScene = null;\n        this.currentScene = scene;\n        this.frame = this.currentScene.firstFrame;\n        await this.currentScene.reset();\n      } else if (this.frame >= frame) {\n        this.previousScene = null;\n        this.frame = this.currentScene.firstFrame;\n        await this.currentScene.reset();\n      }\n    }\n    this.finished = false;\n    while (this.frame < frame && !this.finished) {\n      this.finished = await this.next();\n    }\n    return this.finished;\n  }\n  async reset() {\n    this.previousScene = null;\n    this.currentScene = this.scenes.current[0];\n    this.frame = 0;\n    await this.currentScene.reset();\n  }\n  reload(description) {\n    this.scenes.current.forEach((scene) => scene.reload(description));\n  }\n  async recalculate() {\n    this.previousScene = null;\n    this.slides = [];\n    const speed = this.speed;\n    this.frame = 0;\n    this.speed = 1;\n    const scenes = [];\n    try {\n      for (const scene of this.scenes.current) {\n        await scene.recalculate((frame) => {\n          this.frame = frame;\n        });\n        this.slides.push(...scene.slides.onChanged.current);\n        scenes.push(scene);\n      }\n    } finally {\n      this.speed = speed;\n    }\n    this.scenes.current = scenes;\n    this.duration = this.frame;\n  }\n  async next() {\n    if (this.previousScene) {\n      await this.previousScene.next();\n      if (this.currentScene.isFinished()) {\n        this.previousScene = null;\n      }\n    }\n    this.frame += this.speed;\n    if (this.currentScene.isFinished()) {\n      return true;\n    }\n    await this.currentScene.next();\n    if (this.previousScene && this.currentScene.isAfterTransitionIn()) {\n      this.previousScene = null;\n    }\n    if (this.currentScene.canTransitionOut()) {\n      this.previousScene = this.currentScene;\n      const nextScene = this.getNextScene(this.previousScene);\n      if (nextScene) {\n        this.previousScene.stopAllMedia();\n        this.currentScene = nextScene;\n        await this.currentScene.reset(this.previousScene);\n      }\n      if (!nextScene || this.currentScene.isAfterTransitionIn()) {\n        this.previousScene = null;\n      }\n    }\n    return this.currentScene.isFinished();\n  }\n  findBestScene(frame) {\n    let lastScene = this.scenes.current[0];\n    for (const scene of this.scenes.current) {\n      if (!scene.isCached() || scene.lastFrame > frame) {\n        return scene;\n      }\n      lastScene = scene;\n    }\n    return lastScene;\n  }\n  getNextScene(scene) {\n    const scenes = this.scenes.current;\n    if (!scene) {\n      return scenes[0];\n    }\n    const index = scenes.findIndex((s) => s === scene);\n    if (index < 0) {\n      return null;\n    }\n    return scenes[index + 1] ?? null;\n  }\n};\nvar PlaybackStatus = class {\n  constructor(playback) {\n    this.playback = playback;\n  }\n  /**\n   * Convert seconds to frames using the current framerate.\n   *\n   * @param seconds - The seconds to convert.\n   */\n  secondsToFrames(seconds) {\n    return Math.ceil(seconds * this.playback.fps);\n  }\n  /**\n   * Convert frames to seconds using the current framerate.\n   *\n   * @param frames - The frames to convert.\n   */\n  framesToSeconds(frames) {\n    return frames / this.playback.fps;\n  }\n  get time() {\n    return this.framesToSeconds(this.playback.frame);\n  }\n  get frame() {\n    return this.playback.frame;\n  }\n  get speed() {\n    return this.playback.speed;\n  }\n  get fps() {\n    return this.playback.fps;\n  }\n  get state() {\n    return this.playback.state;\n  }\n  /**\n   * The time passed since the last frame in seconds.\n   */\n  get deltaTime() {\n    return this.framesToSeconds(1) * this.speed;\n  }\n};\nvar SOURCE_URL_REGEX = /^\\/\\/# sourceURL=(.*)$/gm;\nvar INFO_LOG_REGEX = /ERROR: \\d+:(\\d+): (.*)/g;\nvar INFO_TOKEN_REGEX = /^'([^']+)'/;\nvar includeWithoutPreprocessor = `\nThe \\`#include\\` directive requires the use of a preprocessor.\n\nMake sure to import the shader from a file:\n\n\\`\\`\\`ts\nimport shader from './shader.glsl';\n\\`\\`\\`\n\nDo **NOT** use the raw loader:\n\n\\`\\`\\`ts\nimport shader from './shader.glsl?raw';\n\\`\\`\\`\n\nDo **NOT** use \\`#include\\` in an inline string:\n\n\\`\\`\\`ts\nconst shader = \\`\\\\\n#include \"example.glsl\"\n\\`;\n\\`\\`\\`\n\n[Learn more](https://motioncanvas.io/docs/shaders) about working with shaders.\n`;\nvar SharedWebGLContext = class {\n  constructor(logger) {\n    this.logger = logger;\n    this.gl = null;\n    this.currentOwner = null;\n    this.programLookup = /* @__PURE__ */ new Map();\n  }\n  borrow(owner) {\n    var _a;\n    if (this.currentOwner === owner) {\n      return this.gl;\n    }\n    (_a = this.currentOwner) == null ? void 0 : _a.teardown(this.gl);\n    this.currentOwner = owner;\n    this.currentOwner.setup(this.getGL());\n    return this.gl;\n  }\n  /**\n   * Dispose the WebGL context to free up resources.\n   */\n  dispose() {\n    var _a, _b;\n    if (!this.gl) {\n      return;\n    }\n    (_a = this.currentOwner) == null ? void 0 : _a.teardown(this.gl);\n    this.currentOwner = null;\n    this.gl.useProgram(null);\n    for (const { program, fragment, vertex } of this.programLookup.values()) {\n      this.gl.deleteProgram(program);\n      this.gl.deleteShader(fragment);\n      this.gl.deleteShader(vertex);\n    }\n    this.programLookup.clear();\n    (_b = this.gl.getExtension(\"WEBGL_lose_context\")) == null ? void 0 : _b.loseContext();\n    this.gl.canvas.remove();\n    this.gl = null;\n  }\n  getProgram(fragment, vertex) {\n    const key = `${fragment}#${vertex}`;\n    if (this.programLookup.has(key)) {\n      return this.programLookup.get(key).program;\n    }\n    const gl = this.getGL();\n    const fragmentShader = this.getShader(gl.FRAGMENT_SHADER, fragment);\n    const vertexShader = this.getShader(gl.VERTEX_SHADER, vertex);\n    if (!fragmentShader || !vertexShader) {\n      return null;\n    }\n    const program = gl.createProgram();\n    gl.attachShader(program, fragmentShader);\n    gl.attachShader(program, vertexShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      this.logger.error({\n        message: \"Failed to initialize the shader program.\",\n        remarks: gl.getProgramInfoLog(program) ?? void 0,\n        stack: new Error().stack\n      });\n      gl.deleteProgram(program);\n      return null;\n    }\n    this.programLookup.set(key, {\n      program,\n      fragment: fragmentShader,\n      vertex: vertexShader\n    });\n    return program;\n  }\n  getShader(type, source) {\n    const gl = this.getGL();\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      const log = gl.getShaderInfoLog(shader);\n      logGlslError(this.logger, log, source);\n      gl.deleteShader(shader);\n      return null;\n    }\n    return shader;\n  }\n  getGL() {\n    if (this.gl) {\n      return this.gl;\n    }\n    this.gl = document.createElement(\"canvas\").getContext(\"webgl2\", {\n      depth: false,\n      premultipliedAlpha: false,\n      stencil: false,\n      powerPreference: \"high-performance\"\n    });\n    if (!this.gl) {\n      throw new Error(\"Failed to initialize WebGL.\");\n    }\n    return this.gl;\n  }\n};\nfunction logGlslError(logger, log, source) {\n  let sourceUrl = null;\n  SOURCE_URL_REGEX.lastIndex = 0;\n  const sourceMatch = SOURCE_URL_REGEX.exec(source);\n  if (sourceMatch) {\n    const url = new URL(sourceMatch[1], window.location.origin);\n    url.searchParams.set(\"t\", Date.now().toString());\n    sourceUrl = url.toString();\n  }\n  if (!log) {\n    logger.error({\n      message: `Unknown shader compilation error.`,\n      stack: fakeStackTrace(sourceUrl, 1, 0)\n    });\n    return null;\n  }\n  let logged = false;\n  let result;\n  while (result = INFO_LOG_REGEX.exec(log)) {\n    const [, line, message] = result;\n    let column = 0;\n    const match = message.match(INFO_TOKEN_REGEX);\n    if (match) {\n      const tokenLine = source.split(\"\\n\")[parseInt(line) - 1];\n      const index = tokenLine.indexOf(match[1]);\n      if (index !== -1) {\n        column = index;\n      }\n      if (match[1] === \"include\") {\n        const line2 = source.split(\"\\n\").find((line3) => line3.startsWith(\"#include\"));\n        if (line2) {\n          logged = true;\n          logger.error({\n            message: `Shader compilation error: ${message}`,\n            remarks: includeWithoutPreprocessor\n          });\n          break;\n        }\n      }\n    }\n    logged = true;\n    logger.error({\n      message: `Shader compilation error: ${message}`,\n      stack: fakeStackTrace(sourceUrl, line, column)\n    });\n  }\n  if (!logged) {\n    logger.error({\n      message: `Shader compilation error: ${log}`,\n      stack: fakeStackTrace(sourceUrl, 1, 0)\n    });\n  }\n}\nfunction fakeStackTrace(file, line, column) {\n  if (!file) {\n    return void 0;\n  }\n  return navigator.userAgent.toLowerCase().includes(\"chrome\") ? `  at (${file}:${line}:${column})` : `@${file}:${line}:${column}`;\n}\nvar Player = class {\n  constructor(project, settings = {}, initialState = {}, initialFrame = -1) {\n    var _a, _b;\n    this.project = project;\n    this.settings = settings;\n    this.initialState = initialState;\n    this.initialFrame = initialFrame;\n    this.render = new AsyncEventDispatcher();\n    this.frame = new ValueDispatcher(0);\n    this.duration = new ValueDispatcher(0);\n    this.recalculated = new EventDispatcher();\n    this.lock = new Semaphore();\n    this.startTime = 0;\n    this.endTime = Infinity;\n    this.requestId = null;\n    this.renderTime = 0;\n    this.requestedSeek = -1;\n    this.requestedRender = false;\n    this.requestedRecalculation = true;\n    this.active = false;\n    this.playerState = new ValueDispatcher({\n      loop: true,\n      muted: true,\n      volume: 1,\n      speed: 1,\n      ...initialState,\n      paused: true\n    });\n    this.sharedWebGLContext = new SharedWebGLContext(this.project.logger);\n    this.requestedSeek = initialFrame;\n    this.logger = this.project.logger;\n    this.playback = new PlaybackManager();\n    this.status = new PlaybackStatus(this.playback);\n    this.size = settings.size ?? new Vector2(1920, 1080);\n    this.resolutionScale = settings.resolutionScale ?? 1;\n    this.startTime = ((_a = settings.range) == null ? void 0 : _a[0]) ?? 0;\n    this.endTime = ((_b = settings.range) == null ? void 0 : _b[1]) ?? Infinity;\n    this.playback.fps = settings.fps ?? 60;\n    const scenes = [];\n    for (const description of project.scenes) {\n      const scene = new description.klass({\n        ...description,\n        playback: this.status,\n        logger: this.project.logger,\n        size: this.size,\n        resolutionScale: this.resolutionScale,\n        sharedWebGLContext: this.sharedWebGLContext,\n        experimentalFeatures: project.experimentalFeatures\n      });\n      scene.onReloaded.subscribe(() => this.requestRecalculation());\n      scene.variables.updateSignals(project.variables ?? {});\n      scenes.push(scene);\n    }\n    this.playback.setup(scenes);\n    this.activate();\n  }\n  /**\n   * Triggered during each iteration of the update loop when the frame is ready\n   * to be rendered.\n   *\n   * @remarks\n   * Player does not perform any rendering on its own. For the animation to be\n   * visible, another class must subscribe to this event and perform the\n   * rendering itself. {@link Stage} can be used to display the animation.\n   *\n   * @eventProperty\n   */\n  get onRender() {\n    return this.render.subscribable;\n  }\n  get onStateChanged() {\n    return this.playerState.subscribable;\n  }\n  get onFrameChanged() {\n    return this.frame.subscribable;\n  }\n  get onDurationChanged() {\n    return this.duration.subscribable;\n  }\n  /**\n   * Triggered right after recalculation finishes.\n   *\n   * @remarks\n   * Can be used to provide visual feedback.\n   *\n   * @eventProperty\n   */\n  get onRecalculated() {\n    return this.recalculated.subscribable;\n  }\n  get startFrame() {\n    return Math.min(\n      this.playback.duration,\n      this.status.secondsToFrames(this.startTime)\n    );\n  }\n  get endFrame() {\n    return Math.min(\n      this.playback.duration,\n      this.status.secondsToFrames(this.endTime)\n    );\n  }\n  get finished() {\n    return this.playback.finished || this.playback.frame >= this.endFrame;\n  }\n  async configure(settings) {\n    await this.lock.acquire();\n    let frame = this.playback.frame;\n    let recalculate = false;\n    this.startTime = settings.range[0];\n    this.endTime = settings.range[1];\n    const newFps = Math.max(1, settings.fps);\n    if (this.playback.fps !== newFps) {\n      const ratio = newFps / this.playback.fps;\n      this.playback.fps = newFps;\n      frame = Math.floor(frame * ratio);\n      recalculate = true;\n    }\n    if (!settings.size.exactlyEquals(this.size) || settings.resolutionScale !== this.resolutionScale) {\n      this.size = settings.size;\n      this.resolutionScale = settings.resolutionScale;\n      this.playback.reload({\n        size: this.size,\n        resolutionScale: this.resolutionScale\n      });\n    }\n    this.lock.release();\n    if (recalculate) {\n      this.playback.reload();\n      this.frame.current = frame;\n      this.requestRecalculation();\n      this.requestedSeek = frame;\n    }\n  }\n  /**\n   * Whether the given frame is inside the animation range.\n   *\n   * @param frame - The frame to check.\n   */\n  isInRange(frame) {\n    return frame >= 0 && frame <= this.playback.duration;\n  }\n  /**\n   * Whether the given frame is inside the user-defined range.\n   *\n   * @param frame - The frame to check.\n   */\n  isInUserRange(frame) {\n    return frame >= this.startFrame && frame <= this.endFrame;\n  }\n  requestSeek(value) {\n    this.requestedSeek = this.clampRange(value);\n  }\n  requestPreviousFrame() {\n    this.requestedSeek = this.frame.current - this.playback.speed;\n  }\n  requestNextFrame() {\n    this.requestedSeek = this.frame.current + this.playback.speed;\n  }\n  requestReset() {\n    this.requestedSeek = 0;\n  }\n  requestRender() {\n    this.requestedRender = true;\n  }\n  toggleLoop(value = !this.playerState.current.loop) {\n    if (value !== this.playerState.current.loop) {\n      this.playerState.current = {\n        ...this.playerState.current,\n        loop: value\n      };\n    }\n  }\n  togglePlayback(value = this.playerState.current.paused) {\n    if (value === this.playerState.current.paused) {\n      this.playerState.current = {\n        ...this.playerState.current,\n        paused: !value\n      };\n      if (value && !this.playerState.current.loop && this.playback.frame === this.playback.duration) {\n        this.requestReset();\n      }\n    }\n  }\n  toggleAudio(value = this.playerState.current.muted) {\n    if (value === this.playerState.current.muted) {\n      this.playerState.current = {\n        ...this.playerState.current,\n        muted: !value\n      };\n    }\n  }\n  setAudioVolume(value) {\n    const clampedValue = clamp(0, 1, value);\n    if (clampedValue !== this.playerState.current.volume) {\n      this.playerState.current = {\n        ...this.playerState.current,\n        volume: clampedValue\n      };\n    }\n  }\n  addAudioVolume(value) {\n    this.setAudioVolume(this.playerState.current.volume + value);\n  }\n  setSpeed(value) {\n    if (value !== this.playerState.current.speed) {\n      this.playback.speed = value;\n      this.playback.reload();\n      this.playerState.current = {\n        ...this.playerState.current,\n        speed: value\n      };\n      this.requestRecalculation();\n    }\n  }\n  setVariables(variables) {\n    for (const scene of this.playback.onScenesRecalculated.current) {\n      scene.variables.updateSignals(variables);\n    }\n  }\n  /**\n   * Activate the player.\n   *\n   * @remarks\n   * A player needs to be active in order for the update loop to run. Each\n   * player is active by default.\n   */\n  activate() {\n    this.active = true;\n    this.request();\n  }\n  /**\n   * Deactivate the player.\n   *\n   * @remarks\n   * Deactivating the player prevents its update loop from running. This should\n   * be done before disposing the player, to prevent it from running in the\n   * background.\n   *\n   * Just pausing the player does not stop the loop.\n   */\n  deactivate() {\n    this.active = false;\n    this.sharedWebGLContext.dispose();\n    this.playback.currentScene.stopAllMedia();\n    if (this.requestId !== null) {\n      cancelAnimationFrame(this.requestId);\n      this.requestId = null;\n    }\n  }\n  requestRecalculation() {\n    this.requestedRecalculation = true;\n    this.request();\n  }\n  async prepare() {\n    const state = {\n      ...this.playerState.current,\n      seek: this.requestedSeek,\n      render: this.requestedRender\n    };\n    this.requestedSeek = -1;\n    this.requestedRender = false;\n    if (this.requestedRecalculation) {\n      if (state.seek < 0) {\n        state.seek = this.playback.frame;\n      }\n      try {\n        await this.playback.recalculate();\n        this.duration.current = this.playback.frame;\n        this.recalculated.dispatch();\n      } catch (e2) {\n        this.requestSeek(state.seek);\n        throw e2;\n      } finally {\n        this.requestedRecalculation = false;\n      }\n    }\n    if (!state.loop && this.finished && !state.paused && state.seek < 0 || this.endFrame === this.startFrame) {\n      this.togglePlayback(false);\n      state.paused = true;\n      state.seek = this.endFrame === this.startFrame ? state.seek : this.startFrame;\n    }\n    if (state.loop && (state.seek > this.endFrame || this.finished && !state.paused) && this.startFrame !== this.endTime) {\n      state.seek = this.startFrame;\n    }\n    return state;\n  }\n  async run() {\n    const state = await this.prepare();\n    const previousState = this.playback.state;\n    this.playback.state = state.paused ? 2 : 0;\n    if (state.seek >= 0 || !this.isInUserRange(this.status.frame)) {\n      const seekFrame = state.seek < 0 ? this.status.frame : state.seek;\n      const clampedFrame = this.clampRange(seekFrame);\n      this.logger.profile(\"seek time\");\n      await this.playback.seek(clampedFrame);\n      this.logger.profile(\"seek time\");\n    } else if (state.paused) {\n      if (state.render || state.paused && previousState !== 2) {\n        await this.render.dispatch();\n      }\n      this.request();\n      return;\n    } else if (this.status.frame < this.endFrame) {\n      await this.playback.progress();\n    }\n    if (!state.paused && this.playback.currentScene.slides.isWaiting()) {\n      this.togglePlayback(false);\n      state.paused = true;\n    }\n    await this.render.dispatch();\n    this.frame.current = this.playback.frame;\n    this.request();\n  }\n  request() {\n    if (!this.active) return;\n    this.requestId ?? (this.requestId = requestAnimationFrame(async (time) => {\n      this.requestId = null;\n      if (time - this.renderTime >= 1e3 / (this.status.fps + 5)) {\n        this.renderTime = time;\n        await this.lock.acquire();\n        try {\n          await this.run();\n        } catch (e2) {\n          this.logger.error(e2);\n        }\n        this.lock.release();\n      } else {\n        this.request();\n      }\n    }));\n  }\n  clampRange(frame) {\n    return clamp(this.startFrame, this.endFrame, frame);\n  }\n};\nfunction getFullPreviewSettings(project) {\n  return {\n    ...project.settings.shared,\n    ...project.settings.preview\n  };\n}\nvar Stage = class {\n  constructor() {\n    this.background = null;\n    this.resolutionScale = 1;\n    this.colorSpace = \"srgb\";\n    this.size = Vector2.zero;\n    this.finalBuffer = document.createElement(\"canvas\");\n    this.currentBuffer = document.createElement(\"canvas\");\n    this.previousBuffer = document.createElement(\"canvas\");\n    const colorSpace = this.colorSpace;\n    this.context = getContext({ colorSpace }, this.finalBuffer);\n    this.currentContext = getContext({ colorSpace }, this.currentBuffer);\n    this.previousContext = getContext({ colorSpace }, this.previousBuffer);\n  }\n  get canvasSize() {\n    return this.size.scale(this.resolutionScale);\n  }\n  configure({\n    colorSpace = this.colorSpace,\n    size = this.size,\n    resolutionScale = this.resolutionScale,\n    background = this.background\n  }) {\n    if (colorSpace !== this.colorSpace) {\n      this.colorSpace = colorSpace;\n      this.context = getContext({ colorSpace }, this.finalBuffer);\n      this.currentContext = getContext({ colorSpace }, this.currentBuffer);\n      this.previousContext = getContext({ colorSpace }, this.previousBuffer);\n    }\n    if (!size.exactlyEquals(this.size) || resolutionScale !== this.resolutionScale) {\n      this.resolutionScale = resolutionScale;\n      this.size = size;\n      this.resizeCanvas(this.context);\n      this.resizeCanvas(this.currentContext);\n      this.resizeCanvas(this.previousContext);\n    }\n    this.background = typeof background === \"string\" ? background : (background == null ? void 0 : background.serialize()) ?? null;\n  }\n  async render(currentScene, previousScene) {\n    const previousOnTop = previousScene ? unwrap(currentScene.previousOnTop) : false;\n    if (previousScene) {\n      await previousScene.render(this.previousContext);\n    }\n    await currentScene.render(this.currentContext);\n    const size = this.canvasSize;\n    this.context.clearRect(0, 0, size.width, size.height);\n    if (this.background) {\n      this.context.save();\n      this.context.fillStyle = this.background;\n      this.context.fillRect(0, 0, size.width, size.height);\n      this.context.restore();\n    }\n    if (previousScene && !previousOnTop) {\n      this.context.drawImage(this.previousBuffer, 0, 0);\n    }\n    this.context.drawImage(this.currentBuffer, 0, 0);\n    if (previousOnTop) {\n      this.context.drawImage(this.previousBuffer, 0, 0);\n    }\n  }\n  resizeCanvas(context) {\n    const size = this.canvasSize;\n    context.canvas.width = size.width;\n    context.canvas.height = size.height;\n  }\n};\nfunction isThreadGenerator(value) {\n  return value !== null && typeof value === \"object\" && Symbol.iterator in value && \"next\" in value;\n}\nvar reusedGenerator = `\nThis usually happens when you mistakenly reuse a generator that is already\nrunning.\n\nFor example, using \\`yield\\` here will run the opacity generator concurrently and\nstore it in the \\`task\\` variable (in case you want to cancel or await it later):\n\n\\`\\`\\`ts\nconst task = yield rect().opacity(1, 1);\n\\`\\`\\`\n\nTrying to \\`yield\\` this task again will cause the current error:\n\n\\`\\`\\`ts\nyield task;\n\\`\\`\\`\n\nPassing it to other flow functions will also cause the error:\n\n\\`\\`\\`ts\n// prettier-ignore\nyield* all(task);\n\\`\\`\\`\n\nTry to investigate your code looking for \\`yield\\` statements whose return value\nis reused in this way. Here's an example of a common mistake:\n\n\\`\\`\\`ts wrong\n// prettier-ignore\nyield* all(\n  yield rect().opacity(1, 1), \n  yield rect().x(200, 1),\n);\n\\`\\`\\`\n\n\\`\\`\\`ts correct\n// prettier-ignore\nyield* all(\n  rect().opacity(1, 1), \n  rect().x(200, 1),\n);\n\\`\\`\\`\n`;\ndecorate(noop, threadable());\nfunction* noop() {\n}\nvar Thread = class {\n  constructor(runner) {\n    this.runner = runner;\n    this.children = [];\n    this.time = createSignal(0);\n    this.parent = null;\n    this.isCanceled = false;\n    this.isPaused = false;\n    this.fixedTime = 0;\n    this.queue = [];\n    if (this.runner.task) {\n      useLogger().error({\n        message: `The generator \"${getTaskName(\n          this.runner\n        )}\" is already being executed by another thread.`,\n        remarks: reusedGenerator\n      });\n      this.runner = noop();\n    }\n    this.runner.task = this;\n  }\n  /**\n   * The fixed time of this thread.\n   *\n   * @remarks\n   * Fixed time is a multiple of the frame duration. It can be used to account\n   * for the difference between this thread's {@link time} and the time of the\n   * current animation frame.\n   */\n  get fixed() {\n    return this.fixedTime;\n  }\n  /**\n   * Check if this thread or any of its ancestors has been canceled.\n   */\n  get canceled() {\n    var _a;\n    return this.isCanceled || (((_a = this.parent) == null ? void 0 : _a.canceled) ?? false);\n  }\n  get paused() {\n    var _a;\n    return this.isPaused || (((_a = this.parent) == null ? void 0 : _a.paused) ?? false);\n  }\n  /**\n   * Progress the wrapped generator once.\n   */\n  next() {\n    if (this.paused) {\n      return {\n        value: null,\n        done: false\n      };\n    }\n    startThread(this);\n    const result = this.runner.next(this.value);\n    endThread(this);\n    this.value = null;\n    return result;\n  }\n  /**\n   * Prepare the thread for the next update cycle.\n   *\n   * @param dt - The delta time of the next cycle.\n   */\n  update(dt) {\n    if (!this.paused) {\n      this.time(this.time() + dt);\n      this.fixedTime += dt;\n    }\n    this.children = this.children.filter((child) => !child.canceled);\n  }\n  spawn(child) {\n    if (!isThreadGenerator(child)) {\n      child = child();\n    }\n    this.queue.push(child);\n    return child;\n  }\n  add(child) {\n    child.parent = this;\n    child.isCanceled = false;\n    child.time(this.time());\n    child.fixedTime = this.fixedTime;\n    this.children.push(child);\n    setTaskName(child.runner, `unknown ${this.children.length}`);\n  }\n  drain(callback) {\n    this.queue.forEach(callback);\n    this.queue = [];\n  }\n  cancel() {\n    this.runner.return();\n    this.isCanceled = true;\n    this.parent = null;\n    this.drain((task) => task.return());\n  }\n  pause(value) {\n    this.isPaused = value;\n  }\n};\ndecorate(threads, threadable());\nfunction* threads(factory, callback) {\n  const playback = usePlayback();\n  const root = factory();\n  setTaskName(root, \"root\");\n  const rootThread = new Thread(root);\n  callback == null ? void 0 : callback(rootThread);\n  let threads2 = [rootThread];\n  while (threads2.length > 0) {\n    const newThreads = [];\n    const queue = [...threads2];\n    const dt = playback.deltaTime;\n    while (queue.length > 0) {\n      const thread = queue.pop();\n      if (!thread || thread.canceled) {\n        continue;\n      }\n      const result = thread.next();\n      if (result.done) {\n        thread.cancel();\n        continue;\n      }\n      if (isThreadGenerator(result.value)) {\n        const child = new Thread(result.value);\n        thread.value = result.value;\n        thread.add(child);\n        queue.push(thread);\n        queue.push(child);\n      } else if (result.value) {\n        thread.value = yield result.value;\n        queue.push(thread);\n      } else {\n        thread.update(dt);\n        thread.drain((task) => {\n          const child = new Thread(task);\n          thread.add(child);\n          newThreads.unshift(child);\n        });\n        newThreads.unshift(thread);\n      }\n    }\n    threads2 = newThreads.filter((thread) => !thread.canceled);\n    if (threads2.length > 0) yield;\n  }\n}\nvar stylesNew = `\n.overlay {\n\tposition: absolute;\n\tleft: 0;\n\tright: 0;\n\ttop: 0;\n\tbottom: 0;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\topacity: 0;\n\ttransition: opacity 0.1s;\n\tz-index: 0;\n  }\n  .canvas {\n\twidth: 100%;\n\theight: 100%;\n\tdisplay: block;\n\topacity: 1;\n\ttransition: opacity 0.1s;\n  }\n`;\nvar TEMPLATE = `<style>${stylesNew}</style><div class=\"overlay\"></div>`;\nvar ID = \"twick-player\";\nvar TwickPlayer = class extends HTMLElement {\n  constructor() {\n    super();\n    __publicField(this, \"root\");\n    __publicField(this, \"canvas\");\n    __publicField(this, \"overlay\");\n    __publicField(this, \"state\", \"initial\");\n    __publicField(this, \"project\", null);\n    __publicField(this, \"player\", null);\n    __publicField(this, \"defaultSettings\");\n    __publicField(this, \"abortController\", null);\n    __publicField(this, \"playing\", false);\n    __publicField(this, \"stage\", new Stage());\n    __publicField(this, \"time\", 0);\n    __publicField(this, \"duration\", 0);\n    // in frames\n    __publicField(this, \"looping\", true);\n    __publicField(this, \"volume\", 1);\n    __publicField(this, \"volumeChangeRequested\", true);\n    /**\n     * Triggered by the timeline.\n     */\n    __publicField(this, \"handleSeekTo\", (event) => {\n      var _a;\n      if (!this.project) {\n        return;\n      }\n      const e2 = event;\n      this.time = e2.detail;\n      (_a = this.player) == null ? void 0 : _a.requestSeek(e2.detail * this.player.playback.fps);\n      this.volumeChangeRequested = true;\n    });\n    __publicField(this, \"handleVolumeChange\", (event) => {\n      var _a;\n      if (!this.project) {\n        return;\n      }\n      const e2 = event;\n      this.volume = e2.detail;\n      (_a = this.player) == null ? void 0 : _a.playback.currentScene.adjustVolume(this.volume);\n    });\n    /**\n     * Triggered by the player.\n     */\n    __publicField(this, \"handleFrameChanged\", (frame) => {\n      var _a;\n      if (!this.project || !this.player) {\n        return;\n      }\n      this.time = frame / this.player.playback.fps;\n      if (this.volumeChangeRequested || frame === 0) {\n        (_a = this.player) == null ? void 0 : _a.playback.currentScene.adjustVolume(this.volume);\n        this.volumeChangeRequested = false;\n      }\n    });\n    /**\n     * Called on every frame.\n     */\n    __publicField(this, \"render\", async () => {\n      if (this.player && this.project) {\n        await this.stage.render(\n          this.player.playback.currentScene,\n          this.player.playback.previousScene\n        );\n        this.dispatchEvent(new CustomEvent(\"timeupdate\", { detail: this.time }));\n        const durationInFrames = this.player.playback.duration;\n        if (durationInFrames === this.duration) {\n          return;\n        }\n        this.duration = durationInFrames;\n        const durationInSeconds = durationInFrames / this.player.playback.fps;\n        this.dispatchEvent(\n          new CustomEvent(\"duration\", { detail: durationInSeconds })\n        );\n      }\n    });\n    this.root = this.attachShadow({ mode: \"open\" });\n    this.root.innerHTML = TEMPLATE;\n    this.overlay = this.root.querySelector(\".overlay\");\n    this.canvas = this.stage.finalBuffer;\n    this.canvas.classList.add(\"canvas\");\n    this.root.prepend(this.canvas);\n    this.setState(\n      \"initial\"\n      /* Initial */\n    );\n  }\n  static get observedAttributes() {\n    return [\n      \"playing\",\n      \"variables\",\n      \"looping\",\n      \"fps\",\n      \"quality\",\n      \"width\",\n      \"height\",\n      \"volume\"\n    ];\n  }\n  get fps() {\n    var _a;\n    const attr = this.getAttribute(\"fps\");\n    return attr ? parseFloat(attr) : ((_a = this.defaultSettings) == null ? void 0 : _a.fps) ?? 60;\n  }\n  get quality() {\n    var _a;\n    const attr = this.getAttribute(\"quality\");\n    return attr ? parseFloat(attr) : ((_a = this.defaultSettings) == null ? void 0 : _a.resolutionScale) ?? 1;\n  }\n  get width() {\n    var _a;\n    const attr = this.getAttribute(\"width\");\n    return attr ? parseFloat(attr) : ((_a = this.defaultSettings) == null ? void 0 : _a.size.width) ?? 0;\n  }\n  set width(value) {\n    if (Number.isFinite(value)) {\n      this.setAttribute(\"width\", String(value));\n    }\n  }\n  get height() {\n    var _a;\n    const attr = this.getAttribute(\"height\");\n    return attr ? parseFloat(attr) : ((_a = this.defaultSettings) == null ? void 0 : _a.size.height) ?? 0;\n  }\n  set height(value) {\n    if (Number.isFinite(value)) {\n      this.setAttribute(\"height\", String(value));\n    }\n  }\n  get variables() {\n    var _a;\n    try {\n      const attr = this.getAttribute(\"variables\");\n      return attr ? JSON.parse(attr) : {};\n    } catch {\n      (_a = this.project) == null ? void 0 : _a.logger.warn(`Project variables could not be parsed.`);\n      return {};\n    }\n  }\n  setProject(project) {\n    this.updateProject(project);\n  }\n  setState(state) {\n    this.state = state;\n    this.setPlaying(this.playing);\n  }\n  setPlaying(value) {\n    var _a, _b;\n    if (this.state === \"ready\" && value) {\n      (_a = this.player) == null ? void 0 : _a.togglePlayback(true);\n      this.playing = true;\n    } else {\n      (_b = this.player) == null ? void 0 : _b.togglePlayback(false);\n      this.playing = false;\n    }\n  }\n  async updateProject(project) {\n    var _a, _b, _c, _d, _e;\n    const playing = this.playing;\n    this.setState(\n      \"initial\"\n      /* Initial */\n    );\n    (_a = this.abortController) == null ? void 0 : _a.abort();\n    this.abortController = new AbortController();\n    this.project = project;\n    this.defaultSettings = getFullPreviewSettings(this.project);\n    const player = new Player(this.project);\n    player.setVariables(this.variables);\n    player.toggleLoop(this.looping);\n    (_b = this.player) == null ? void 0 : _b.onRender.unsubscribe(this.render);\n    (_c = this.player) == null ? void 0 : _c.onFrameChanged.unsubscribe(this.handleFrameChanged);\n    (_d = this.player) == null ? void 0 : _d.togglePlayback(false);\n    (_e = this.player) == null ? void 0 : _e.deactivate();\n    this.player = player;\n    this.updateSettings();\n    this.setState(\n      \"ready\"\n      /* Ready */\n    );\n    this.dispatchEvent(new CustomEvent(\"playerready\", { detail: this.player }));\n    this.setPlaying(playing);\n    this.player.onRender.subscribe(this.render);\n    this.player.onFrameChanged.subscribe(this.handleFrameChanged);\n  }\n  attributeChangedCallback(name, _, newValue) {\n    var _a, _b, _c, _d;\n    switch (name) {\n      case \"playing\":\n        this.setPlaying(newValue === \"true\");\n        break;\n      case \"variables\":\n        (_a = this.player) == null ? void 0 : _a.setVariables(this.variables);\n        (_b = this.player) == null ? void 0 : _b.requestSeek(this.player.playback.frame);\n        (_c = this.player) == null ? void 0 : _c.playback.reload();\n        break;\n      case \"looping\":\n        this.looping = newValue === \"true\";\n        (_d = this.player) == null ? void 0 : _d.toggleLoop(newValue === \"true\");\n        break;\n      case \"fps\":\n      case \"quality\":\n      case \"width\":\n      case \"height\":\n        this.updateSettings();\n        break;\n      case \"volume\":\n        this.volume = newValue;\n        this.volumeChangeRequested = true;\n    }\n  }\n  /**\n   * Runs when the element is removed from the DOM.\n   */\n  disconnectedCallback() {\n    var _a, _b;\n    (_a = this.player) == null ? void 0 : _a.deactivate();\n    (_b = this.player) == null ? void 0 : _b.onRender.unsubscribe(this.render);\n    this.removeEventListener(\"seekto\", this.handleSeekTo);\n    this.removeEventListener(\"volumechange\", this.handleVolumeChange);\n  }\n  /**\n   * Runs when the element is added to the DOM.\n   */\n  connectedCallback() {\n    var _a, _b;\n    (_a = this.player) == null ? void 0 : _a.activate();\n    (_b = this.player) == null ? void 0 : _b.onRender.subscribe(this.render);\n    this.addEventListener(\"seekto\", this.handleSeekTo);\n    this.addEventListener(\"volumechange\", this.handleVolumeChange);\n  }\n  updateSettings() {\n    var _a;\n    if (!this.defaultSettings) {\n      return;\n    }\n    const resolutionScale = Number.isFinite(this.quality) && this.quality > 0 ? this.quality : this.defaultSettings.resolutionScale ?? 1;\n    const settings = {\n      ...this.defaultSettings,\n      size: new Vector2(this.width, this.height),\n      resolutionScale,\n      fps: this.fps\n    };\n    this.stage.configure(settings);\n    (_a = this.player) == null ? void 0 : _a.configure(settings);\n  }\n};\nif (!customElements.get(ID)) {\n  customElements.define(ID, TwickPlayer);\n}\n//# sourceMappingURL=internal-KYB5ZQ5E-Be1ZlZZg.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdHdpY2svbGl2ZS1wbGF5ZXIvZGlzdC9pbnRlcm5hbC1LWUI1WlE1RS1CZTFabFpaZy5tanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsc0JBQXNCLE1BQU0sSUFBSSxNQUFNO0FBQ3RDLG9CQUFvQixNQUFNLHNCQUFzQixNQUFNO0FBQ3REO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLE1BQU0sY0FBYyxRQUFRO0FBQ3RFO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLElBQUksY0FBYyxRQUFRO0FBQ2hFO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSkFBaUosaUJBQWlCO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNCQUFzQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDBDQUEwQztBQUNwRztBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxTQUFTLGlEQUFpRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsSUFBSSxjQUFjLFFBQVE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDLEVBQUUsNkNBQTZDLEVBQUUsNENBQTRDLEVBQUUscUJBQXFCLFNBQVMsT0FBTztBQUNqTTtBQUNBLFNBQVMsaURBQWlEO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFNBQVMsaURBQWlEO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQyxFQUFFLDZDQUE2QyxFQUFFLDRDQUE0QyxFQUFFLHFCQUFxQixTQUFTLE9BQU87QUFDak07QUFDQSxTQUFTLGlEQUFpRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxTQUFTLGlEQUFpRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0QixpQ0FBaUMsRUFBRSxpQ0FBaUMsRUFBRSxnQ0FBZ0MsRUFBRSxxQkFBcUIsU0FBUyxPQUFPO0FBQ3pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNEJBQTRCLGlDQUFpQyxFQUFFLGlDQUFpQyxFQUFFLGdDQUFnQyxFQUFFLHFCQUFxQixTQUFTLE9BQU87QUFDeks7QUFDQSxTQUFTLGlEQUFpRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsU0FBUyxpREFBaUQ7QUFDMUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixpQ0FBaUMsRUFBRSxpQ0FBaUMsRUFBRSxnQ0FBZ0MsRUFBRSxxQkFBcUIsU0FBUyxPQUFPO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixpQ0FBaUMsRUFBRSxpQ0FBaUMsRUFBRSxnQ0FBZ0MsRUFBRSxxQkFBcUIsU0FBUyxPQUFPO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE1BQU0sS0FBSyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTyxJQUFJLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGNBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVMsR0FBRyxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsS0FBSyxHQUFHLEtBQUssR0FBRyxPQUFPLFNBQVMsS0FBSyxHQUFHLEtBQUssR0FBRyxPQUFPO0FBQ2hJO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDLHVDQUF1QyxZQUFZO0FBQ25ELHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUMseUNBQXlDLFlBQVk7QUFDckQsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxxQkFBcUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1CQUFtQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQkFBMkI7QUFDbkU7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdHdpY2svbGl2ZS1wbGF5ZXIvZGlzdC9pbnRlcm5hbC1LWUI1WlE1RS1CZTFabFpaZy5tanM/NTk5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuY29uc3QgcGFyc2VOdW1iZXIgPSAoY29sb3IsIGxlbikgPT4ge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSBcIm51bWJlclwiKSByZXR1cm47XG4gIGlmIChsZW4gPT09IDMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kZTogXCJyZ2JcIixcbiAgICAgIHI6IChjb2xvciA+PiA4ICYgMTUgfCBjb2xvciA+PiA0ICYgMjQwKSAvIDI1NSxcbiAgICAgIGc6IChjb2xvciA+PiA0ICYgMTUgfCBjb2xvciAmIDI0MCkgLyAyNTUsXG4gICAgICBiOiAoY29sb3IgJiAxNSB8IGNvbG9yIDw8IDQgJiAyNDApIC8gMjU1XG4gICAgfTtcbiAgfVxuICBpZiAobGVuID09PSA0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6IFwicmdiXCIsXG4gICAgICByOiAoY29sb3IgPj4gMTIgJiAxNSB8IGNvbG9yID4+IDggJiAyNDApIC8gMjU1LFxuICAgICAgZzogKGNvbG9yID4+IDggJiAxNSB8IGNvbG9yID4+IDQgJiAyNDApIC8gMjU1LFxuICAgICAgYjogKGNvbG9yID4+IDQgJiAxNSB8IGNvbG9yICYgMjQwKSAvIDI1NSxcbiAgICAgIGFscGhhOiAoY29sb3IgJiAxNSB8IGNvbG9yIDw8IDQgJiAyNDApIC8gMjU1XG4gICAgfTtcbiAgfVxuICBpZiAobGVuID09PSA2KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6IFwicmdiXCIsXG4gICAgICByOiAoY29sb3IgPj4gMTYgJiAyNTUpIC8gMjU1LFxuICAgICAgZzogKGNvbG9yID4+IDggJiAyNTUpIC8gMjU1LFxuICAgICAgYjogKGNvbG9yICYgMjU1KSAvIDI1NVxuICAgIH07XG4gIH1cbiAgaWYgKGxlbiA9PT0gOCkge1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlOiBcInJnYlwiLFxuICAgICAgcjogKGNvbG9yID4+IDI0ICYgMjU1KSAvIDI1NSxcbiAgICAgIGc6IChjb2xvciA+PiAxNiAmIDI1NSkgLyAyNTUsXG4gICAgICBiOiAoY29sb3IgPj4gOCAmIDI1NSkgLyAyNTUsXG4gICAgICBhbHBoYTogKGNvbG9yICYgMjU1KSAvIDI1NVxuICAgIH07XG4gIH1cbn07XG5jb25zdCBuYW1lZCA9IHtcbiAgYWxpY2VibHVlOiAxNTc5MjM4MyxcbiAgYW50aXF1ZXdoaXRlOiAxNjQ0NDM3NSxcbiAgYXF1YTogNjU1MzUsXG4gIGFxdWFtYXJpbmU6IDgzODg1NjQsXG4gIGF6dXJlOiAxNTc5NDE3NSxcbiAgYmVpZ2U6IDE2MTE5MjYwLFxuICBiaXNxdWU6IDE2NzcwMjQ0LFxuICBibGFjazogMCxcbiAgYmxhbmNoZWRhbG1vbmQ6IDE2NzcyMDQ1LFxuICBibHVlOiAyNTUsXG4gIGJsdWV2aW9sZXQ6IDkwNTUyMDIsXG4gIGJyb3duOiAxMDgyNDIzNCxcbiAgYnVybHl3b29kOiAxNDU5NjIzMSxcbiAgY2FkZXRibHVlOiA2MjY2NTI4LFxuICBjaGFydHJldXNlOiA4Mzg4MzUyLFxuICBjaG9jb2xhdGU6IDEzNzg5NDcwLFxuICBjb3JhbDogMTY3NDQyNzIsXG4gIGNvcm5mbG93ZXJibHVlOiA2NTkxOTgxLFxuICBjb3Juc2lsazogMTY3NzUzODgsXG4gIGNyaW1zb246IDE0NDIzMTAwLFxuICBjeWFuOiA2NTUzNSxcbiAgZGFya2JsdWU6IDEzOSxcbiAgZGFya2N5YW46IDM1NzIzLFxuICBkYXJrZ29sZGVucm9kOiAxMjA5MjkzOSxcbiAgZGFya2dyYXk6IDExMTE5MDE3LFxuICBkYXJrZ3JlZW46IDI1NjAwLFxuICBkYXJrZ3JleTogMTExMTkwMTcsXG4gIGRhcmtraGFraTogMTI0MzMyNTksXG4gIGRhcmttYWdlbnRhOiA5MTA5NjQzLFxuICBkYXJrb2xpdmVncmVlbjogNTU5Nzk5OSxcbiAgZGFya29yYW5nZTogMTY3NDc1MjAsXG4gIGRhcmtvcmNoaWQ6IDEwMDQwMDEyLFxuICBkYXJrcmVkOiA5MTA5NTA0LFxuICBkYXJrc2FsbW9uOiAxNTMwODQxMCxcbiAgZGFya3NlYWdyZWVuOiA5NDE5OTE5LFxuICBkYXJrc2xhdGVibHVlOiA0NzM0MzQ3LFxuICBkYXJrc2xhdGVncmF5OiAzMTAwNDk1LFxuICBkYXJrc2xhdGVncmV5OiAzMTAwNDk1LFxuICBkYXJrdHVycXVvaXNlOiA1Mjk0NSxcbiAgZGFya3Zpb2xldDogOTY5OTUzOSxcbiAgZGVlcHBpbms6IDE2NzE2OTQ3LFxuICBkZWVwc2t5Ymx1ZTogNDkxNTEsXG4gIGRpbWdyYXk6IDY5MDgyNjUsXG4gIGRpbWdyZXk6IDY5MDgyNjUsXG4gIGRvZGdlcmJsdWU6IDIwMDMxOTksXG4gIGZpcmVicmljazogMTE2NzQxNDYsXG4gIGZsb3JhbHdoaXRlOiAxNjc3NTkyMCxcbiAgZm9yZXN0Z3JlZW46IDIyNjM4NDIsXG4gIGZ1Y2hzaWE6IDE2NzExOTM1LFxuICBnYWluc2Jvcm86IDE0NDc0NDYwLFxuICBnaG9zdHdoaXRlOiAxNjMxNjY3MSxcbiAgZ29sZDogMTY3NjY3MjAsXG4gIGdvbGRlbnJvZDogMTQzMjkxMjAsXG4gIGdyYXk6IDg0MjE1MDQsXG4gIGdyZWVuOiAzMjc2OCxcbiAgZ3JlZW55ZWxsb3c6IDExNDAzMDU1LFxuICBncmV5OiA4NDIxNTA0LFxuICBob25leWRldzogMTU3OTQxNjAsXG4gIGhvdHBpbms6IDE2NzM4NzQwLFxuICBpbmRpYW5yZWQ6IDEzNDU4NTI0LFxuICBpbmRpZ286IDQ5MTUzMzAsXG4gIGl2b3J5OiAxNjc3NzIwMCxcbiAga2hha2k6IDE1Nzg3NjYwLFxuICBsYXZlbmRlcjogMTUxMzI0MTAsXG4gIGxhdmVuZGVyYmx1c2g6IDE2NzczMzY1LFxuICBsYXduZ3JlZW46IDgxOTA5NzYsXG4gIGxlbW9uY2hpZmZvbjogMTY3NzU4ODUsXG4gIGxpZ2h0Ymx1ZTogMTEzOTMyNTQsXG4gIGxpZ2h0Y29yYWw6IDE1NzYxNTM2LFxuICBsaWdodGN5YW46IDE0NzQ1NTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogMTY0NDgyMTAsXG4gIGxpZ2h0Z3JheTogMTM4ODIzMjMsXG4gIGxpZ2h0Z3JlZW46IDk0OTgyNTYsXG4gIGxpZ2h0Z3JleTogMTM4ODIzMjMsXG4gIGxpZ2h0cGluazogMTY3NTg0NjUsXG4gIGxpZ2h0c2FsbW9uOiAxNjc1Mjc2MixcbiAgbGlnaHRzZWFncmVlbjogMjE0Mjg5MCxcbiAgbGlnaHRza3libHVlOiA4OTAwMzQ2LFxuICBsaWdodHNsYXRlZ3JheTogNzgzMzc1MyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDc4MzM3NTMsXG4gIGxpZ2h0c3RlZWxibHVlOiAxMTU4NDczNCxcbiAgbGlnaHR5ZWxsb3c6IDE2Nzc3MTg0LFxuICBsaW1lOiA2NTI4MCxcbiAgbGltZWdyZWVuOiAzMzI5MzMwLFxuICBsaW5lbjogMTY0NDU2NzAsXG4gIG1hZ2VudGE6IDE2NzExOTM1LFxuICBtYXJvb246IDgzODg2MDgsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IDY3MzczMjIsXG4gIG1lZGl1bWJsdWU6IDIwNSxcbiAgbWVkaXVtb3JjaGlkOiAxMjIxMTY2NyxcbiAgbWVkaXVtcHVycGxlOiA5NjYyNjgzLFxuICBtZWRpdW1zZWFncmVlbjogMzk3ODA5NyxcbiAgbWVkaXVtc2xhdGVibHVlOiA4MDg3NzkwLFxuICBtZWRpdW1zcHJpbmdncmVlbjogNjQxNTQsXG4gIG1lZGl1bXR1cnF1b2lzZTogNDc3MjMwMCxcbiAgbWVkaXVtdmlvbGV0cmVkOiAxMzA0NzE3MyxcbiAgbWlkbmlnaHRibHVlOiAxNjQ0OTEyLFxuICBtaW50Y3JlYW06IDE2MTIxODUwLFxuICBtaXN0eXJvc2U6IDE2NzcwMjczLFxuICBtb2NjYXNpbjogMTY3NzAyMjksXG4gIG5hdmFqb3doaXRlOiAxNjc2ODY4NSxcbiAgbmF2eTogMTI4LFxuICBvbGRsYWNlOiAxNjY0MzU1OCxcbiAgb2xpdmU6IDg0MjEzNzYsXG4gIG9saXZlZHJhYjogNzA0ODczOSxcbiAgb3JhbmdlOiAxNjc1MzkyMCxcbiAgb3JhbmdlcmVkOiAxNjcyOTM0NCxcbiAgb3JjaGlkOiAxNDMxNTczNCxcbiAgcGFsZWdvbGRlbnJvZDogMTU2NTcxMzAsXG4gIHBhbGVncmVlbjogMTAwMjU4ODAsXG4gIHBhbGV0dXJxdW9pc2U6IDExNTI5OTY2LFxuICBwYWxldmlvbGV0cmVkOiAxNDM4MTIwMyxcbiAgcGFwYXlhd2hpcDogMTY3NzMwNzcsXG4gIHBlYWNocHVmZjogMTY3Njc2NzMsXG4gIHBlcnU6IDEzNDY4OTkxLFxuICBwaW5rOiAxNjc2MTAzNSxcbiAgcGx1bTogMTQ1MjQ2MzcsXG4gIHBvd2RlcmJsdWU6IDExNTkxOTEwLFxuICBwdXJwbGU6IDgzODg3MzYsXG4gIC8vIEFkZGVkIGluIENTUyBDb2xvcnMgTGV2ZWwgNDpcbiAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci8jY2hhbmdlcy1mcm9tLTNcbiAgcmViZWNjYXB1cnBsZTogNjY5Nzg4MSxcbiAgcmVkOiAxNjcxMTY4MCxcbiAgcm9zeWJyb3duOiAxMjM1NzUxOSxcbiAgcm95YWxibHVlOiA0Mjg2OTQ1LFxuICBzYWRkbGVicm93bjogOTEyNzE4NyxcbiAgc2FsbW9uOiAxNjQxNjg4MixcbiAgc2FuZHlicm93bjogMTYwMzI4NjQsXG4gIHNlYWdyZWVuOiAzMDUwMzI3LFxuICBzZWFzaGVsbDogMTY3NzQ2MzgsXG4gIHNpZW5uYTogMTA1MDY3OTcsXG4gIHNpbHZlcjogMTI2MzIyNTYsXG4gIHNreWJsdWU6IDg5MDAzMzEsXG4gIHNsYXRlYmx1ZTogNjk3MDA2MSxcbiAgc2xhdGVncmF5OiA3MzcyOTQ0LFxuICBzbGF0ZWdyZXk6IDczNzI5NDQsXG4gIHNub3c6IDE2Nzc1OTMwLFxuICBzcHJpbmdncmVlbjogNjU0MDcsXG4gIHN0ZWVsYmx1ZTogNDYyMDk4MCxcbiAgdGFuOiAxMzgwODc4MCxcbiAgdGVhbDogMzI4OTYsXG4gIHRoaXN0bGU6IDE0MjA0ODg4LFxuICB0b21hdG86IDE2NzM3MDk1LFxuICB0dXJxdW9pc2U6IDQyNTE4NTYsXG4gIHZpb2xldDogMTU2MzEwODYsXG4gIHdoZWF0OiAxNjExMzMzMSxcbiAgd2hpdGU6IDE2Nzc3MjE1LFxuICB3aGl0ZXNtb2tlOiAxNjExOTI4NSxcbiAgeWVsbG93OiAxNjc3Njk2MCxcbiAgeWVsbG93Z3JlZW46IDEwMTQ1MDc0XG59O1xuY29uc3QgcGFyc2VOYW1lZCA9IChjb2xvcikgPT4ge1xuICByZXR1cm4gcGFyc2VOdW1iZXIobmFtZWRbY29sb3IudG9Mb3dlckNhc2UoKV0sIDYpO1xufTtcbmNvbnN0IGhleCA9IC9eIz8oWzAtOWEtZl17OH18WzAtOWEtZl17Nn18WzAtOWEtZl17NH18WzAtOWEtZl17M30pJC9pO1xuY29uc3QgcGFyc2VIZXggPSAoY29sb3IpID0+IHtcbiAgbGV0IG1hdGNoO1xuICByZXR1cm4gKG1hdGNoID0gY29sb3IubWF0Y2goaGV4KSkgPyBwYXJzZU51bWJlcihwYXJzZUludChtYXRjaFsxXSwgMTYpLCBtYXRjaFsxXS5sZW5ndGgpIDogdm9pZCAwO1xufTtcbmNvbnN0IG51bSQxID0gXCIoWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPylcIjtcbmNvbnN0IHBlciA9IGAke251bSQxfSVgO1xuY29uc3QgbnVtX3BlciA9IGAoPzoke251bSQxfSV8JHtudW0kMX0pYDtcbmNvbnN0IGh1ZSQxID0gYCg/OiR7bnVtJDF9KGRlZ3xncmFkfHJhZHx0dXJuKXwke251bSQxfSlgO1xuY29uc3QgYyA9IGBcXFxccyosXFxcXHMqYDtcbmNvbnN0IHJnYl9udW1fb2xkID0gbmV3IFJlZ0V4cChcbiAgYF5yZ2JhP1xcXFwoXFxcXHMqJHtudW0kMX0ke2N9JHtudW0kMX0ke2N9JHtudW0kMX1cXFxccyooPzosXFxcXHMqJHtudW1fcGVyfVxcXFxzKik/XFxcXCkkYFxuKTtcbmNvbnN0IHJnYl9wZXJfb2xkID0gbmV3IFJlZ0V4cChcbiAgYF5yZ2JhP1xcXFwoXFxcXHMqJHtwZXJ9JHtjfSR7cGVyfSR7Y30ke3Blcn1cXFxccyooPzosXFxcXHMqJHtudW1fcGVyfVxcXFxzKik/XFxcXCkkYFxuKTtcbmNvbnN0IHBhcnNlUmdiTGVnYWN5ID0gKGNvbG9yKSA9PiB7XG4gIGxldCByZXMgPSB7IG1vZGU6IFwicmdiXCIgfTtcbiAgbGV0IG1hdGNoO1xuICBpZiAobWF0Y2ggPSBjb2xvci5tYXRjaChyZ2JfbnVtX29sZCkpIHtcbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgcmVzLnIgPSBtYXRjaFsxXSAvIDI1NTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdICE9PSB2b2lkIDApIHtcbiAgICAgIHJlcy5nID0gbWF0Y2hbMl0gLyAyNTU7XG4gICAgfVxuICAgIGlmIChtYXRjaFszXSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXMuYiA9IG1hdGNoWzNdIC8gMjU1O1xuICAgIH1cbiAgfSBlbHNlIGlmIChtYXRjaCA9IGNvbG9yLm1hdGNoKHJnYl9wZXJfb2xkKSkge1xuICAgIGlmIChtYXRjaFsxXSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXMuciA9IG1hdGNoWzFdIC8gMTAwO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMl0gIT09IHZvaWQgMCkge1xuICAgICAgcmVzLmcgPSBtYXRjaFsyXSAvIDEwMDtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzNdICE9PSB2b2lkIDApIHtcbiAgICAgIHJlcy5iID0gbWF0Y2hbM10gLyAxMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKG1hdGNoWzRdICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBtYXRjaFs0XSAvIDEwMCkpO1xuICB9IGVsc2UgaWYgKG1hdGNoWzVdICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCArbWF0Y2hbNV0pKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IHByZXBhcmUgPSAoY29sb3IsIG1vZGUpID0+IGNvbG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eXBlb2YgY29sb3IgIT09IFwib2JqZWN0XCIgPyBwYXJzZShjb2xvcikgOiBjb2xvci5tb2RlICE9PSB2b2lkIDAgPyBjb2xvciA6IG1vZGUgPyB7IC4uLmNvbG9yLCBtb2RlIH0gOiB2b2lkIDA7XG5jb25zdCBjb252ZXJ0ZXIgPSAodGFyZ2V0X21vZGUgPSBcInJnYlwiKSA9PiAoY29sb3IpID0+IChjb2xvciA9IHByZXBhcmUoY29sb3IsIHRhcmdldF9tb2RlKSkgIT09IHZvaWQgMCA/IChcbiAgLy8gaWYgdGhlIGNvbG9yJ3MgbW9kZSBjb3JyZXNwb25kcyB0byBvdXIgdGFyZ2V0IG1vZGVcbiAgY29sb3IubW9kZSA9PT0gdGFyZ2V0X21vZGUgPyAoXG4gICAgLy8gdGhlbiBqdXN0IHJldHVybiB0aGUgY29sb3JcbiAgICBjb2xvclxuICApIDogKFxuICAgIC8vIG90aGVyd2lzZSBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGRlZGljYXRlZFxuICAgIC8vIGNvbnZlcnRlciBmb3IgdGhlIHRhcmdldCBtb2RlXG4gICAgY29udmVydGVyc1tjb2xvci5tb2RlXVt0YXJnZXRfbW9kZV0gPyAoXG4gICAgICAvLyBhbmQgcmV0dXJuIGl0cyByZXN1bHQuLi5cbiAgICAgIGNvbnZlcnRlcnNbY29sb3IubW9kZV1bdGFyZ2V0X21vZGVdKGNvbG9yKVxuICAgICkgOiAoXG4gICAgICAvLyAuLi5vdGhlcndpc2UgcGFzcyB0aHJvdWdoIFJHQiBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcC5cbiAgICAgIC8vIGlmIHRoZSB0YXJnZXQgbW9kZSBpcyBSR0IuLi5cbiAgICAgIHRhcmdldF9tb2RlID09PSBcInJnYlwiID8gKFxuICAgICAgICAvLyBqdXN0IHJldHVybiB0aGUgUkdCXG4gICAgICAgIGNvbnZlcnRlcnNbY29sb3IubW9kZV0ucmdiKGNvbG9yKVxuICAgICAgKSA6IChcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNvbnZlcnQgY29sb3IubW9kZSAtPiBSR0IgLT4gdGFyZ2V0X21vZGVcbiAgICAgICAgY29udmVydGVycy5yZ2JbdGFyZ2V0X21vZGVdKGNvbnZlcnRlcnNbY29sb3IubW9kZV0ucmdiKGNvbG9yKSlcbiAgICAgIClcbiAgICApXG4gIClcbikgOiB2b2lkIDA7XG5jb25zdCBjb252ZXJ0ZXJzID0ge307XG5jb25zdCBtb2RlcyA9IHt9O1xuY29uc3QgcGFyc2VycyA9IFtdO1xuY29uc3QgY29sb3JQcm9maWxlcyA9IHt9O1xuY29uc3QgaWRlbnRpdHkgPSAodikgPT4gdjtcbmNvbnN0IHVzZU1vZGUgPSAoZGVmaW5pdGlvbjIpID0+IHtcbiAgY29udmVydGVyc1tkZWZpbml0aW9uMi5tb2RlXSA9IHtcbiAgICAuLi5jb252ZXJ0ZXJzW2RlZmluaXRpb24yLm1vZGVdLFxuICAgIC4uLmRlZmluaXRpb24yLnRvTW9kZVxuICB9O1xuICBPYmplY3Qua2V5cyhkZWZpbml0aW9uMi5mcm9tTW9kZSB8fCB7fSkuZm9yRWFjaCgoazIpID0+IHtcbiAgICBpZiAoIWNvbnZlcnRlcnNbazJdKSB7XG4gICAgICBjb252ZXJ0ZXJzW2syXSA9IHt9O1xuICAgIH1cbiAgICBjb252ZXJ0ZXJzW2syXVtkZWZpbml0aW9uMi5tb2RlXSA9IGRlZmluaXRpb24yLmZyb21Nb2RlW2syXTtcbiAgfSk7XG4gIGlmICghZGVmaW5pdGlvbjIucmFuZ2VzKSB7XG4gICAgZGVmaW5pdGlvbjIucmFuZ2VzID0ge307XG4gIH1cbiAgaWYgKCFkZWZpbml0aW9uMi5kaWZmZXJlbmNlKSB7XG4gICAgZGVmaW5pdGlvbjIuZGlmZmVyZW5jZSA9IHt9O1xuICB9XG4gIGRlZmluaXRpb24yLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICBpZiAoZGVmaW5pdGlvbjIucmFuZ2VzW2NoYW5uZWxdID09PSB2b2lkIDApIHtcbiAgICAgIGRlZmluaXRpb24yLnJhbmdlc1tjaGFubmVsXSA9IFswLCAxXTtcbiAgICB9XG4gICAgaWYgKCFkZWZpbml0aW9uMi5pbnRlcnBvbGF0ZVtjaGFubmVsXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGludGVycG9sYXRvciBmb3I6ICR7Y2hhbm5lbH1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uMi5pbnRlcnBvbGF0ZVtjaGFubmVsXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkZWZpbml0aW9uMi5pbnRlcnBvbGF0ZVtjaGFubmVsXSA9IHtcbiAgICAgICAgdXNlOiBkZWZpbml0aW9uMi5pbnRlcnBvbGF0ZVtjaGFubmVsXVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFkZWZpbml0aW9uMi5pbnRlcnBvbGF0ZVtjaGFubmVsXS5maXh1cCkge1xuICAgICAgZGVmaW5pdGlvbjIuaW50ZXJwb2xhdGVbY2hhbm5lbF0uZml4dXAgPSBpZGVudGl0eTtcbiAgICB9XG4gIH0pO1xuICBtb2Rlc1tkZWZpbml0aW9uMi5tb2RlXSA9IGRlZmluaXRpb24yO1xuICAoZGVmaW5pdGlvbjIucGFyc2UgfHwgW10pLmZvckVhY2goKHBhcnNlcikgPT4ge1xuICAgIHVzZVBhcnNlcihwYXJzZXIsIGRlZmluaXRpb24yLm1vZGUpO1xuICB9KTtcbiAgcmV0dXJuIGNvbnZlcnRlcihkZWZpbml0aW9uMi5tb2RlKTtcbn07XG5jb25zdCBnZXRNb2RlID0gKG1vZGUpID0+IG1vZGVzW21vZGVdO1xuY29uc3QgdXNlUGFyc2VyID0gKHBhcnNlciwgbW9kZSkgPT4ge1xuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICghbW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnbW9kZScgcmVxdWlyZWQgd2hlbiAncGFyc2VyJyBpcyBhIHN0cmluZ2ApO1xuICAgIH1cbiAgICBjb2xvclByb2ZpbGVzW3BhcnNlcl0gPSBtb2RlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJzZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmIChwYXJzZXJzLmluZGV4T2YocGFyc2VyKSA8IDApIHtcbiAgICAgIHBhcnNlcnMucHVzaChwYXJzZXIpO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IElkZW50U3RhcnRDb2RlUG9pbnQgPSAvW15cXHgwMC1cXHg3Rl18W2EtekEtWl9dLztcbmNvbnN0IElkZW50Q29kZVBvaW50ID0gL1teXFx4MDAtXFx4N0ZdfFstXFx3XS87XG5jb25zdCBUb2sgPSB7XG4gIEZ1bmN0aW9uOiBcImZ1bmN0aW9uXCIsXG4gIElkZW50OiBcImlkZW50XCIsXG4gIE51bWJlcjogXCJudW1iZXJcIixcbiAgUGVyY2VudGFnZTogXCJwZXJjZW50YWdlXCIsXG4gIFBhcmVuQ2xvc2U6IFwiKVwiLFxuICBOb25lOiBcIm5vbmVcIixcbiAgSHVlOiBcImh1ZVwiLFxuICBBbHBoYTogXCJhbHBoYVwiXG59O1xubGV0IF9pID0gMDtcbmZ1bmN0aW9uIGlzX251bShjaGFycykge1xuICBsZXQgY2ggPSBjaGFyc1tfaV07XG4gIGxldCBjaDEgPSBjaGFyc1tfaSArIDFdO1xuICBpZiAoY2ggPT09IFwiLVwiIHx8IGNoID09PSBcIitcIikge1xuICAgIHJldHVybiAvXFxkLy50ZXN0KGNoMSkgfHwgY2gxID09PSBcIi5cIiAmJiAvXFxkLy50ZXN0KGNoYXJzW19pICsgMl0pO1xuICB9XG4gIGlmIChjaCA9PT0gXCIuXCIpIHtcbiAgICByZXR1cm4gL1xcZC8udGVzdChjaDEpO1xuICB9XG4gIHJldHVybiAvXFxkLy50ZXN0KGNoKTtcbn1cbmZ1bmN0aW9uIGlzX2lkZW50KGNoYXJzKSB7XG4gIGlmIChfaSA+PSBjaGFycy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGNoID0gY2hhcnNbX2ldO1xuICBpZiAoSWRlbnRTdGFydENvZGVQb2ludC50ZXN0KGNoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChjaCA9PT0gXCItXCIpIHtcbiAgICBpZiAoY2hhcnMubGVuZ3RoIC0gX2kgPCAyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBjaDEgPSBjaGFyc1tfaSArIDFdO1xuICAgIGlmIChjaDEgPT09IFwiLVwiIHx8IElkZW50U3RhcnRDb2RlUG9pbnQudGVzdChjaDEpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IGh1ZW5pdHMgPSB7XG4gIGRlZzogMSxcbiAgcmFkOiAxODAgLyBNYXRoLlBJLFxuICBncmFkOiA5IC8gMTAsXG4gIHR1cm46IDM2MFxufTtcbmZ1bmN0aW9uIG51bShjaGFycykge1xuICBsZXQgdmFsdWUgPSBcIlwiO1xuICBpZiAoY2hhcnNbX2ldID09PSBcIi1cIiB8fCBjaGFyc1tfaV0gPT09IFwiK1wiKSB7XG4gICAgdmFsdWUgKz0gY2hhcnNbX2krK107XG4gIH1cbiAgdmFsdWUgKz0gZGlnaXRzKGNoYXJzKTtcbiAgaWYgKGNoYXJzW19pXSA9PT0gXCIuXCIgJiYgL1xcZC8udGVzdChjaGFyc1tfaSArIDFdKSkge1xuICAgIHZhbHVlICs9IGNoYXJzW19pKytdICsgZGlnaXRzKGNoYXJzKTtcbiAgfVxuICBpZiAoY2hhcnNbX2ldID09PSBcImVcIiB8fCBjaGFyc1tfaV0gPT09IFwiRVwiKSB7XG4gICAgaWYgKChjaGFyc1tfaSArIDFdID09PSBcIi1cIiB8fCBjaGFyc1tfaSArIDFdID09PSBcIitcIikgJiYgL1xcZC8udGVzdChjaGFyc1tfaSArIDJdKSkge1xuICAgICAgdmFsdWUgKz0gY2hhcnNbX2krK10gKyBjaGFyc1tfaSsrXSArIGRpZ2l0cyhjaGFycyk7XG4gICAgfSBlbHNlIGlmICgvXFxkLy50ZXN0KGNoYXJzW19pICsgMV0pKSB7XG4gICAgICB2YWx1ZSArPSBjaGFyc1tfaSsrXSArIGRpZ2l0cyhjaGFycyk7XG4gICAgfVxuICB9XG4gIGlmIChpc19pZGVudChjaGFycykpIHtcbiAgICBsZXQgaWQgPSBpZGVudChjaGFycyk7XG4gICAgaWYgKGlkID09PSBcImRlZ1wiIHx8IGlkID09PSBcInJhZFwiIHx8IGlkID09PSBcInR1cm5cIiB8fCBpZCA9PT0gXCJncmFkXCIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFRvay5IdWUsIHZhbHVlOiB2YWx1ZSAqIGh1ZW5pdHNbaWRdIH07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKGNoYXJzW19pXSA9PT0gXCIlXCIpIHtcbiAgICBfaSsrO1xuICAgIHJldHVybiB7IHR5cGU6IFRvay5QZXJjZW50YWdlLCB2YWx1ZTogK3ZhbHVlIH07XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogVG9rLk51bWJlciwgdmFsdWU6ICt2YWx1ZSB9O1xufVxuZnVuY3Rpb24gZGlnaXRzKGNoYXJzKSB7XG4gIGxldCB2ID0gXCJcIjtcbiAgd2hpbGUgKC9cXGQvLnRlc3QoY2hhcnNbX2ldKSkge1xuICAgIHYgKz0gY2hhcnNbX2krK107XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBpZGVudChjaGFycykge1xuICBsZXQgdiA9IFwiXCI7XG4gIHdoaWxlIChfaSA8IGNoYXJzLmxlbmd0aCAmJiBJZGVudENvZGVQb2ludC50ZXN0KGNoYXJzW19pXSkpIHtcbiAgICB2ICs9IGNoYXJzW19pKytdO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gaWRlbnRsaWtlKGNoYXJzKSB7XG4gIGxldCB2ID0gaWRlbnQoY2hhcnMpO1xuICBpZiAoY2hhcnNbX2ldID09PSBcIihcIikge1xuICAgIF9pKys7XG4gICAgcmV0dXJuIHsgdHlwZTogVG9rLkZ1bmN0aW9uLCB2YWx1ZTogdiB9O1xuICB9XG4gIGlmICh2ID09PSBcIm5vbmVcIikge1xuICAgIHJldHVybiB7IHR5cGU6IFRvay5Ob25lLCB2YWx1ZTogdm9pZCAwIH07XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogVG9rLklkZW50LCB2YWx1ZTogdiB9O1xufVxuZnVuY3Rpb24gdG9rZW5pemUoc3RyID0gXCJcIikge1xuICBsZXQgY2hhcnMgPSBzdHIudHJpbSgpO1xuICBsZXQgdG9rZW5zID0gW107XG4gIGxldCBjaDtcbiAgX2kgPSAwO1xuICB3aGlsZSAoX2kgPCBjaGFycy5sZW5ndGgpIHtcbiAgICBjaCA9IGNoYXJzW19pKytdO1xuICAgIGlmIChjaCA9PT0gXCJcXG5cIiB8fCBjaCA9PT0gXCJcdFwiIHx8IGNoID09PSBcIiBcIikge1xuICAgICAgd2hpbGUgKF9pIDwgY2hhcnMubGVuZ3RoICYmIChjaGFyc1tfaV0gPT09IFwiXFxuXCIgfHwgY2hhcnNbX2ldID09PSBcIlx0XCIgfHwgY2hhcnNbX2ldID09PSBcIiBcIikpIHtcbiAgICAgICAgX2krKztcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY2ggPT09IFwiLFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoY2ggPT09IFwiKVwiKSB7XG4gICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRvay5QYXJlbkNsb3NlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjaCA9PT0gXCIrXCIpIHtcbiAgICAgIF9pLS07XG4gICAgICBpZiAoaXNfbnVtKGNoYXJzKSkge1xuICAgICAgICB0b2tlbnMucHVzaChudW0oY2hhcnMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoY2ggPT09IFwiLVwiKSB7XG4gICAgICBfaS0tO1xuICAgICAgaWYgKGlzX251bShjaGFycykpIHtcbiAgICAgICAgdG9rZW5zLnB1c2gobnVtKGNoYXJzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzX2lkZW50KGNoYXJzKSkge1xuICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRvay5JZGVudCwgdmFsdWU6IGlkZW50KGNoYXJzKSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoY2ggPT09IFwiLlwiKSB7XG4gICAgICBfaS0tO1xuICAgICAgaWYgKGlzX251bShjaGFycykpIHtcbiAgICAgICAgdG9rZW5zLnB1c2gobnVtKGNoYXJzKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGNoID09PSBcIi9cIikge1xuICAgICAgd2hpbGUgKF9pIDwgY2hhcnMubGVuZ3RoICYmIChjaGFyc1tfaV0gPT09IFwiXFxuXCIgfHwgY2hhcnNbX2ldID09PSBcIlx0XCIgfHwgY2hhcnNbX2ldID09PSBcIiBcIikpIHtcbiAgICAgICAgX2krKztcbiAgICAgIH1cbiAgICAgIGxldCBhbHBoYTtcbiAgICAgIGlmIChpc19udW0oY2hhcnMpKSB7XG4gICAgICAgIGFscGhhID0gbnVtKGNoYXJzKTtcbiAgICAgICAgaWYgKGFscGhhLnR5cGUgIT09IFRvay5IdWUpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFRvay5BbHBoYSwgdmFsdWU6IGFscGhhIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNfaWRlbnQoY2hhcnMpKSB7XG4gICAgICAgIGlmIChpZGVudChjaGFycykgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogVG9rLkFscGhhLFxuICAgICAgICAgICAgdmFsdWU6IHsgdHlwZTogVG9rLk5vbmUsIHZhbHVlOiB2b2lkIDAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICAgIF9pLS07XG4gICAgICB0b2tlbnMucHVzaChudW0oY2hhcnMpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoSWRlbnRTdGFydENvZGVQb2ludC50ZXN0KGNoKSkge1xuICAgICAgX2ktLTtcbiAgICAgIHRva2Vucy5wdXNoKGlkZW50bGlrZShjaGFycykpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIHBhcnNlQ29sb3JTeW50YXgodG9rZW5zKSB7XG4gIHRva2Vucy5faSA9IDA7XG4gIGxldCB0b2tlbiA9IHRva2Vuc1t0b2tlbnMuX2krK107XG4gIGlmICghdG9rZW4gfHwgdG9rZW4udHlwZSAhPT0gVG9rLkZ1bmN0aW9uIHx8IHRva2VuLnZhbHVlICE9PSBcImNvbG9yXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHRva2VuID0gdG9rZW5zW3Rva2Vucy5faSsrXTtcbiAgaWYgKHRva2VuLnR5cGUgIT09IFRvay5JZGVudCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgbW9kZSA9IGNvbG9yUHJvZmlsZXNbdG9rZW4udmFsdWVdO1xuICBpZiAoIW1vZGUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHJlcyA9IHsgbW9kZSB9O1xuICBjb25zdCBjb29yZHMgPSBjb25zdW1lQ29vcmRzKHRva2VucywgZmFsc2UpO1xuICBpZiAoIWNvb3Jkcykge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgY2hhbm5lbHMgPSBnZXRNb2RlKG1vZGUpLmNoYW5uZWxzO1xuICBmb3IgKGxldCBpaSA9IDAsIGMyLCBjaDsgaWkgPCBjaGFubmVscy5sZW5ndGg7IGlpKyspIHtcbiAgICBjMiA9IGNvb3Jkc1tpaV07XG4gICAgY2ggPSBjaGFubmVsc1tpaV07XG4gICAgaWYgKGMyLnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgICByZXNbY2hdID0gYzIudHlwZSA9PT0gVG9rLk51bWJlciA/IGMyLnZhbHVlIDogYzIudmFsdWUgLyAxMDA7XG4gICAgICBpZiAoY2ggPT09IFwiYWxwaGFcIikge1xuICAgICAgICByZXNbY2hdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgcmVzW2NoXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29uc3VtZUNvb3Jkcyh0b2tlbnMsIGluY2x1ZGVIdWUpIHtcbiAgY29uc3QgY29vcmRzID0gW107XG4gIGxldCB0b2tlbjtcbiAgd2hpbGUgKHRva2Vucy5faSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMuX2krK107XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFRvay5Ob25lIHx8IHRva2VuLnR5cGUgPT09IFRvay5OdW1iZXIgfHwgdG9rZW4udHlwZSA9PT0gVG9rLkFscGhhIHx8IHRva2VuLnR5cGUgPT09IFRvay5QZXJjZW50YWdlIHx8IGluY2x1ZGVIdWUgJiYgdG9rZW4udHlwZSA9PT0gVG9rLkh1ZSkge1xuICAgICAgY29vcmRzLnB1c2godG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0b2tlbi50eXBlID09PSBUb2suUGFyZW5DbG9zZSkge1xuICAgICAgaWYgKHRva2Vucy5faSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChjb29yZHMubGVuZ3RoIDwgMyB8fCBjb29yZHMubGVuZ3RoID4gNCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKGNvb3Jkcy5sZW5ndGggPT09IDQpIHtcbiAgICBpZiAoY29vcmRzWzNdLnR5cGUgIT09IFRvay5BbHBoYSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29vcmRzWzNdID0gY29vcmRzWzNdLnZhbHVlO1xuICB9XG4gIGlmIChjb29yZHMubGVuZ3RoID09PSAzKSB7XG4gICAgY29vcmRzLnB1c2goeyB0eXBlOiBUb2suTm9uZSwgdmFsdWU6IHZvaWQgMCB9KTtcbiAgfVxuICByZXR1cm4gY29vcmRzLmV2ZXJ5KChjMikgPT4gYzIudHlwZSAhPT0gVG9rLkFscGhhKSA/IGNvb3JkcyA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHBhcnNlTW9kZXJuU3ludGF4KHRva2VucywgaW5jbHVkZUh1ZSkge1xuICB0b2tlbnMuX2kgPSAwO1xuICBsZXQgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLl9pKytdO1xuICBpZiAoIXRva2VuIHx8IHRva2VuLnR5cGUgIT09IFRvay5GdW5jdGlvbikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IGNvb3JkcyA9IGNvbnN1bWVDb29yZHModG9rZW5zLCBpbmNsdWRlSHVlKTtcbiAgaWYgKCFjb29yZHMpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvb3Jkcy51bnNoaWZ0KHRva2VuLnZhbHVlKTtcbiAgcmV0dXJuIGNvb3Jkcztcbn1cbmNvbnN0IHBhcnNlID0gKGNvbG9yKSA9PiB7XG4gIGlmICh0eXBlb2YgY29sb3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKGNvbG9yKTtcbiAgY29uc3QgcGFyc2VkID0gdG9rZW5zID8gcGFyc2VNb2Rlcm5TeW50YXgodG9rZW5zLCB0cnVlKSA6IHZvaWQgMDtcbiAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgbGVuID0gcGFyc2Vycy5sZW5ndGg7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgaWYgKChyZXN1bHQgPSBwYXJzZXJzW2krK10oY29sb3IsIHBhcnNlZCkpICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbnMgPyBwYXJzZUNvbG9yU3ludGF4KHRva2VucykgOiB2b2lkIDA7XG59O1xuZnVuY3Rpb24gcGFyc2VSZ2IoY29sb3IsIHBhcnNlZCkge1xuICBpZiAoIXBhcnNlZCB8fCBwYXJzZWRbMF0gIT09IFwicmdiXCIgJiYgcGFyc2VkWzBdICE9PSBcInJnYmFcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcmVzID0geyBtb2RlOiBcInJnYlwiIH07XG4gIGNvbnN0IFssIHIsIGcsIGIsIGFscGhhXSA9IHBhcnNlZDtcbiAgaWYgKHIudHlwZSA9PT0gVG9rLkh1ZSB8fCBnLnR5cGUgPT09IFRvay5IdWUgfHwgYi50eXBlID09PSBUb2suSHVlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoci50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIHJlcy5yID0gci50eXBlID09PSBUb2suTnVtYmVyID8gci52YWx1ZSAvIDI1NSA6IHIudmFsdWUgLyAxMDA7XG4gIH1cbiAgaWYgKGcudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICByZXMuZyA9IGcudHlwZSA9PT0gVG9rLk51bWJlciA/IGcudmFsdWUgLyAyNTUgOiBnLnZhbHVlIC8gMTAwO1xuICB9XG4gIGlmIChiLnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgcmVzLmIgPSBiLnR5cGUgPT09IFRvay5OdW1iZXIgPyBiLnZhbHVlIC8gMjU1IDogYi52YWx1ZSAvIDEwMDtcbiAgfVxuICBpZiAoYWxwaGEudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICByZXMuYWxwaGEgPSBNYXRoLm1pbihcbiAgICAgIDEsXG4gICAgICBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgYWxwaGEudHlwZSA9PT0gVG9rLk51bWJlciA/IGFscGhhLnZhbHVlIDogYWxwaGEudmFsdWUgLyAxMDBcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBwYXJzZVRyYW5zcGFyZW50ID0gKGMyKSA9PiBjMiA9PT0gXCJ0cmFuc3BhcmVudFwiID8geyBtb2RlOiBcInJnYlwiLCByOiAwLCBnOiAwLCBiOiAwLCBhbHBoYTogMCB9IDogdm9pZCAwO1xuY29uc3QgbGVycCA9IChhLCBiLCB0KSA9PiBhICsgdCAqIChiIC0gYSk7XG5jb25zdCBnZXRfY2xhc3NlcyA9IChhcnIpID0+IHtcbiAgbGV0IGNsYXNzZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgbGV0IGEgPSBhcnJbaV07XG4gICAgbGV0IGIgPSBhcnJbaSArIDFdO1xuICAgIGlmIChhID09PSB2b2lkIDAgJiYgYiA9PT0gdm9pZCAwKSB7XG4gICAgICBjbGFzc2VzLnB1c2godm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKGEgIT09IHZvaWQgMCAmJiBiICE9PSB2b2lkIDApIHtcbiAgICAgIGNsYXNzZXMucHVzaChbYSwgYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc2VzLnB1c2goYSAhPT0gdm9pZCAwID8gW2EsIGFdIDogW2IsIGJdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsYXNzZXM7XG59O1xuY29uc3QgaW50ZXJwb2xhdG9yUGllY2V3aXNlID0gKGludGVycG9sYXRvcikgPT4gKGFycikgPT4ge1xuICBsZXQgY2xhc3NlcyA9IGdldF9jbGFzc2VzKGFycik7XG4gIHJldHVybiAodCkgPT4ge1xuICAgIGxldCBjbHMgPSB0ICogY2xhc3Nlcy5sZW5ndGg7XG4gICAgbGV0IGlkeCA9IHQgPj0gMSA/IGNsYXNzZXMubGVuZ3RoIC0gMSA6IE1hdGgubWF4KE1hdGguZmxvb3IoY2xzKSwgMCk7XG4gICAgbGV0IHBhaXIgPSBjbGFzc2VzW2lkeF07XG4gICAgcmV0dXJuIHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVycG9sYXRvcihwYWlyWzBdLCBwYWlyWzFdLCBjbHMgLSBpZHgpO1xuICB9O1xufTtcbmNvbnN0IGludGVycG9sYXRvckxpbmVhciA9IGludGVycG9sYXRvclBpZWNld2lzZShsZXJwKTtcbmNvbnN0IGZpeHVwQWxwaGEgPSAoYXJyKSA9PiB7XG4gIGxldCBzb21lX2RlZmluZWQgPSBmYWxzZTtcbiAgbGV0IHJlcyA9IGFyci5tYXAoKHYpID0+IHtcbiAgICBpZiAodiAhPT0gdm9pZCAwKSB7XG4gICAgICBzb21lX2RlZmluZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9KTtcbiAgcmV0dXJuIHNvbWVfZGVmaW5lZCA/IHJlcyA6IGFycjtcbn07XG5jb25zdCBkZWZpbml0aW9uJHIgPSB7XG4gIG1vZGU6IFwicmdiXCIsXG4gIGNoYW5uZWxzOiBbXCJyXCIsIFwiZ1wiLCBcImJcIiwgXCJhbHBoYVwiXSxcbiAgcGFyc2U6IFtcbiAgICBwYXJzZVJnYixcbiAgICBwYXJzZUhleCxcbiAgICBwYXJzZVJnYkxlZ2FjeSxcbiAgICBwYXJzZU5hbWVkLFxuICAgIHBhcnNlVHJhbnNwYXJlbnQsXG4gICAgXCJzcmdiXCJcbiAgXSxcbiAgc2VyaWFsaXplOiBcInNyZ2JcIixcbiAgaW50ZXJwb2xhdGU6IHtcbiAgICByOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgZzogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGI6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhbHBoYTogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwQWxwaGEgfVxuICB9LFxuICBnYW11dDogdHJ1ZSxcbiAgd2hpdGU6IHsgcjogMSwgZzogMSwgYjogMSB9LFxuICBibGFjazogeyByOiAwLCBnOiAwLCBiOiAwIH1cbn07XG5jb25zdCBsaW5lYXJpemUkMiA9ICh2ID0gMCkgPT4gTWF0aC5wb3coTWF0aC5hYnModiksIDU2MyAvIDI1NikgKiBNYXRoLnNpZ24odik7XG5jb25zdCBjb252ZXJ0QTk4VG9YeXo2NSA9IChhOTgpID0+IHtcbiAgbGV0IHIgPSBsaW5lYXJpemUkMihhOTgucik7XG4gIGxldCBnID0gbGluZWFyaXplJDIoYTk4LmcpO1xuICBsZXQgYiA9IGxpbmVhcml6ZSQyKGE5OC5iKTtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcInh5ejY1XCIsXG4gICAgeDogMC41NzY2NjkwNDI5MTAxMzA1ICogciArIDAuMTg1NTU4MjM3OTA2NTQ2MyAqIGcgKyAwLjE4ODIyODY0NjIzNDk5NDcgKiBiLFxuICAgIHk6IDAuMjk3MzQ0OTc1MjUwNTM2ICogciArIDAuNjI3MzYzNTY2MjU1NDY2MSAqIGcgKyAwLjA3NTI5MTQ1ODQ5Mzk5NzkgKiBiLFxuICAgIHo6IDAuMDI3MDMxMzYxMzg2NDEyMyAqIHIgKyAwLjA3MDY4ODg1MjUzNTgyNzIgKiBnICsgMC45OTEzMzc1MzY4Mzc2Mzg2ICogYlxuICB9O1xuICBpZiAoYTk4LmFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBhOTguYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBnYW1tYSQyID0gKHYpID0+IE1hdGgucG93KE1hdGguYWJzKHYpLCAyNTYgLyA1NjMpICogTWF0aC5zaWduKHYpO1xuY29uc3QgY29udmVydFh5ejY1VG9BOTggPSAoeyB4LCB5LCB6LCBhbHBoYSB9KSA9PiB7XG4gIGlmICh4ID09PSB2b2lkIDApIHggPSAwO1xuICBpZiAoeSA9PT0gdm9pZCAwKSB5ID0gMDtcbiAgaWYgKHogPT09IHZvaWQgMCkgeiA9IDA7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJhOThcIixcbiAgICByOiBnYW1tYSQyKFxuICAgICAgeCAqIDIuMDQxNTg3OTAzODEwNzQ2NSAtIHkgKiAwLjU2NTAwNjk3NDI3ODg1OTcgLSAwLjM0NDczMTM1MDc3ODMyOTcgKiB6XG4gICAgKSxcbiAgICBnOiBnYW1tYSQyKFxuICAgICAgeCAqIC0wLjk2OTI0MzYzNjI4MDg3OTggKyB5ICogMS44NzU5Njc1MDE1MDc3MjA2ICsgMC4wNDE1NTUwNTc0MDcxNzU2ICogelxuICAgICksXG4gICAgYjogZ2FtbWEkMihcbiAgICAgIHggKiAwLjAxMzQ0NDI4MDYzMjAzMTIgLSB5ICogMC4xMTgzNjIzOTIyMzEwMTg0ICsgMS4wMTUxNzQ5OTQzOTEyMDU4ICogelxuICAgIClcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBhbHBoYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZuJDMgPSAoYzIgPSAwKSA9PiB7XG4gIGNvbnN0IGFiczIgPSBNYXRoLmFicyhjMik7XG4gIGlmIChhYnMyIDw9IDAuMDQwNDUpIHtcbiAgICByZXR1cm4gYzIgLyAxMi45MjtcbiAgfVxuICByZXR1cm4gKE1hdGguc2lnbihjMikgfHwgMSkgKiBNYXRoLnBvdygoYWJzMiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xufTtcbmNvbnN0IGNvbnZlcnRSZ2JUb0xyZ2IgPSAoeyByLCBnLCBiLCBhbHBoYSB9KSA9PiB7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJscmdiXCIsXG4gICAgcjogZm4kMyhyKSxcbiAgICBnOiBmbiQzKGcpLFxuICAgIGI6IGZuJDMoYilcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHJlcy5hbHBoYSA9IGFscGhhO1xuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGNvbnZlcnRSZ2JUb1h5ejY1ID0gKHJnYikgPT4ge1xuICBsZXQgeyByLCBnLCBiLCBhbHBoYSB9ID0gY29udmVydFJnYlRvTHJnYihyZ2IpO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwieHl6NjVcIixcbiAgICB4OiAwLjQxMjM5MDc5OTI2NTk1OTMgKiByICsgMC4zNTc1ODQzMzkzODM4NzggKiBnICsgMC4xODA0ODA3ODg0MDE4MzQzICogYixcbiAgICB5OiAwLjIxMjYzOTAwNTg3MTUxMDIgKiByICsgMC43MTUxNjg2Nzg3Njc3NTYgKiBnICsgMC4wNzIxOTIzMTUzNjA3MzM3ICogYixcbiAgICB6OiAwLjAxOTMzMDgxODcxNTU5MTggKiByICsgMC4xMTkxOTQ3Nzk3OTQ2MjYgKiBnICsgMC45NTA1MzIxNTIyNDk2NjA3ICogYlxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZm4kMiA9IChjMiA9IDApID0+IHtcbiAgY29uc3QgYWJzMiA9IE1hdGguYWJzKGMyKTtcbiAgaWYgKGFiczIgPiAzMTMwOGUtNykge1xuICAgIHJldHVybiAoTWF0aC5zaWduKGMyKSB8fCAxKSAqICgxLjA1NSAqIE1hdGgucG93KGFiczIsIDEgLyAyLjQpIC0gMC4wNTUpO1xuICB9XG4gIHJldHVybiBjMiAqIDEyLjkyO1xufTtcbmNvbnN0IGNvbnZlcnRMcmdiVG9SZ2IgPSAoeyByLCBnLCBiLCBhbHBoYSB9LCBtb2RlID0gXCJyZ2JcIikgPT4ge1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGUsXG4gICAgcjogZm4kMihyKSxcbiAgICBnOiBmbiQyKGcpLFxuICAgIGI6IGZuJDIoYilcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHJlcy5hbHBoYSA9IGFscGhhO1xuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGNvbnZlcnRYeXo2NVRvUmdiID0gKHsgeCwgeSwgeiwgYWxwaGEgfSkgPT4ge1xuICBpZiAoeCA9PT0gdm9pZCAwKSB4ID0gMDtcbiAgaWYgKHkgPT09IHZvaWQgMCkgeSA9IDA7XG4gIGlmICh6ID09PSB2b2lkIDApIHogPSAwO1xuICBsZXQgcmVzID0gY29udmVydExyZ2JUb1JnYih7XG4gICAgcjogeCAqIDMuMjQwOTY5OTQxOTA0NTIyNiAtIHkgKiAxLjUzNzM4MzE3NzU3MDA5NCAtIDAuNDk4NjEwNzYwMjkzMDAzNCAqIHosXG4gICAgZzogeCAqIC0wLjk2OTI0MzYzNjI4MDg3OTYgKyB5ICogMS44NzU5Njc1MDE1MDc3MjA0ICsgMC4wNDE1NTUwNTc0MDcxNzU2ICogeixcbiAgICBiOiB4ICogMC4wNTU2MzAwNzk2OTY5OTM2IC0geSAqIDAuMjAzOTc2OTU4ODg4OTc2NSArIDEuMDU2OTcxNTE0MjQyODc4NCAqIHpcbiAgfSk7XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBkZWZpbml0aW9uJHEgPSB7XG4gIC4uLmRlZmluaXRpb24kcixcbiAgbW9kZTogXCJhOThcIixcbiAgcGFyc2U6IFtcImE5OC1yZ2JcIl0sXG4gIHNlcmlhbGl6ZTogXCJhOTgtcmdiXCIsXG4gIGZyb21Nb2RlOiB7XG4gICAgcmdiOiAoY29sb3IpID0+IGNvbnZlcnRYeXo2NVRvQTk4KGNvbnZlcnRSZ2JUb1h5ejY1KGNvbG9yKSksXG4gICAgeHl6NjU6IGNvbnZlcnRYeXo2NVRvQTk4XG4gIH0sXG4gIHRvTW9kZToge1xuICAgIHJnYjogKGNvbG9yKSA9PiBjb252ZXJ0WHl6NjVUb1JnYihjb252ZXJ0QTk4VG9YeXo2NShjb2xvcikpLFxuICAgIHh5ejY1OiBjb252ZXJ0QTk4VG9YeXo2NVxuICB9XG59O1xuY29uc3Qgbm9ybWFsaXplSHVlID0gKGh1ZTIpID0+IChodWUyID0gaHVlMiAlIDM2MCkgPCAwID8gaHVlMiArIDM2MCA6IGh1ZTI7XG5jb25zdCBodWUgPSAoaHVlcywgZm4yKSA9PiB7XG4gIHJldHVybiBodWVzLm1hcCgoaHVlMiwgaWR4LCBhcnIpID0+IHtcbiAgICBpZiAoaHVlMiA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gaHVlMjtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemVIdWUoaHVlMik7XG4gICAgaWYgKGlkeCA9PT0gMCB8fCBodWVzW2lkeCAtIDFdID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH1cbiAgICByZXR1cm4gZm4yKG5vcm1hbGl6ZWQgLSBub3JtYWxpemVIdWUoYXJyW2lkeCAtIDFdKSk7XG4gIH0pLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgaWYgKCFhY2MubGVuZ3RoIHx8IGN1cnIgPT09IHZvaWQgMCB8fCBhY2NbYWNjLmxlbmd0aCAtIDFdID09PSB2b2lkIDApIHtcbiAgICAgIGFjYy5wdXNoKGN1cnIpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgYWNjLnB1c2goY3VyciArIGFjY1thY2MubGVuZ3RoIC0gMV0pO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbn07XG5jb25zdCBmaXh1cEh1ZVNob3J0ZXIgPSAoYXJyKSA9PiBodWUoYXJyLCAoZCkgPT4gTWF0aC5hYnMoZCkgPD0gMTgwID8gZCA6IGQgLSAzNjAgKiBNYXRoLnNpZ24oZCkpO1xuY29uc3QgTSA9IFstMC4xNDg2MSwgMS43ODI3NywgLTAuMjkyMjcsIC0wLjkwNjQ5LCAxLjk3Mjk0LCAwXTtcbmNvbnN0IGRlZ1RvUmFkID0gTWF0aC5QSSAvIDE4MDtcbmNvbnN0IHJhZFRvRGVnID0gMTgwIC8gTWF0aC5QSTtcbmxldCBERSA9IE1bM10gKiBNWzRdO1xubGV0IEJFID0gTVsxXSAqIE1bNF07XG5sZXQgQkNBRCA9IE1bMV0gKiBNWzJdIC0gTVswXSAqIE1bM107XG5jb25zdCBjb252ZXJ0UmdiVG9DdWJlaGVsaXggPSAoeyByLCBnLCBiLCBhbHBoYSB9KSA9PiB7XG4gIGlmIChyID09PSB2b2lkIDApIHIgPSAwO1xuICBpZiAoZyA9PT0gdm9pZCAwKSBnID0gMDtcbiAgaWYgKGIgPT09IHZvaWQgMCkgYiA9IDA7XG4gIGxldCBsID0gKEJDQUQgKiBiICsgciAqIERFIC0gZyAqIEJFKSAvIChCQ0FEICsgREUgLSBCRSk7XG4gIGxldCB4ID0gYiAtIGw7XG4gIGxldCB5ID0gKE1bNF0gKiAoZyAtIGwpIC0gTVsyXSAqIHgpIC8gTVszXTtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcImN1YmVoZWxpeFwiLFxuICAgIGwsXG4gICAgczogbCA9PT0gMCB8fCBsID09PSAxID8gdm9pZCAwIDogTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpIC8gKE1bNF0gKiBsICogKDEgLSBsKSlcbiAgfTtcbiAgaWYgKHJlcy5zKSByZXMuaCA9IE1hdGguYXRhbjIoeSwgeCkgKiByYWRUb0RlZyAtIDEyMDtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHJlcy5hbHBoYSA9IGFscGhhO1xuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGNvbnZlcnRDdWJlaGVsaXhUb1JnYiA9ICh7IGgsIHMsIGwsIGFscGhhIH0pID0+IHtcbiAgbGV0IHJlcyA9IHsgbW9kZTogXCJyZ2JcIiB9O1xuICBoID0gKGggPT09IHZvaWQgMCA/IDAgOiBoICsgMTIwKSAqIGRlZ1RvUmFkO1xuICBpZiAobCA9PT0gdm9pZCAwKSBsID0gMDtcbiAgbGV0IGFtcCA9IHMgPT09IHZvaWQgMCA/IDAgOiBzICogbCAqICgxIC0gbCk7XG4gIGxldCBjb3NoID0gTWF0aC5jb3MoaCk7XG4gIGxldCBzaW5oID0gTWF0aC5zaW4oaCk7XG4gIHJlcy5yID0gbCArIGFtcCAqIChNWzBdICogY29zaCArIE1bMV0gKiBzaW5oKTtcbiAgcmVzLmcgPSBsICsgYW1wICogKE1bMl0gKiBjb3NoICsgTVszXSAqIHNpbmgpO1xuICByZXMuYiA9IGwgKyBhbXAgKiAoTVs0XSAqIGNvc2ggKyBNWzVdICogc2luaCk7XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSByZXMuYWxwaGEgPSBhbHBoYTtcbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBkaWZmZXJlbmNlSHVlU2F0dXJhdGlvbiA9IChzdGQsIHNtcCkgPT4ge1xuICBpZiAoc3RkLmggPT09IHZvaWQgMCB8fCBzbXAuaCA9PT0gdm9pZCAwIHx8ICFzdGQucyB8fCAhc21wLnMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgc3RkX2ggPSBub3JtYWxpemVIdWUoc3RkLmgpO1xuICBsZXQgc21wX2ggPSBub3JtYWxpemVIdWUoc21wLmgpO1xuICBsZXQgZEggPSBNYXRoLnNpbigoc21wX2ggLSBzdGRfaCArIDM2MCkgLyAyICogTWF0aC5QSSAvIDE4MCk7XG4gIHJldHVybiAyICogTWF0aC5zcXJ0KHN0ZC5zICogc21wLnMpICogZEg7XG59O1xuY29uc3QgZGlmZmVyZW5jZUh1ZU5haXZlID0gKHN0ZCwgc21wKSA9PiB7XG4gIGlmIChzdGQuaCA9PT0gdm9pZCAwIHx8IHNtcC5oID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgc3RkX2ggPSBub3JtYWxpemVIdWUoc3RkLmgpO1xuICBsZXQgc21wX2ggPSBub3JtYWxpemVIdWUoc21wLmgpO1xuICBpZiAoTWF0aC5hYnMoc21wX2ggLSBzdGRfaCkgPiAxODApIHtcbiAgICByZXR1cm4gc3RkX2ggLSAoc21wX2ggLSAzNjAgKiBNYXRoLnNpZ24oc21wX2ggLSBzdGRfaCkpO1xuICB9XG4gIHJldHVybiBzbXBfaCAtIHN0ZF9oO1xufTtcbmNvbnN0IGRpZmZlcmVuY2VIdWVDaHJvbWEgPSAoc3RkLCBzbXApID0+IHtcbiAgaWYgKHN0ZC5oID09PSB2b2lkIDAgfHwgc21wLmggPT09IHZvaWQgMCB8fCAhc3RkLmMgfHwgIXNtcC5jKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IHN0ZF9oID0gbm9ybWFsaXplSHVlKHN0ZC5oKTtcbiAgbGV0IHNtcF9oID0gbm9ybWFsaXplSHVlKHNtcC5oKTtcbiAgbGV0IGRIID0gTWF0aC5zaW4oKHNtcF9oIC0gc3RkX2ggKyAzNjApIC8gMiAqIE1hdGguUEkgLyAxODApO1xuICByZXR1cm4gMiAqIE1hdGguc3FydChzdGQuYyAqIHNtcC5jKSAqIGRIO1xufTtcbmNvbnN0IGF2ZXJhZ2VBbmdsZSA9ICh2YWwpID0+IHtcbiAgbGV0IHN1bSA9IHZhbC5yZWR1Y2UoXG4gICAgKHN1bTIsIHZhbDIpID0+IHtcbiAgICAgIGlmICh2YWwyICE9PSB2b2lkIDApIHtcbiAgICAgICAgbGV0IHJhZCA9IHZhbDIgKiBNYXRoLlBJIC8gMTgwO1xuICAgICAgICBzdW0yLnNpbiArPSBNYXRoLnNpbihyYWQpO1xuICAgICAgICBzdW0yLmNvcyArPSBNYXRoLmNvcyhyYWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bTI7XG4gICAgfSxcbiAgICB7IHNpbjogMCwgY29zOiAwIH1cbiAgKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihzdW0uc2luLCBzdW0uY29zKSAqIDE4MCAvIE1hdGguUEk7XG4gIHJldHVybiBhbmdsZSA8IDAgPyAzNjAgKyBhbmdsZSA6IGFuZ2xlO1xufTtcbmNvbnN0IGRlZmluaXRpb24kcCA9IHtcbiAgbW9kZTogXCJjdWJlaGVsaXhcIixcbiAgY2hhbm5lbHM6IFtcImhcIiwgXCJzXCIsIFwibFwiLCBcImFscGhhXCJdLFxuICBwYXJzZTogW1wiLS1jdWJlaGVsaXhcIl0sXG4gIHNlcmlhbGl6ZTogXCItLWN1YmVoZWxpeFwiLFxuICByYW5nZXM6IHtcbiAgICBoOiBbMCwgMzYwXSxcbiAgICBzOiBbMCwgNC42MTRdLFxuICAgIGw6IFswLCAxXVxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHJnYjogY29udmVydFJnYlRvQ3ViZWhlbGl4XG4gIH0sXG4gIHRvTW9kZToge1xuICAgIHJnYjogY29udmVydEN1YmVoZWxpeFRvUmdiXG4gIH0sXG4gIGludGVycG9sYXRlOiB7XG4gICAgaDoge1xuICAgICAgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgICBmaXh1cDogZml4dXBIdWVTaG9ydGVyXG4gICAgfSxcbiAgICBzOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgbDogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGFscGhhOiB7XG4gICAgICB1c2U6IGludGVycG9sYXRvckxpbmVhcixcbiAgICAgIGZpeHVwOiBmaXh1cEFscGhhXG4gICAgfVxuICB9LFxuICBkaWZmZXJlbmNlOiB7XG4gICAgaDogZGlmZmVyZW5jZUh1ZVNhdHVyYXRpb25cbiAgfSxcbiAgYXZlcmFnZToge1xuICAgIGg6IGF2ZXJhZ2VBbmdsZVxuICB9XG59O1xuY29uc3QgY29udmVydExhYlRvTGNoID0gKHsgbCwgYSwgYiwgYWxwaGEgfSwgbW9kZSA9IFwibGNoXCIpID0+IHtcbiAgaWYgKGEgPT09IHZvaWQgMCkgYSA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBsZXQgYzIgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gIGxldCByZXMgPSB7IG1vZGUsIGwsIGM6IGMyIH07XG4gIGlmIChjMikgcmVzLmggPSBub3JtYWxpemVIdWUoTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEkpO1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydExjaFRvTGFiID0gKHsgbCwgYzogYzIsIGgsIGFscGhhIH0sIG1vZGUgPSBcImxhYlwiKSA9PiB7XG4gIGlmIChoID09PSB2b2lkIDApIGggPSAwO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGUsXG4gICAgbCxcbiAgICBhOiBjMiA/IGMyICogTWF0aC5jb3MoaCAvIDE4MCAqIE1hdGguUEkpIDogMCxcbiAgICBiOiBjMiA/IGMyICogTWF0aC5zaW4oaCAvIDE4MCAqIE1hdGguUEkpIDogMFxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgayQxID0gTWF0aC5wb3coMjksIDMpIC8gTWF0aC5wb3coMywgMyk7XG5jb25zdCBlJDEgPSBNYXRoLnBvdyg2LCAzKSAvIE1hdGgucG93KDI5LCAzKTtcbmNvbnN0IEQ1MCA9IHtcbiAgWDogMC4zNDU3IC8gMC4zNTg1LFxuICBZOiAxLFxuICBaOiAoMSAtIDAuMzQ1NyAtIDAuMzU4NSkgLyAwLjM1ODVcbn07XG5jb25zdCBENjUgPSB7XG4gIFg6IDAuMzEyNyAvIDAuMzI5LFxuICBZOiAxLFxuICBaOiAoMSAtIDAuMzEyNyAtIDAuMzI5KSAvIDAuMzI5XG59O1xubGV0IGZuJDEgPSAodikgPT4gTWF0aC5wb3codiwgMykgPiBlJDEgPyBNYXRoLnBvdyh2LCAzKSA6ICgxMTYgKiB2IC0gMTYpIC8gayQxO1xuY29uc3QgY29udmVydExhYjY1VG9YeXo2NSA9ICh7IGwsIGEsIGIsIGFscGhhIH0pID0+IHtcbiAgaWYgKGwgPT09IHZvaWQgMCkgbCA9IDA7XG4gIGlmIChhID09PSB2b2lkIDApIGEgPSAwO1xuICBpZiAoYiA9PT0gdm9pZCAwKSBiID0gMDtcbiAgbGV0IGZ5ID0gKGwgKyAxNikgLyAxMTY7XG4gIGxldCBmeCA9IGEgLyA1MDAgKyBmeTtcbiAgbGV0IGZ6ID0gZnkgLSBiIC8gMjAwO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwieHl6NjVcIixcbiAgICB4OiBmbiQxKGZ4KSAqIEQ2NS5YLFxuICAgIHk6IGZuJDEoZnkpICogRDY1LlksXG4gICAgejogZm4kMShmeikgKiBENjUuWlxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydExhYjY1VG9SZ2IgPSAobGFiKSA9PiBjb252ZXJ0WHl6NjVUb1JnYihjb252ZXJ0TGFiNjVUb1h5ejY1KGxhYikpO1xuY29uc3QgZiQxID0gKHZhbHVlKSA9PiB2YWx1ZSA+IGUkMSA/IE1hdGguY2JydCh2YWx1ZSkgOiAoayQxICogdmFsdWUgKyAxNikgLyAxMTY7XG5jb25zdCBjb252ZXJ0WHl6NjVUb0xhYjY1ID0gKHsgeCwgeSwgeiwgYWxwaGEgfSkgPT4ge1xuICBpZiAoeCA9PT0gdm9pZCAwKSB4ID0gMDtcbiAgaWYgKHkgPT09IHZvaWQgMCkgeSA9IDA7XG4gIGlmICh6ID09PSB2b2lkIDApIHogPSAwO1xuICBsZXQgZjAgPSBmJDEoeCAvIEQ2NS5YKTtcbiAgbGV0IGYxID0gZiQxKHkgLyBENjUuWSk7XG4gIGxldCBmMiA9IGYkMSh6IC8gRDY1LlopO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwibGFiNjVcIixcbiAgICBsOiAxMTYgKiBmMSAtIDE2LFxuICAgIGE6IDUwMCAqIChmMCAtIGYxKSxcbiAgICBiOiAyMDAgKiAoZjEgLSBmMilcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBhbHBoYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGNvbnZlcnRSZ2JUb0xhYjY1ID0gKHJnYikgPT4ge1xuICBsZXQgcmVzID0gY29udmVydFh5ejY1VG9MYWI2NShjb252ZXJ0UmdiVG9YeXo2NShyZ2IpKTtcbiAgaWYgKHJnYi5yID09PSByZ2IuYiAmJiByZ2IuYiA9PT0gcmdiLmcpIHtcbiAgICByZXMuYSA9IHJlcy5iID0gMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGtFID0gMTtcbmNvbnN0IGtDSCA9IDE7XG5jb25zdCDOuCA9IDI2IC8gMTgwICogTWF0aC5QSTtcbmNvbnN0IGNvc864ID0gTWF0aC5jb3MozrgpO1xuY29uc3Qgc2luzrggPSBNYXRoLnNpbijOuCk7XG5jb25zdCBmYWN0b3IgPSAxMDAgLyBNYXRoLmxvZygxMzkgLyAxMDApO1xuY29uc3QgY29udmVydERsY2hUb0xhYjY1ID0gKHsgbCwgYzogYzIsIGgsIGFscGhhIH0pID0+IHtcbiAgaWYgKGwgPT09IHZvaWQgMCkgbCA9IDA7XG4gIGlmIChjMiA9PT0gdm9pZCAwKSBjMiA9IDA7XG4gIGlmIChoID09PSB2b2lkIDApIGggPSAwO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwibGFiNjVcIixcbiAgICBsOiAoTWF0aC5leHAobCAqIGtFIC8gZmFjdG9yKSAtIDEpIC8gMzllLTRcbiAgfTtcbiAgbGV0IEcgPSAoTWF0aC5leHAoMC4wNDM1ICogYzIgKiBrQ0ggKiBrRSkgLSAxKSAvIDAuMDc1O1xuICBsZXQgZTIgPSBHICogTWF0aC5jb3MoaCAvIDE4MCAqIE1hdGguUEkgLSDOuCk7XG4gIGxldCBmMiA9IEcgKiBNYXRoLnNpbihoIC8gMTgwICogTWF0aC5QSSAtIM64KTtcbiAgcmVzLmEgPSBlMiAqIGNvc864IC0gZjIgLyAwLjgzICogc2luzrg7XG4gIHJlcy5iID0gZTIgKiBzaW7OuCArIGYyIC8gMC44MyAqIGNvc864O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydExhYjY1VG9EbGNoID0gKHsgbCwgYSwgYiwgYWxwaGEgfSkgPT4ge1xuICBpZiAobCA9PT0gdm9pZCAwKSBsID0gMDtcbiAgaWYgKGEgPT09IHZvaWQgMCkgYSA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBsZXQgZTIgPSBhICogY29zzrggKyBiICogc2luzrg7XG4gIGxldCBmMiA9IDAuODMgKiAoYiAqIGNvc864IC0gYSAqIHNpbs64KTtcbiAgbGV0IEcgPSBNYXRoLnNxcnQoZTIgKiBlMiArIGYyICogZjIpO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwiZGxjaFwiLFxuICAgIGw6IGZhY3RvciAvIGtFICogTWF0aC5sb2coMSArIDM5ZS00ICogbCksXG4gICAgYzogTWF0aC5sb2coMSArIDAuMDc1ICogRykgLyAoMC4wNDM1ICoga0NIICoga0UpXG4gIH07XG4gIGlmIChyZXMuYykge1xuICAgIHJlcy5oID0gbm9ybWFsaXplSHVlKChNYXRoLmF0YW4yKGYyLCBlMikgKyDOuCkgLyBNYXRoLlBJICogMTgwKTtcbiAgfVxuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydERsYWJUb0xhYjY1ID0gKGMyKSA9PiBjb252ZXJ0RGxjaFRvTGFiNjUoY29udmVydExhYlRvTGNoKGMyLCBcImRsY2hcIikpO1xuY29uc3QgY29udmVydExhYjY1VG9EbGFiID0gKGMyKSA9PiBjb252ZXJ0TGNoVG9MYWIoY29udmVydExhYjY1VG9EbGNoKGMyKSwgXCJkbGFiXCIpO1xuY29uc3QgZGVmaW5pdGlvbiRvID0ge1xuICBtb2RlOiBcImRsYWJcIixcbiAgcGFyc2U6IFtcIi0tZGluOTlvLWxhYlwiXSxcbiAgc2VyaWFsaXplOiBcIi0tZGluOTlvLWxhYlwiLFxuICB0b01vZGU6IHtcbiAgICBsYWI2NTogY29udmVydERsYWJUb0xhYjY1LFxuICAgIHJnYjogKGMyKSA9PiBjb252ZXJ0TGFiNjVUb1JnYihjb252ZXJ0RGxhYlRvTGFiNjUoYzIpKVxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIGxhYjY1OiBjb252ZXJ0TGFiNjVUb0RsYWIsXG4gICAgcmdiOiAoYzIpID0+IGNvbnZlcnRMYWI2NVRvRGxhYihjb252ZXJ0UmdiVG9MYWI2NShjMikpXG4gIH0sXG4gIGNoYW5uZWxzOiBbXCJsXCIsIFwiYVwiLCBcImJcIiwgXCJhbHBoYVwiXSxcbiAgcmFuZ2VzOiB7XG4gICAgbDogWzAsIDEwMF0sXG4gICAgYTogWy00MC4wOSwgNDUuNTAxXSxcbiAgICBiOiBbLTQwLjQ2OSwgNDQuMzQ0XVxuICB9LFxuICBpbnRlcnBvbGF0ZToge1xuICAgIGw6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYjogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGFscGhhOiB7XG4gICAgICB1c2U6IGludGVycG9sYXRvckxpbmVhcixcbiAgICAgIGZpeHVwOiBmaXh1cEFscGhhXG4gICAgfVxuICB9XG59O1xuY29uc3QgZGVmaW5pdGlvbiRuID0ge1xuICBtb2RlOiBcImRsY2hcIixcbiAgcGFyc2U6IFtcIi0tZGluOTlvLWxjaFwiXSxcbiAgc2VyaWFsaXplOiBcIi0tZGluOTlvLWxjaFwiLFxuICB0b01vZGU6IHtcbiAgICBsYWI2NTogY29udmVydERsY2hUb0xhYjY1LFxuICAgIGRsYWI6IChjMikgPT4gY29udmVydExjaFRvTGFiKGMyLCBcImRsYWJcIiksXG4gICAgcmdiOiAoYzIpID0+IGNvbnZlcnRMYWI2NVRvUmdiKGNvbnZlcnREbGNoVG9MYWI2NShjMikpXG4gIH0sXG4gIGZyb21Nb2RlOiB7XG4gICAgbGFiNjU6IGNvbnZlcnRMYWI2NVRvRGxjaCxcbiAgICBkbGFiOiAoYzIpID0+IGNvbnZlcnRMYWJUb0xjaChjMiwgXCJkbGNoXCIpLFxuICAgIHJnYjogKGMyKSA9PiBjb252ZXJ0TGFiNjVUb0RsY2goY29udmVydFJnYlRvTGFiNjUoYzIpKVxuICB9LFxuICBjaGFubmVsczogW1wibFwiLCBcImNcIiwgXCJoXCIsIFwiYWxwaGFcIl0sXG4gIHJhbmdlczoge1xuICAgIGw6IFswLCAxMDBdLFxuICAgIGM6IFswLCA1MS40ODRdLFxuICAgIGg6IFswLCAzNjBdXG4gIH0sXG4gIGludGVycG9sYXRlOiB7XG4gICAgbDogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGM6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBoOiB7XG4gICAgICB1c2U6IGludGVycG9sYXRvckxpbmVhcixcbiAgICAgIGZpeHVwOiBmaXh1cEh1ZVNob3J0ZXJcbiAgICB9LFxuICAgIGFscGhhOiB7XG4gICAgICB1c2U6IGludGVycG9sYXRvckxpbmVhcixcbiAgICAgIGZpeHVwOiBmaXh1cEFscGhhXG4gICAgfVxuICB9LFxuICBkaWZmZXJlbmNlOiB7XG4gICAgaDogZGlmZmVyZW5jZUh1ZUNocm9tYVxuICB9LFxuICBhdmVyYWdlOiB7XG4gICAgaDogYXZlcmFnZUFuZ2xlXG4gIH1cbn07XG5mdW5jdGlvbiBjb252ZXJ0SHNpVG9SZ2IoeyBoLCBzLCBpLCBhbHBoYSB9KSB7XG4gIGggPSBub3JtYWxpemVIdWUoaCAhPT0gdm9pZCAwID8gaCA6IDApO1xuICBpZiAocyA9PT0gdm9pZCAwKSBzID0gMDtcbiAgaWYgKGkgPT09IHZvaWQgMCkgaSA9IDA7XG4gIGxldCBmMiA9IE1hdGguYWJzKGggLyA2MCAlIDIgLSAxKTtcbiAgbGV0IHJlcztcbiAgc3dpdGNoIChNYXRoLmZsb29yKGggLyA2MCkpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXMgPSB7XG4gICAgICAgIHI6IGkgKiAoMSArIHMgKiAoMyAvICgyIC0gZjIpIC0gMSkpLFxuICAgICAgICBnOiBpICogKDEgKyBzICogKDMgKiAoMSAtIGYyKSAvICgyIC0gZjIpIC0gMSkpLFxuICAgICAgICBiOiBpICogKDEgLSBzKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHJlcyA9IHtcbiAgICAgICAgcjogaSAqICgxICsgcyAqICgzICogKDEgLSBmMikgLyAoMiAtIGYyKSAtIDEpKSxcbiAgICAgICAgZzogaSAqICgxICsgcyAqICgzIC8gKDIgLSBmMikgLSAxKSksXG4gICAgICAgIGI6IGkgKiAoMSAtIHMpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgcmVzID0ge1xuICAgICAgICByOiBpICogKDEgLSBzKSxcbiAgICAgICAgZzogaSAqICgxICsgcyAqICgzIC8gKDIgLSBmMikgLSAxKSksXG4gICAgICAgIGI6IGkgKiAoMSArIHMgKiAoMyAqICgxIC0gZjIpIC8gKDIgLSBmMikgLSAxKSlcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByZXMgPSB7XG4gICAgICAgIHI6IGkgKiAoMSAtIHMpLFxuICAgICAgICBnOiBpICogKDEgKyBzICogKDMgKiAoMSAtIGYyKSAvICgyIC0gZjIpIC0gMSkpLFxuICAgICAgICBiOiBpICogKDEgKyBzICogKDMgLyAoMiAtIGYyKSAtIDEpKVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHJlcyA9IHtcbiAgICAgICAgcjogaSAqICgxICsgcyAqICgzICogKDEgLSBmMikgLyAoMiAtIGYyKSAtIDEpKSxcbiAgICAgICAgZzogaSAqICgxIC0gcyksXG4gICAgICAgIGI6IGkgKiAoMSArIHMgKiAoMyAvICgyIC0gZjIpIC0gMSkpXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgcmVzID0ge1xuICAgICAgICByOiBpICogKDEgKyBzICogKDMgLyAoMiAtIGYyKSAtIDEpKSxcbiAgICAgICAgZzogaSAqICgxIC0gcyksXG4gICAgICAgIGI6IGkgKiAoMSArIHMgKiAoMyAqICgxIC0gZjIpIC8gKDIgLSBmMikgLSAxKSlcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzID0geyByOiBpICogKDEgLSBzKSwgZzogaSAqICgxIC0gcyksIGI6IGkgKiAoMSAtIHMpIH07XG4gIH1cbiAgcmVzLm1vZGUgPSBcInJnYlwiO1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0UmdiVG9Ic2koeyByLCBnLCBiLCBhbHBoYSB9KSB7XG4gIGlmIChyID09PSB2b2lkIDApIHIgPSAwO1xuICBpZiAoZyA9PT0gdm9pZCAwKSBnID0gMDtcbiAgaWYgKGIgPT09IHZvaWQgMCkgYiA9IDA7XG4gIGxldCBNMyA9IE1hdGgubWF4KHIsIGcsIGIpLCBtID0gTWF0aC5taW4ociwgZywgYik7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJoc2lcIixcbiAgICBzOiByICsgZyArIGIgPT09IDAgPyAwIDogMSAtIDMgKiBtIC8gKHIgKyBnICsgYiksXG4gICAgaTogKHIgKyBnICsgYikgLyAzXG4gIH07XG4gIGlmIChNMyAtIG0gIT09IDApXG4gICAgcmVzLmggPSAoTTMgPT09IHIgPyAoZyAtIGIpIC8gKE0zIC0gbSkgKyAoZyA8IGIpICogNiA6IE0zID09PSBnID8gKGIgLSByKSAvIChNMyAtIG0pICsgMiA6IChyIC0gZykgLyAoTTMgLSBtKSArIDQpICogNjA7XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSByZXMuYWxwaGEgPSBhbHBoYTtcbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGRlZmluaXRpb24kbSA9IHtcbiAgbW9kZTogXCJoc2lcIixcbiAgdG9Nb2RlOiB7XG4gICAgcmdiOiBjb252ZXJ0SHNpVG9SZ2JcbiAgfSxcbiAgcGFyc2U6IFtcIi0taHNpXCJdLFxuICBzZXJpYWxpemU6IFwiLS1oc2lcIixcbiAgZnJvbU1vZGU6IHtcbiAgICByZ2I6IGNvbnZlcnRSZ2JUb0hzaVxuICB9LFxuICBjaGFubmVsczogW1wiaFwiLCBcInNcIiwgXCJpXCIsIFwiYWxwaGFcIl0sXG4gIHJhbmdlczoge1xuICAgIGg6IFswLCAzNjBdXG4gIH0sXG4gIGdhbXV0OiBcInJnYlwiLFxuICBpbnRlcnBvbGF0ZToge1xuICAgIGg6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEh1ZVNob3J0ZXIgfSxcbiAgICBzOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgaTogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGFscGhhOiB7IHVzZTogaW50ZXJwb2xhdG9yTGluZWFyLCBmaXh1cDogZml4dXBBbHBoYSB9XG4gIH0sXG4gIGRpZmZlcmVuY2U6IHtcbiAgICBoOiBkaWZmZXJlbmNlSHVlU2F0dXJhdGlvblxuICB9LFxuICBhdmVyYWdlOiB7XG4gICAgaDogYXZlcmFnZUFuZ2xlXG4gIH1cbn07XG5mdW5jdGlvbiBjb252ZXJ0SHNsVG9SZ2IoeyBoLCBzLCBsLCBhbHBoYSB9KSB7XG4gIGggPSBub3JtYWxpemVIdWUoaCAhPT0gdm9pZCAwID8gaCA6IDApO1xuICBpZiAocyA9PT0gdm9pZCAwKSBzID0gMDtcbiAgaWYgKGwgPT09IHZvaWQgMCkgbCA9IDA7XG4gIGxldCBtMSA9IGwgKyBzICogKGwgPCAwLjUgPyBsIDogMSAtIGwpO1xuICBsZXQgbTIgPSBtMSAtIChtMSAtIGwpICogMiAqIE1hdGguYWJzKGggLyA2MCAlIDIgLSAxKTtcbiAgbGV0IHJlcztcbiAgc3dpdGNoIChNYXRoLmZsb29yKGggLyA2MCkpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXMgPSB7IHI6IG0xLCBnOiBtMiwgYjogMiAqIGwgLSBtMSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgcmVzID0geyByOiBtMiwgZzogbTEsIGI6IDIgKiBsIC0gbTEgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIHJlcyA9IHsgcjogMiAqIGwgLSBtMSwgZzogbTEsIGI6IG0yIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByZXMgPSB7IHI6IDIgKiBsIC0gbTEsIGc6IG0yLCBiOiBtMSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgcmVzID0geyByOiBtMiwgZzogMiAqIGwgLSBtMSwgYjogbTEgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHJlcyA9IHsgcjogbTEsIGc6IDIgKiBsIC0gbTEsIGI6IG0yIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzID0geyByOiAyICogbCAtIG0xLCBnOiAyICogbCAtIG0xLCBiOiAyICogbCAtIG0xIH07XG4gIH1cbiAgcmVzLm1vZGUgPSBcInJnYlwiO1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb252ZXJ0UmdiVG9Ic2woeyByLCBnLCBiLCBhbHBoYSB9KSB7XG4gIGlmIChyID09PSB2b2lkIDApIHIgPSAwO1xuICBpZiAoZyA9PT0gdm9pZCAwKSBnID0gMDtcbiAgaWYgKGIgPT09IHZvaWQgMCkgYiA9IDA7XG4gIGxldCBNMyA9IE1hdGgubWF4KHIsIGcsIGIpLCBtID0gTWF0aC5taW4ociwgZywgYik7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJoc2xcIixcbiAgICBzOiBNMyA9PT0gbSA/IDAgOiAoTTMgLSBtKSAvICgxIC0gTWF0aC5hYnMoTTMgKyBtIC0gMSkpLFxuICAgIGw6IDAuNSAqIChNMyArIG0pXG4gIH07XG4gIGlmIChNMyAtIG0gIT09IDApXG4gICAgcmVzLmggPSAoTTMgPT09IHIgPyAoZyAtIGIpIC8gKE0zIC0gbSkgKyAoZyA8IGIpICogNiA6IE0zID09PSBnID8gKGIgLSByKSAvIChNMyAtIG0pICsgMiA6IChyIC0gZykgLyAoTTMgLSBtKSArIDQpICogNjA7XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSByZXMuYWxwaGEgPSBhbHBoYTtcbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGh1ZVRvRGVnID0gKHZhbCwgdW5pdCkgPT4ge1xuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlIFwiZGVnXCI6XG4gICAgICByZXR1cm4gK3ZhbDtcbiAgICBjYXNlIFwicmFkXCI6XG4gICAgICByZXR1cm4gdmFsIC8gTWF0aC5QSSAqIDE4MDtcbiAgICBjYXNlIFwiZ3JhZFwiOlxuICAgICAgcmV0dXJuIHZhbCAvIDEwICogOTtcbiAgICBjYXNlIFwidHVyblwiOlxuICAgICAgcmV0dXJuIHZhbCAqIDM2MDtcbiAgfVxufTtcbmNvbnN0IGhzbF9vbGQgPSBuZXcgUmVnRXhwKFxuICBgXmhzbGE/XFxcXChcXFxccyoke2h1ZSQxfSR7Y30ke3Blcn0ke2N9JHtwZXJ9XFxcXHMqKD86LFxcXFxzKiR7bnVtX3Blcn1cXFxccyopP1xcXFwpJGBcbik7XG5jb25zdCBwYXJzZUhzbExlZ2FjeSA9IChjb2xvcikgPT4ge1xuICBsZXQgbWF0Y2ggPSBjb2xvci5tYXRjaChoc2xfb2xkKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICBsZXQgcmVzID0geyBtb2RlOiBcImhzbFwiIH07XG4gIGlmIChtYXRjaFszXSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmggPSArbWF0Y2hbM107XG4gIH0gZWxzZSBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCAmJiBtYXRjaFsyXSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmggPSBodWVUb0RlZyhtYXRjaFsxXSwgbWF0Y2hbMl0pO1xuICB9XG4gIGlmIChtYXRjaFs0XSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLnMgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtYXRjaFs0XSAvIDEwMCksIDEpO1xuICB9XG4gIGlmIChtYXRjaFs1XSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmwgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBtYXRjaFs1XSAvIDEwMCksIDEpO1xuICB9XG4gIGlmIChtYXRjaFs2XSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgbWF0Y2hbNl0gLyAxMDApKTtcbiAgfSBlbHNlIGlmIChtYXRjaFs3XSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgK21hdGNoWzddKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBwYXJzZUhzbChjb2xvciwgcGFyc2VkKSB7XG4gIGlmICghcGFyc2VkIHx8IHBhcnNlZFswXSAhPT0gXCJoc2xcIiAmJiBwYXJzZWRbMF0gIT09IFwiaHNsYVwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCByZXMgPSB7IG1vZGU6IFwiaHNsXCIgfTtcbiAgY29uc3QgWywgaCwgcywgbCwgYWxwaGFdID0gcGFyc2VkO1xuICBpZiAoaC50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIGlmIChoLnR5cGUgPT09IFRvay5QZXJjZW50YWdlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXMuaCA9IGgudmFsdWU7XG4gIH1cbiAgaWYgKHMudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICBpZiAocy50eXBlID09PSBUb2suSHVlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXMucyA9IHMudmFsdWUgLyAxMDA7XG4gIH1cbiAgaWYgKGwudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICBpZiAobC50eXBlID09PSBUb2suSHVlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXMubCA9IGwudmFsdWUgLyAxMDA7XG4gIH1cbiAgaWYgKGFscGhhLnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgcmVzLmFscGhhID0gTWF0aC5taW4oXG4gICAgICAxLFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIDAsXG4gICAgICAgIGFscGhhLnR5cGUgPT09IFRvay5OdW1iZXIgPyBhbHBoYS52YWx1ZSA6IGFscGhhLnZhbHVlIC8gMTAwXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuY29uc3QgZGVmaW5pdGlvbiRsID0ge1xuICBtb2RlOiBcImhzbFwiLFxuICB0b01vZGU6IHtcbiAgICByZ2I6IGNvbnZlcnRIc2xUb1JnYlxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHJnYjogY29udmVydFJnYlRvSHNsXG4gIH0sXG4gIGNoYW5uZWxzOiBbXCJoXCIsIFwic1wiLCBcImxcIiwgXCJhbHBoYVwiXSxcbiAgcmFuZ2VzOiB7XG4gICAgaDogWzAsIDM2MF1cbiAgfSxcbiAgZ2FtdXQ6IFwicmdiXCIsXG4gIHBhcnNlOiBbcGFyc2VIc2wsIHBhcnNlSHNsTGVnYWN5XSxcbiAgc2VyaWFsaXplOiAoYzIpID0+IGBoc2woJHtjMi5oICE9PSB2b2lkIDAgPyBjMi5oIDogXCJub25lXCJ9ICR7YzIucyAhPT0gdm9pZCAwID8gYzIucyAqIDEwMCArIFwiJVwiIDogXCJub25lXCJ9ICR7YzIubCAhPT0gdm9pZCAwID8gYzIubCAqIDEwMCArIFwiJVwiIDogXCJub25lXCJ9JHtjMi5hbHBoYSA8IDEgPyBgIC8gJHtjMi5hbHBoYX1gIDogXCJcIn0pYCxcbiAgaW50ZXJwb2xhdGU6IHtcbiAgICBoOiB7IHVzZTogaW50ZXJwb2xhdG9yTGluZWFyLCBmaXh1cDogZml4dXBIdWVTaG9ydGVyIH0sXG4gICAgczogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGw6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhbHBoYTogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwQWxwaGEgfVxuICB9LFxuICBkaWZmZXJlbmNlOiB7XG4gICAgaDogZGlmZmVyZW5jZUh1ZVNhdHVyYXRpb25cbiAgfSxcbiAgYXZlcmFnZToge1xuICAgIGg6IGF2ZXJhZ2VBbmdsZVxuICB9XG59O1xuZnVuY3Rpb24gY29udmVydEhzdlRvUmdiKHsgaCwgcywgdiwgYWxwaGEgfSkge1xuICBoID0gbm9ybWFsaXplSHVlKGggIT09IHZvaWQgMCA/IGggOiAwKTtcbiAgaWYgKHMgPT09IHZvaWQgMCkgcyA9IDA7XG4gIGlmICh2ID09PSB2b2lkIDApIHYgPSAwO1xuICBsZXQgZjIgPSBNYXRoLmFicyhoIC8gNjAgJSAyIC0gMSk7XG4gIGxldCByZXM7XG4gIHN3aXRjaCAoTWF0aC5mbG9vcihoIC8gNjApKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmVzID0geyByOiB2LCBnOiB2ICogKDEgLSBzICogZjIpLCBiOiB2ICogKDEgLSBzKSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgcmVzID0geyByOiB2ICogKDEgLSBzICogZjIpLCBnOiB2LCBiOiB2ICogKDEgLSBzKSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgcmVzID0geyByOiB2ICogKDEgLSBzKSwgZzogdiwgYjogdiAqICgxIC0gcyAqIGYyKSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgcmVzID0geyByOiB2ICogKDEgLSBzKSwgZzogdiAqICgxIC0gcyAqIGYyKSwgYjogdiB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgcmVzID0geyByOiB2ICogKDEgLSBzICogZjIpLCBnOiB2ICogKDEgLSBzKSwgYjogdiB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgcmVzID0geyByOiB2LCBnOiB2ICogKDEgLSBzKSwgYjogdiAqICgxIC0gcyAqIGYyKSB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlcyA9IHsgcjogdiAqICgxIC0gcyksIGc6IHYgKiAoMSAtIHMpLCBiOiB2ICogKDEgLSBzKSB9O1xuICB9XG4gIHJlcy5tb2RlID0gXCJyZ2JcIjtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHJlcy5hbHBoYSA9IGFscGhhO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29udmVydFJnYlRvSHN2KHsgciwgZywgYiwgYWxwaGEgfSkge1xuICBpZiAociA9PT0gdm9pZCAwKSByID0gMDtcbiAgaWYgKGcgPT09IHZvaWQgMCkgZyA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBsZXQgTTMgPSBNYXRoLm1heChyLCBnLCBiKSwgbSA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwiaHN2XCIsXG4gICAgczogTTMgPT09IDAgPyAwIDogMSAtIG0gLyBNMyxcbiAgICB2OiBNM1xuICB9O1xuICBpZiAoTTMgLSBtICE9PSAwKVxuICAgIHJlcy5oID0gKE0zID09PSByID8gKGcgLSBiKSAvIChNMyAtIG0pICsgKGcgPCBiKSAqIDYgOiBNMyA9PT0gZyA/IChiIC0gcikgLyAoTTMgLSBtKSArIDIgOiAociAtIGcpIC8gKE0zIC0gbSkgKyA0KSAqIDYwO1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBkZWZpbml0aW9uJGsgPSB7XG4gIG1vZGU6IFwiaHN2XCIsXG4gIHRvTW9kZToge1xuICAgIHJnYjogY29udmVydEhzdlRvUmdiXG4gIH0sXG4gIHBhcnNlOiBbXCItLWhzdlwiXSxcbiAgc2VyaWFsaXplOiBcIi0taHN2XCIsXG4gIGZyb21Nb2RlOiB7XG4gICAgcmdiOiBjb252ZXJ0UmdiVG9Ic3ZcbiAgfSxcbiAgY2hhbm5lbHM6IFtcImhcIiwgXCJzXCIsIFwidlwiLCBcImFscGhhXCJdLFxuICByYW5nZXM6IHtcbiAgICBoOiBbMCwgMzYwXVxuICB9LFxuICBnYW11dDogXCJyZ2JcIixcbiAgaW50ZXJwb2xhdGU6IHtcbiAgICBoOiB7IHVzZTogaW50ZXJwb2xhdG9yTGluZWFyLCBmaXh1cDogZml4dXBIdWVTaG9ydGVyIH0sXG4gICAgczogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIHY6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhbHBoYTogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwQWxwaGEgfVxuICB9LFxuICBkaWZmZXJlbmNlOiB7XG4gICAgaDogZGlmZmVyZW5jZUh1ZVNhdHVyYXRpb25cbiAgfSxcbiAgYXZlcmFnZToge1xuICAgIGg6IGF2ZXJhZ2VBbmdsZVxuICB9XG59O1xuZnVuY3Rpb24gY29udmVydEh3YlRvUmdiKHsgaCwgdywgYiwgYWxwaGEgfSkge1xuICBpZiAodyA9PT0gdm9pZCAwKSB3ID0gMDtcbiAgaWYgKGIgPT09IHZvaWQgMCkgYiA9IDA7XG4gIGlmICh3ICsgYiA+IDEpIHtcbiAgICBsZXQgcyA9IHcgKyBiO1xuICAgIHcgLz0gcztcbiAgICBiIC89IHM7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRIc3ZUb1JnYih7XG4gICAgaCxcbiAgICBzOiBiID09PSAxID8gMSA6IDEgLSB3IC8gKDEgLSBiKSxcbiAgICB2OiAxIC0gYixcbiAgICBhbHBoYVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSZ2JUb0h3YihyZ2JhKSB7XG4gIGxldCBoc3YgPSBjb252ZXJ0UmdiVG9Ic3YocmdiYSk7XG4gIGlmIChoc3YgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgbGV0IHMgPSBoc3YucyAhPT0gdm9pZCAwID8gaHN2LnMgOiAwO1xuICBsZXQgdiA9IGhzdi52ICE9PSB2b2lkIDAgPyBoc3YudiA6IDA7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJod2JcIixcbiAgICB3OiAoMSAtIHMpICogdixcbiAgICBiOiAxIC0gdlxuICB9O1xuICBpZiAoaHN2LmggIT09IHZvaWQgMCkgcmVzLmggPSBoc3YuaDtcbiAgaWYgKGhzdi5hbHBoYSAhPT0gdm9pZCAwKSByZXMuYWxwaGEgPSBoc3YuYWxwaGE7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBQYXJzZUh3Yihjb2xvciwgcGFyc2VkKSB7XG4gIGlmICghcGFyc2VkIHx8IHBhcnNlZFswXSAhPT0gXCJod2JcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcmVzID0geyBtb2RlOiBcImh3YlwiIH07XG4gIGNvbnN0IFssIGgsIHcsIGIsIGFscGhhXSA9IHBhcnNlZDtcbiAgaWYgKGgudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICBpZiAoaC50eXBlID09PSBUb2suUGVyY2VudGFnZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmVzLmggPSBoLnZhbHVlO1xuICB9XG4gIGlmICh3LnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgaWYgKHcudHlwZSA9PT0gVG9rLkh1ZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmVzLncgPSB3LnZhbHVlIC8gMTAwO1xuICB9XG4gIGlmIChiLnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgaWYgKGIudHlwZSA9PT0gVG9rLkh1ZSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmVzLmIgPSBiLnZhbHVlIC8gMTAwO1xuICB9XG4gIGlmIChhbHBoYS50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIHJlcy5hbHBoYSA9IE1hdGgubWluKFxuICAgICAgMSxcbiAgICAgIE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICBhbHBoYS50eXBlID09PSBUb2suTnVtYmVyID8gYWxwaGEudmFsdWUgOiBhbHBoYS52YWx1ZSAvIDEwMFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGRlZmluaXRpb24kaiA9IHtcbiAgbW9kZTogXCJod2JcIixcbiAgdG9Nb2RlOiB7XG4gICAgcmdiOiBjb252ZXJ0SHdiVG9SZ2JcbiAgfSxcbiAgZnJvbU1vZGU6IHtcbiAgICByZ2I6IGNvbnZlcnRSZ2JUb0h3YlxuICB9LFxuICBjaGFubmVsczogW1wiaFwiLCBcIndcIiwgXCJiXCIsIFwiYWxwaGFcIl0sXG4gIHJhbmdlczoge1xuICAgIGg6IFswLCAzNjBdXG4gIH0sXG4gIGdhbXV0OiBcInJnYlwiLFxuICBwYXJzZTogW1BhcnNlSHdiXSxcbiAgc2VyaWFsaXplOiAoYzIpID0+IGBod2IoJHtjMi5oICE9PSB2b2lkIDAgPyBjMi5oIDogXCJub25lXCJ9ICR7YzIudyAhPT0gdm9pZCAwID8gYzIudyAqIDEwMCArIFwiJVwiIDogXCJub25lXCJ9ICR7YzIuYiAhPT0gdm9pZCAwID8gYzIuYiAqIDEwMCArIFwiJVwiIDogXCJub25lXCJ9JHtjMi5hbHBoYSA8IDEgPyBgIC8gJHtjMi5hbHBoYX1gIDogXCJcIn0pYCxcbiAgaW50ZXJwb2xhdGU6IHtcbiAgICBoOiB7IHVzZTogaW50ZXJwb2xhdG9yTGluZWFyLCBmaXh1cDogZml4dXBIdWVTaG9ydGVyIH0sXG4gICAgdzogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGI6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhbHBoYTogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwQWxwaGEgfVxuICB9LFxuICBkaWZmZXJlbmNlOiB7XG4gICAgaDogZGlmZmVyZW5jZUh1ZU5haXZlXG4gIH0sXG4gIGF2ZXJhZ2U6IHtcbiAgICBoOiBhdmVyYWdlQW5nbGVcbiAgfVxufTtcbmNvbnN0IFlXID0gMjAzO1xuY29uc3QgTTEgPSAwLjE1OTMwMTc1NzgxMjU7XG5jb25zdCBNMiA9IDc4Ljg0Mzc1O1xuY29uc3QgQzEgPSAwLjgzNTkzNzU7XG5jb25zdCBDMiA9IDE4Ljg1MTU2MjU7XG5jb25zdCBDMyA9IDE4LjY4NzU7XG5mdW5jdGlvbiB0cmFuc2ZlclBxRGVjb2RlKHYpIHtcbiAgaWYgKHYgPCAwKSByZXR1cm4gMDtcbiAgY29uc3QgYzIgPSBNYXRoLnBvdyh2LCAxIC8gTTIpO1xuICByZXR1cm4gMWU0ICogTWF0aC5wb3coTWF0aC5tYXgoMCwgYzIgLSBDMSkgLyAoQzIgLSBDMyAqIGMyKSwgMSAvIE0xKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZmVyUHFFbmNvZGUodikge1xuICBpZiAodiA8IDApIHJldHVybiAwO1xuICBjb25zdCBjMiA9IE1hdGgucG93KHYgLyAxZTQsIE0xKTtcbiAgcmV0dXJuIE1hdGgucG93KChDMSArIEMyICogYzIpIC8gKDEgKyBDMyAqIGMyKSwgTTIpO1xufVxuY29uc3QgdG9SZWwgPSAoYzIpID0+IE1hdGgubWF4KGMyIC8gWVcsIDApO1xuY29uc3QgY29udmVydEl0cFRvWHl6NjUgPSAoeyBpLCB0LCBwOiBwMiwgYWxwaGEgfSkgPT4ge1xuICBpZiAoaSA9PT0gdm9pZCAwKSBpID0gMDtcbiAgaWYgKHQgPT09IHZvaWQgMCkgdCA9IDA7XG4gIGlmIChwMiA9PT0gdm9pZCAwKSBwMiA9IDA7XG4gIGNvbnN0IGwgPSB0cmFuc2ZlclBxRGVjb2RlKFxuICAgIGkgKyAwLjAwODYwOTAzNzAzNzkzMjc2MSAqIHQgKyAwLjExMTAyOTYyNTAwMzAyNTkzICogcDJcbiAgKTtcbiAgY29uc3QgbSA9IHRyYW5zZmVyUHFEZWNvZGUoXG4gICAgaSAtIDAuMDA4NjA5MDM3MDM3OTMyNzUgKiB0IC0gMC4xMTEwMjk2MjUwMDMwMjU5OSAqIHAyXG4gICk7XG4gIGNvbnN0IHMgPSB0cmFuc2ZlclBxRGVjb2RlKFxuICAgIGkgKyAwLjU2MDAzMTMzNTcxMDY3OTEgKiB0IC0gMC4zMjA2MjcxNzQ5ODczMTg4NSAqIHAyXG4gICk7XG4gIGNvbnN0IHJlcyA9IHtcbiAgICBtb2RlOiBcInh5ejY1XCIsXG4gICAgeDogdG9SZWwoXG4gICAgICAyLjA3MDE1MjIxODM4OTQyMiAqIGwgLSAxLjMyNjM0NzMzODk2NzE1NTYgKiBtICsgMC4yMDY2NTEwNDc2Mjk0MDUxICogc1xuICAgICksXG4gICAgeTogdG9SZWwoXG4gICAgICAwLjM2NDczODUyMDk3NDgwNzQgKiBsICsgMC42ODA1NjYwMjQ5NDcyMjcgKiBtIC0gMC4wNDUzMDQ1NDU5MjIwMzQ2ICogc1xuICAgICksXG4gICAgejogdG9SZWwoXG4gICAgICAtMC4wNDk3NDcyMDc1MzU4MTIgKiBsIC0gMC4wNDkyNjA5NjY2OTY2MTM4ICogbSArIDEuMTg4MDY1OTI0OTkyMzA0MiAqIHNcbiAgICApXG4gIH07XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCB0b0FicyA9IChjMiA9IDApID0+IE1hdGgubWF4KGMyICogWVcsIDApO1xuY29uc3QgY29udmVydFh5ejY1VG9JdHAgPSAoeyB4LCB5LCB6LCBhbHBoYSB9KSA9PiB7XG4gIGNvbnN0IGFic1ggPSB0b0Ficyh4KTtcbiAgY29uc3QgYWJzWSA9IHRvQWJzKHkpO1xuICBjb25zdCBhYnNaID0gdG9BYnMoeik7XG4gIGNvbnN0IGwgPSB0cmFuc2ZlclBxRW5jb2RlKFxuICAgIDAuMzU5MjgzMjU5MDEyMTIxNyAqIGFic1ggKyAwLjY5NzYwNTExNDc3Nzk1MDIgKiBhYnNZIC0gMC4wMzU4OTE1OTMyMzIwMjg5ICogYWJzWlxuICApO1xuICBjb25zdCBtID0gdHJhbnNmZXJQcUVuY29kZShcbiAgICAtMC4xOTIwODA4NDYzNzA0OTk1ICogYWJzWCArIDEuMTAwNDc2Nzk3MDM3NDMyMyAqIGFic1kgKyAwLjA3NTM3NDg2NTg1MTkxMTggKiBhYnNaXG4gICk7XG4gIGNvbnN0IHMgPSB0cmFuc2ZlclBxRW5jb2RlKFxuICAgIDAuMDA3MDc5Nzg0NDYwNzQ3NyAqIGFic1ggKyAwLjA3NDgzOTY2NjIxODYzNjYgKiBhYnNZICsgMC44NDMzMjY1NDUzODk4NzY1ICogYWJzWlxuICApO1xuICBjb25zdCBpID0gMC41ICogbCArIDAuNSAqIG07XG4gIGNvbnN0IHQgPSAxLjYxMzc2OTUzMTI1ICogbCAtIDMuMzIzNDg2MzI4MTI1ICogbSArIDEuNzA5NzE2Nzk2ODc1ICogcztcbiAgY29uc3QgcDIgPSA0LjM3ODE3MzgyODEyNSAqIGwgLSA0LjI0NTYwNTQ2ODc1ICogbSAtIDAuMTMyNTY4MzU5Mzc1ICogcztcbiAgY29uc3QgcmVzID0geyBtb2RlOiBcIml0cFwiLCBpLCB0LCBwOiBwMiB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZGVmaW5pdGlvbiRpID0ge1xuICBtb2RlOiBcIml0cFwiLFxuICBjaGFubmVsczogW1wiaVwiLCBcInRcIiwgXCJwXCIsIFwiYWxwaGFcIl0sXG4gIHBhcnNlOiBbXCItLWljdGNwXCJdLFxuICBzZXJpYWxpemU6IFwiLS1pY3RjcFwiLFxuICB0b01vZGU6IHtcbiAgICB4eXo2NTogY29udmVydEl0cFRvWHl6NjUsXG4gICAgcmdiOiAoY29sb3IpID0+IGNvbnZlcnRYeXo2NVRvUmdiKGNvbnZlcnRJdHBUb1h5ejY1KGNvbG9yKSlcbiAgfSxcbiAgZnJvbU1vZGU6IHtcbiAgICB4eXo2NTogY29udmVydFh5ejY1VG9JdHAsXG4gICAgcmdiOiAoY29sb3IpID0+IGNvbnZlcnRYeXo2NVRvSXRwKGNvbnZlcnRSZ2JUb1h5ejY1KGNvbG9yKSlcbiAgfSxcbiAgcmFuZ2VzOiB7XG4gICAgaTogWzAsIDAuNTgxXSxcbiAgICB0OiBbLTAuMzY5LCAwLjI3Ml0sXG4gICAgcDogWy0wLjE2NCwgMC4zMzFdXG4gIH0sXG4gIGludGVycG9sYXRlOiB7XG4gICAgaTogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIHQ6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBwOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYWxwaGE6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEFscGhhIH1cbiAgfVxufTtcbmNvbnN0IHAkMSA9IDEzNC4wMzQzNzQ5OTk5OTk5ODtcbmNvbnN0IGQwJDEgPSAxNjI5NTQ5OTUzMjgyMTU2NWUtMjc7XG5jb25zdCBqYWJQcUVuY29kZSA9ICh2KSA9PiB7XG4gIGlmICh2IDwgMCkgcmV0dXJuIDA7XG4gIGxldCB2bjIgPSBNYXRoLnBvdyh2IC8gMWU0LCBNMSk7XG4gIHJldHVybiBNYXRoLnBvdygoQzEgKyBDMiAqIHZuMikgLyAoMSArIEMzICogdm4yKSwgcCQxKTtcbn07XG5jb25zdCBhYnMgPSAodiA9IDApID0+IE1hdGgubWF4KHYgKiAyMDMsIDApO1xuY29uc3QgY29udmVydFh5ejY1VG9KYWIgPSAoeyB4LCB5LCB6LCBhbHBoYSB9KSA9PiB7XG4gIHggPSBhYnMoeCk7XG4gIHkgPSBhYnMoeSk7XG4gIHogPSBhYnMoeik7XG4gIGxldCB4cCA9IDEuMTUgKiB4IC0gMC4xNSAqIHo7XG4gIGxldCB5cCA9IDAuNjYgKiB5ICsgMC4zNCAqIHg7XG4gIGxldCBsID0gamFiUHFFbmNvZGUoMC40MTQ3ODk3MiAqIHhwICsgMC41Nzk5OTkgKiB5cCArIDAuMDE0NjQ4ICogeik7XG4gIGxldCBtID0gamFiUHFFbmNvZGUoLTAuMjAxNTEgKiB4cCArIDEuMTIwNjQ5ICogeXAgKyAwLjA1MzEwMDggKiB6KTtcbiAgbGV0IHMgPSBqYWJQcUVuY29kZSgtMC4wMTY2MDA4ICogeHAgKyAwLjI2NDggKiB5cCArIDAuNjY4NDc5OSAqIHopO1xuICBsZXQgaSA9IChsICsgbSkgLyAyO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwiamFiXCIsXG4gICAgajogMC40NCAqIGkgLyAoMSAtIDAuNTYgKiBpKSAtIGQwJDEsXG4gICAgYTogMy41MjQgKiBsIC0gNC4wNjY3MDggKiBtICsgMC41NDI3MDggKiBzLFxuICAgIGI6IDAuMTk5MDc2ICogbCArIDEuMDk2Nzk5ICogbSAtIDEuMjk1ODc1ICogc1xuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgcCA9IDEzNC4wMzQzNzQ5OTk5OTk5ODtcbmNvbnN0IGQwID0gMTYyOTU0OTk1MzI4MjE1NjVlLTI3O1xuY29uc3QgamFiUHFEZWNvZGUgPSAodikgPT4ge1xuICBpZiAodiA8IDApIHJldHVybiAwO1xuICBsZXQgdnAgPSBNYXRoLnBvdyh2LCAxIC8gcCk7XG4gIHJldHVybiAxZTQgKiBNYXRoLnBvdygoQzEgLSB2cCkgLyAoQzMgKiB2cCAtIEMyKSwgMSAvIE0xKTtcbn07XG5jb25zdCByZWwgPSAodikgPT4gdiAvIDIwMztcbmNvbnN0IGNvbnZlcnRKYWJUb1h5ejY1ID0gKHsgaiwgYSwgYiwgYWxwaGEgfSkgPT4ge1xuICBpZiAoaiA9PT0gdm9pZCAwKSBqID0gMDtcbiAgaWYgKGEgPT09IHZvaWQgMCkgYSA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBsZXQgaSA9IChqICsgZDApIC8gKDAuNDQgKyAwLjU2ICogKGogKyBkMCkpO1xuICBsZXQgbCA9IGphYlBxRGVjb2RlKGkgKyAwLjEzODYwNTA0ICogYSArIDAuMDU4MDQ3MzE2ICogYik7XG4gIGxldCBtID0gamFiUHFEZWNvZGUoaSAtIDAuMTM4NjA1MDQgKiBhIC0gMC4wNTgwNDczMTYgKiBiKTtcbiAgbGV0IHMgPSBqYWJQcURlY29kZShpIC0gMC4wOTYwMTkyNDIgKiBhIC0gMC44MTE4OTE5ICogYik7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJ4eXo2NVwiLFxuICAgIHg6IHJlbChcbiAgICAgIDEuNjYxMzczMDI0NjUyMTc0ICogbCAtIDAuOTE0NTIzMDgxMzA0MzQ4ICogbSArIDAuMjMxMzYyMDgxNzM5MTMwNDUgKiBzXG4gICAgKSxcbiAgICB5OiByZWwoXG4gICAgICAtMC4zMjUwNzU4NjExODQ0NTMzICogbCArIDEuNTcxODQ3MDI2NzMyNTQzICogbSAtIDAuMjE4MjUzODM0NTMyMjc5MjggKiBzXG4gICAgKSxcbiAgICB6OiByZWwoLTAuMDkwOTgyODExICogbCAtIDAuMzEyNzI4MjkgKiBtICsgMS41MjI3NjY2ICogcylcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBhbHBoYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGNvbnZlcnRSZ2JUb0phYiA9IChyZ2IpID0+IHtcbiAgbGV0IHJlcyA9IGNvbnZlcnRYeXo2NVRvSmFiKGNvbnZlcnRSZ2JUb1h5ejY1KHJnYikpO1xuICBpZiAocmdiLnIgPT09IHJnYi5iICYmIHJnYi5iID09PSByZ2IuZykge1xuICAgIHJlcy5hID0gcmVzLmIgPSAwO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydEphYlRvUmdiID0gKGNvbG9yKSA9PiBjb252ZXJ0WHl6NjVUb1JnYihjb252ZXJ0SmFiVG9YeXo2NShjb2xvcikpO1xuY29uc3QgZGVmaW5pdGlvbiRoID0ge1xuICBtb2RlOiBcImphYlwiLFxuICBjaGFubmVsczogW1wialwiLCBcImFcIiwgXCJiXCIsIFwiYWxwaGFcIl0sXG4gIHBhcnNlOiBbXCItLWp6YXpielwiXSxcbiAgc2VyaWFsaXplOiBcIi0tanphemJ6XCIsXG4gIGZyb21Nb2RlOiB7XG4gICAgcmdiOiBjb252ZXJ0UmdiVG9KYWIsXG4gICAgeHl6NjU6IGNvbnZlcnRYeXo2NVRvSmFiXG4gIH0sXG4gIHRvTW9kZToge1xuICAgIHJnYjogY29udmVydEphYlRvUmdiLFxuICAgIHh5ejY1OiBjb252ZXJ0SmFiVG9YeXo2NVxuICB9LFxuICByYW5nZXM6IHtcbiAgICBqOiBbMCwgMC4yMjJdLFxuICAgIGE6IFstMC4xMDksIDAuMTI5XSxcbiAgICBiOiBbLTAuMTg1LCAwLjEzNF1cbiAgfSxcbiAgaW50ZXJwb2xhdGU6IHtcbiAgICBqOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYTogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGI6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhbHBoYTogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwQWxwaGEgfVxuICB9XG59O1xuY29uc3QgY29udmVydEphYlRvSmNoID0gKHsgaiwgYSwgYiwgYWxwaGEgfSkgPT4ge1xuICBpZiAoYSA9PT0gdm9pZCAwKSBhID0gMDtcbiAgaWYgKGIgPT09IHZvaWQgMCkgYiA9IDA7XG4gIGxldCBjMiA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcImpjaFwiLFxuICAgIGosXG4gICAgYzogYzJcbiAgfTtcbiAgaWYgKGMyKSB7XG4gICAgcmVzLmggPSBub3JtYWxpemVIdWUoTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEkpO1xuICB9XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBjb252ZXJ0SmNoVG9KYWIgPSAoeyBqLCBjOiBjMiwgaCwgYWxwaGEgfSkgPT4ge1xuICBpZiAoaCA9PT0gdm9pZCAwKSBoID0gMDtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcImphYlwiLFxuICAgIGosXG4gICAgYTogYzIgPyBjMiAqIE1hdGguY29zKGggLyAxODAgKiBNYXRoLlBJKSA6IDAsXG4gICAgYjogYzIgPyBjMiAqIE1hdGguc2luKGggLyAxODAgKiBNYXRoLlBJKSA6IDBcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHJlcy5hbHBoYSA9IGFscGhhO1xuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGRlZmluaXRpb24kZyA9IHtcbiAgbW9kZTogXCJqY2hcIixcbiAgcGFyc2U6IFtcIi0tanpjemh6XCJdLFxuICBzZXJpYWxpemU6IFwiLS1qemN6aHpcIixcbiAgdG9Nb2RlOiB7XG4gICAgamFiOiBjb252ZXJ0SmNoVG9KYWIsXG4gICAgcmdiOiAoYzIpID0+IGNvbnZlcnRKYWJUb1JnYihjb252ZXJ0SmNoVG9KYWIoYzIpKVxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHJnYjogKGMyKSA9PiBjb252ZXJ0SmFiVG9KY2goY29udmVydFJnYlRvSmFiKGMyKSksXG4gICAgamFiOiBjb252ZXJ0SmFiVG9KY2hcbiAgfSxcbiAgY2hhbm5lbHM6IFtcImpcIiwgXCJjXCIsIFwiaFwiLCBcImFscGhhXCJdLFxuICByYW5nZXM6IHtcbiAgICBqOiBbMCwgMC4yMjFdLFxuICAgIGM6IFswLCAwLjE5XSxcbiAgICBoOiBbMCwgMzYwXVxuICB9LFxuICBpbnRlcnBvbGF0ZToge1xuICAgIGg6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEh1ZVNob3J0ZXIgfSxcbiAgICBjOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgajogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGFscGhhOiB7IHVzZTogaW50ZXJwb2xhdG9yTGluZWFyLCBmaXh1cDogZml4dXBBbHBoYSB9XG4gIH0sXG4gIGRpZmZlcmVuY2U6IHtcbiAgICBoOiBkaWZmZXJlbmNlSHVlQ2hyb21hXG4gIH0sXG4gIGF2ZXJhZ2U6IHtcbiAgICBoOiBhdmVyYWdlQW5nbGVcbiAgfVxufTtcbmNvbnN0IGsgPSBNYXRoLnBvdygyOSwgMykgLyBNYXRoLnBvdygzLCAzKTtcbmNvbnN0IGUgPSBNYXRoLnBvdyg2LCAzKSAvIE1hdGgucG93KDI5LCAzKTtcbmxldCBmbiA9ICh2KSA9PiBNYXRoLnBvdyh2LCAzKSA+IGUgPyBNYXRoLnBvdyh2LCAzKSA6ICgxMTYgKiB2IC0gMTYpIC8gaztcbmNvbnN0IGNvbnZlcnRMYWJUb1h5ejUwID0gKHsgbCwgYSwgYiwgYWxwaGEgfSkgPT4ge1xuICBpZiAobCA9PT0gdm9pZCAwKSBsID0gMDtcbiAgaWYgKGEgPT09IHZvaWQgMCkgYSA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBsZXQgZnkgPSAobCArIDE2KSAvIDExNjtcbiAgbGV0IGZ4ID0gYSAvIDUwMCArIGZ5O1xuICBsZXQgZnogPSBmeSAtIGIgLyAyMDA7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJ4eXo1MFwiLFxuICAgIHg6IGZuKGZ4KSAqIEQ1MC5YLFxuICAgIHk6IGZuKGZ5KSAqIEQ1MC5ZLFxuICAgIHo6IGZuKGZ6KSAqIEQ1MC5aXG4gIH07XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBjb252ZXJ0WHl6NTBUb1JnYiA9ICh7IHgsIHksIHosIGFscGhhIH0pID0+IHtcbiAgaWYgKHggPT09IHZvaWQgMCkgeCA9IDA7XG4gIGlmICh5ID09PSB2b2lkIDApIHkgPSAwO1xuICBpZiAoeiA9PT0gdm9pZCAwKSB6ID0gMDtcbiAgbGV0IHJlcyA9IGNvbnZlcnRMcmdiVG9SZ2Ioe1xuICAgIHI6IHggKiAzLjEzNDEzNTk1Njk5NTg3MDcgLSB5ICogMS42MTczODYzMzIxNjEyNTM4IC0gMC40OTA2NjE5NDYwMDgzNTMyICogeixcbiAgICBnOiB4ICogLTAuOTc4Nzk1NTAyOTEyMDg5ICsgeSAqIDEuOTE2MjU0NTY3MjU5NTI0ICsgMC4wMzM0NDI3MzExNjEzMTk0OSAqIHosXG4gICAgYjogeCAqIDAuMDcxOTU1Mzc5ODg0MTE2NzcgLSB5ICogMC4yMjg5NzY4MjY0MTU4MzIyICsgMS40MDUzODYwNTgzMjQxMjUgKiB6XG4gIH0pO1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydExhYlRvUmdiID0gKGxhYikgPT4gY29udmVydFh5ejUwVG9SZ2IoY29udmVydExhYlRvWHl6NTAobGFiKSk7XG5jb25zdCBjb252ZXJ0UmdiVG9YeXo1MCA9IChyZ2IpID0+IHtcbiAgbGV0IHsgciwgZywgYiwgYWxwaGEgfSA9IGNvbnZlcnRSZ2JUb0xyZ2IocmdiKTtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcInh5ejUwXCIsXG4gICAgeDogMC40MzYwNjU3NDI4MjQ4MTEgKiByICsgMC4zODUxNTE0Njg4MzM3OTEyICogZyArIDAuMTQzMDc4NDU0NDIyNjQxOTcgKiBiLFxuICAgIHk6IDAuMjIyNDkzMTkxNzU2MjM3MDIgKiByICsgMC43MTY4ODcwNTM4MjM4ODIzICogZyArIDAuMDYwNjE5NzkwNTM2MTY1MzcgKiBiLFxuICAgIHo6IDAuMDEzOTIzOTA0NTAwOTQzNDY1ICogciArIDAuMDk3MDgxMjg1NjY1NzQ2MzQgKiBnICsgMC43MTQwOTkzNTg0MDA1MTU1ICogYlxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZiA9ICh2YWx1ZSkgPT4gdmFsdWUgPiBlID8gTWF0aC5jYnJ0KHZhbHVlKSA6IChrICogdmFsdWUgKyAxNikgLyAxMTY7XG5jb25zdCBjb252ZXJ0WHl6NTBUb0xhYiA9ICh7IHgsIHksIHosIGFscGhhIH0pID0+IHtcbiAgaWYgKHggPT09IHZvaWQgMCkgeCA9IDA7XG4gIGlmICh5ID09PSB2b2lkIDApIHkgPSAwO1xuICBpZiAoeiA9PT0gdm9pZCAwKSB6ID0gMDtcbiAgbGV0IGYwID0gZih4IC8gRDUwLlgpO1xuICBsZXQgZjEgPSBmKHkgLyBENTAuWSk7XG4gIGxldCBmMiA9IGYoeiAvIEQ1MC5aKTtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcImxhYlwiLFxuICAgIGw6IDExNiAqIGYxIC0gMTYsXG4gICAgYTogNTAwICogKGYwIC0gZjEpLFxuICAgIGI6IDIwMCAqIChmMSAtIGYyKVxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydFJnYlRvTGFiID0gKHJnYikgPT4ge1xuICBsZXQgcmVzID0gY29udmVydFh5ejUwVG9MYWIoY29udmVydFJnYlRvWHl6NTAocmdiKSk7XG4gIGlmIChyZ2IuciA9PT0gcmdiLmIgJiYgcmdiLmIgPT09IHJnYi5nKSB7XG4gICAgcmVzLmEgPSByZXMuYiA9IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5mdW5jdGlvbiBwYXJzZUxhYihjb2xvciwgcGFyc2VkKSB7XG4gIGlmICghcGFyc2VkIHx8IHBhcnNlZFswXSAhPT0gXCJsYWJcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgcmVzID0geyBtb2RlOiBcImxhYlwiIH07XG4gIGNvbnN0IFssIGwsIGEsIGIsIGFscGhhXSA9IHBhcnNlZDtcbiAgaWYgKGwudHlwZSA9PT0gVG9rLkh1ZSB8fCBhLnR5cGUgPT09IFRvay5IdWUgfHwgYi50eXBlID09PSBUb2suSHVlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAobC50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIHJlcy5sID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbC52YWx1ZSksIDEwMCk7XG4gIH1cbiAgaWYgKGEudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICByZXMuYSA9IGEudHlwZSA9PT0gVG9rLk51bWJlciA/IGEudmFsdWUgOiBhLnZhbHVlICogMTI1IC8gMTAwO1xuICB9XG4gIGlmIChiLnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgcmVzLmIgPSBiLnR5cGUgPT09IFRvay5OdW1iZXIgPyBiLnZhbHVlIDogYi52YWx1ZSAqIDEyNSAvIDEwMDtcbiAgfVxuICBpZiAoYWxwaGEudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICByZXMuYWxwaGEgPSBNYXRoLm1pbihcbiAgICAgIDEsXG4gICAgICBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgYWxwaGEudHlwZSA9PT0gVG9rLk51bWJlciA/IGFscGhhLnZhbHVlIDogYWxwaGEudmFsdWUgLyAxMDBcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBkZWZpbml0aW9uJGYgPSB7XG4gIG1vZGU6IFwibGFiXCIsXG4gIHRvTW9kZToge1xuICAgIHh5ejUwOiBjb252ZXJ0TGFiVG9YeXo1MCxcbiAgICByZ2I6IGNvbnZlcnRMYWJUb1JnYlxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHh5ejUwOiBjb252ZXJ0WHl6NTBUb0xhYixcbiAgICByZ2I6IGNvbnZlcnRSZ2JUb0xhYlxuICB9LFxuICBjaGFubmVsczogW1wibFwiLCBcImFcIiwgXCJiXCIsIFwiYWxwaGFcIl0sXG4gIHJhbmdlczoge1xuICAgIGw6IFswLCAxMDBdLFxuICAgIGE6IFstMTI1LCAxMjVdLFxuICAgIGI6IFstMTI1LCAxMjVdXG4gIH0sXG4gIHBhcnNlOiBbcGFyc2VMYWJdLFxuICBzZXJpYWxpemU6IChjMikgPT4gYGxhYigke2MyLmwgIT09IHZvaWQgMCA/IGMyLmwgOiBcIm5vbmVcIn0gJHtjMi5hICE9PSB2b2lkIDAgPyBjMi5hIDogXCJub25lXCJ9ICR7YzIuYiAhPT0gdm9pZCAwID8gYzIuYiA6IFwibm9uZVwifSR7YzIuYWxwaGEgPCAxID8gYCAvICR7YzIuYWxwaGF9YCA6IFwiXCJ9KWAsXG4gIGludGVycG9sYXRlOiB7XG4gICAgbDogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGE6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBiOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYWxwaGE6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEFscGhhIH1cbiAgfVxufTtcbmNvbnN0IGRlZmluaXRpb24kZSA9IHtcbiAgLi4uZGVmaW5pdGlvbiRmLFxuICBtb2RlOiBcImxhYjY1XCIsXG4gIHBhcnNlOiBbXCItLWxhYi1kNjVcIl0sXG4gIHNlcmlhbGl6ZTogXCItLWxhYi1kNjVcIixcbiAgdG9Nb2RlOiB7XG4gICAgeHl6NjU6IGNvbnZlcnRMYWI2NVRvWHl6NjUsXG4gICAgcmdiOiBjb252ZXJ0TGFiNjVUb1JnYlxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHh5ejY1OiBjb252ZXJ0WHl6NjVUb0xhYjY1LFxuICAgIHJnYjogY29udmVydFJnYlRvTGFiNjVcbiAgfSxcbiAgcmFuZ2VzOiB7XG4gICAgbDogWzAsIDEwMF0sXG4gICAgYTogWy0xMjUsIDEyNV0sXG4gICAgYjogWy0xMjUsIDEyNV1cbiAgfVxufTtcbmZ1bmN0aW9uIHBhcnNlTGNoKGNvbG9yLCBwYXJzZWQpIHtcbiAgaWYgKCFwYXJzZWQgfHwgcGFyc2VkWzBdICE9PSBcImxjaFwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCByZXMgPSB7IG1vZGU6IFwibGNoXCIgfTtcbiAgY29uc3QgWywgbCwgYzIsIGgsIGFscGhhXSA9IHBhcnNlZDtcbiAgaWYgKGwudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICBpZiAobC50eXBlID09PSBUb2suSHVlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXMubCA9IE1hdGgubWluKE1hdGgubWF4KDAsIGwudmFsdWUpLCAxMDApO1xuICB9XG4gIGlmIChjMi50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIHJlcy5jID0gTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgYzIudHlwZSA9PT0gVG9rLk51bWJlciA/IGMyLnZhbHVlIDogYzIudmFsdWUgKiAxNTAgLyAxMDBcbiAgICApO1xuICB9XG4gIGlmIChoLnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgaWYgKGgudHlwZSA9PT0gVG9rLlBlcmNlbnRhZ2UpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJlcy5oID0gaC52YWx1ZTtcbiAgfVxuICBpZiAoYWxwaGEudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICByZXMuYWxwaGEgPSBNYXRoLm1pbihcbiAgICAgIDEsXG4gICAgICBNYXRoLm1heChcbiAgICAgICAgMCxcbiAgICAgICAgYWxwaGEudHlwZSA9PT0gVG9rLk51bWJlciA/IGFscGhhLnZhbHVlIDogYWxwaGEudmFsdWUgLyAxMDBcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5jb25zdCBkZWZpbml0aW9uJGQgPSB7XG4gIG1vZGU6IFwibGNoXCIsXG4gIHRvTW9kZToge1xuICAgIGxhYjogY29udmVydExjaFRvTGFiLFxuICAgIHJnYjogKGMyKSA9PiBjb252ZXJ0TGFiVG9SZ2IoY29udmVydExjaFRvTGFiKGMyKSlcbiAgfSxcbiAgZnJvbU1vZGU6IHtcbiAgICByZ2I6IChjMikgPT4gY29udmVydExhYlRvTGNoKGNvbnZlcnRSZ2JUb0xhYihjMikpLFxuICAgIGxhYjogY29udmVydExhYlRvTGNoXG4gIH0sXG4gIGNoYW5uZWxzOiBbXCJsXCIsIFwiY1wiLCBcImhcIiwgXCJhbHBoYVwiXSxcbiAgcmFuZ2VzOiB7XG4gICAgbDogWzAsIDEwMF0sXG4gICAgYzogWzAsIDE1MF0sXG4gICAgaDogWzAsIDM2MF1cbiAgfSxcbiAgcGFyc2U6IFtwYXJzZUxjaF0sXG4gIHNlcmlhbGl6ZTogKGMyKSA9PiBgbGNoKCR7YzIubCAhPT0gdm9pZCAwID8gYzIubCA6IFwibm9uZVwifSAke2MyLmMgIT09IHZvaWQgMCA/IGMyLmMgOiBcIm5vbmVcIn0gJHtjMi5oICE9PSB2b2lkIDAgPyBjMi5oIDogXCJub25lXCJ9JHtjMi5hbHBoYSA8IDEgPyBgIC8gJHtjMi5hbHBoYX1gIDogXCJcIn0pYCxcbiAgaW50ZXJwb2xhdGU6IHtcbiAgICBoOiB7IHVzZTogaW50ZXJwb2xhdG9yTGluZWFyLCBmaXh1cDogZml4dXBIdWVTaG9ydGVyIH0sXG4gICAgYzogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGw6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhbHBoYTogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwQWxwaGEgfVxuICB9LFxuICBkaWZmZXJlbmNlOiB7XG4gICAgaDogZGlmZmVyZW5jZUh1ZUNocm9tYVxuICB9LFxuICBhdmVyYWdlOiB7XG4gICAgaDogYXZlcmFnZUFuZ2xlXG4gIH1cbn07XG5jb25zdCBkZWZpbml0aW9uJGMgPSB7XG4gIC4uLmRlZmluaXRpb24kZCxcbiAgbW9kZTogXCJsY2g2NVwiLFxuICBwYXJzZTogW1wiLS1sY2gtZDY1XCJdLFxuICBzZXJpYWxpemU6IFwiLS1sY2gtZDY1XCIsXG4gIHRvTW9kZToge1xuICAgIGxhYjY1OiAoYzIpID0+IGNvbnZlcnRMY2hUb0xhYihjMiwgXCJsYWI2NVwiKSxcbiAgICByZ2I6IChjMikgPT4gY29udmVydExhYjY1VG9SZ2IoY29udmVydExjaFRvTGFiKGMyLCBcImxhYjY1XCIpKVxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHJnYjogKGMyKSA9PiBjb252ZXJ0TGFiVG9MY2goY29udmVydFJnYlRvTGFiNjUoYzIpLCBcImxjaDY1XCIpLFxuICAgIGxhYjY1OiAoYzIpID0+IGNvbnZlcnRMYWJUb0xjaChjMiwgXCJsY2g2NVwiKVxuICB9LFxuICByYW5nZXM6IHtcbiAgICBsOiBbMCwgMTAwXSxcbiAgICBjOiBbMCwgMTUwXSxcbiAgICBoOiBbMCwgMzYwXVxuICB9XG59O1xuY29uc3QgY29udmVydEx1dlRvTGNodXYgPSAoeyBsLCB1LCB2LCBhbHBoYSB9KSA9PiB7XG4gIGlmICh1ID09PSB2b2lkIDApIHUgPSAwO1xuICBpZiAodiA9PT0gdm9pZCAwKSB2ID0gMDtcbiAgbGV0IGMyID0gTWF0aC5zcXJ0KHUgKiB1ICsgdiAqIHYpO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwibGNodXZcIixcbiAgICBsLFxuICAgIGM6IGMyXG4gIH07XG4gIGlmIChjMikge1xuICAgIHJlcy5oID0gbm9ybWFsaXplSHVlKE1hdGguYXRhbjIodiwgdSkgKiAxODAgLyBNYXRoLlBJKTtcbiAgfVxuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydExjaHV2VG9MdXYgPSAoeyBsLCBjOiBjMiwgaCwgYWxwaGEgfSkgPT4ge1xuICBpZiAoaCA9PT0gdm9pZCAwKSBoID0gMDtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcImx1dlwiLFxuICAgIGwsXG4gICAgdTogYzIgPyBjMiAqIE1hdGguY29zKGggLyAxODAgKiBNYXRoLlBJKSA6IDAsXG4gICAgdjogYzIgPyBjMiAqIE1hdGguc2luKGggLyAxODAgKiBNYXRoLlBJKSA6IDBcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBhbHBoYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IHVfZm4kMSA9ICh4LCB5LCB6KSA9PiA0ICogeCAvICh4ICsgMTUgKiB5ICsgMyAqIHopO1xuY29uc3Qgdl9mbiQxID0gKHgsIHksIHopID0+IDkgKiB5IC8gKHggKyAxNSAqIHkgKyAzICogeik7XG5jb25zdCB1biQxID0gdV9mbiQxKEQ1MC5YLCBENTAuWSwgRDUwLlopO1xuY29uc3Qgdm4kMSA9IHZfZm4kMShENTAuWCwgRDUwLlksIEQ1MC5aKTtcbmNvbnN0IGxfZm4gPSAodmFsdWUpID0+IHZhbHVlIDw9IGUgPyBrICogdmFsdWUgOiAxMTYgKiBNYXRoLmNicnQodmFsdWUpIC0gMTY7XG5jb25zdCBjb252ZXJ0WHl6NTBUb0x1diA9ICh7IHgsIHksIHosIGFscGhhIH0pID0+IHtcbiAgaWYgKHggPT09IHZvaWQgMCkgeCA9IDA7XG4gIGlmICh5ID09PSB2b2lkIDApIHkgPSAwO1xuICBpZiAoeiA9PT0gdm9pZCAwKSB6ID0gMDtcbiAgbGV0IGwgPSBsX2ZuKHkgLyBENTAuWSk7XG4gIGxldCB1ID0gdV9mbiQxKHgsIHksIHopO1xuICBsZXQgdiA9IHZfZm4kMSh4LCB5LCB6KTtcbiAgaWYgKCFpc0Zpbml0ZSh1KSB8fCAhaXNGaW5pdGUodikpIHtcbiAgICBsID0gdSA9IHYgPSAwO1xuICB9IGVsc2Uge1xuICAgIHUgPSAxMyAqIGwgKiAodSAtIHVuJDEpO1xuICAgIHYgPSAxMyAqIGwgKiAodiAtIHZuJDEpO1xuICB9XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJsdXZcIixcbiAgICBsLFxuICAgIHUsXG4gICAgdlxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgdV9mbiA9ICh4LCB5LCB6KSA9PiA0ICogeCAvICh4ICsgMTUgKiB5ICsgMyAqIHopO1xuY29uc3Qgdl9mbiA9ICh4LCB5LCB6KSA9PiA5ICogeSAvICh4ICsgMTUgKiB5ICsgMyAqIHopO1xuY29uc3QgdW4gPSB1X2ZuKEQ1MC5YLCBENTAuWSwgRDUwLlopO1xuY29uc3Qgdm4gPSB2X2ZuKEQ1MC5YLCBENTAuWSwgRDUwLlopO1xuY29uc3QgY29udmVydEx1dlRvWHl6NTAgPSAoeyBsLCB1LCB2LCBhbHBoYSB9KSA9PiB7XG4gIGlmIChsID09PSB2b2lkIDApIGwgPSAwO1xuICBpZiAobCA9PT0gMCkge1xuICAgIHJldHVybiB7IG1vZGU6IFwieHl6NTBcIiwgeDogMCwgeTogMCwgejogMCB9O1xuICB9XG4gIGlmICh1ID09PSB2b2lkIDApIHUgPSAwO1xuICBpZiAodiA9PT0gdm9pZCAwKSB2ID0gMDtcbiAgbGV0IHVwID0gdSAvICgxMyAqIGwpICsgdW47XG4gIGxldCB2cCA9IHYgLyAoMTMgKiBsKSArIHZuO1xuICBsZXQgeSA9IEQ1MC5ZICogKGwgPD0gOCA/IGwgLyBrIDogTWF0aC5wb3coKGwgKyAxNikgLyAxMTYsIDMpKTtcbiAgbGV0IHggPSB5ICogKDkgKiB1cCkgLyAoNCAqIHZwKTtcbiAgbGV0IHogPSB5ICogKDEyIC0gMyAqIHVwIC0gMjAgKiB2cCkgLyAoNCAqIHZwKTtcbiAgbGV0IHJlcyA9IHsgbW9kZTogXCJ4eXo1MFwiLCB4LCB5LCB6IH07XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBjb252ZXJ0UmdiVG9MY2h1diA9IChyZ2IpID0+IGNvbnZlcnRMdXZUb0xjaHV2KGNvbnZlcnRYeXo1MFRvTHV2KGNvbnZlcnRSZ2JUb1h5ejUwKHJnYikpKTtcbmNvbnN0IGNvbnZlcnRMY2h1dlRvUmdiID0gKGxjaHV2KSA9PiBjb252ZXJ0WHl6NTBUb1JnYihjb252ZXJ0THV2VG9YeXo1MChjb252ZXJ0TGNodXZUb0x1dihsY2h1dikpKTtcbmNvbnN0IGRlZmluaXRpb24kYiA9IHtcbiAgbW9kZTogXCJsY2h1dlwiLFxuICB0b01vZGU6IHtcbiAgICBsdXY6IGNvbnZlcnRMY2h1dlRvTHV2LFxuICAgIHJnYjogY29udmVydExjaHV2VG9SZ2JcbiAgfSxcbiAgZnJvbU1vZGU6IHtcbiAgICByZ2I6IGNvbnZlcnRSZ2JUb0xjaHV2LFxuICAgIGx1djogY29udmVydEx1dlRvTGNodXZcbiAgfSxcbiAgY2hhbm5lbHM6IFtcImxcIiwgXCJjXCIsIFwiaFwiLCBcImFscGhhXCJdLFxuICBwYXJzZTogW1wiLS1sY2h1dlwiXSxcbiAgc2VyaWFsaXplOiBcIi0tbGNodXZcIixcbiAgcmFuZ2VzOiB7XG4gICAgbDogWzAsIDEwMF0sXG4gICAgYzogWzAsIDE3Ni45NTZdLFxuICAgIGg6IFswLCAzNjBdXG4gIH0sXG4gIGludGVycG9sYXRlOiB7XG4gICAgaDogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwSHVlU2hvcnRlciB9LFxuICAgIGM6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBsOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYWxwaGE6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEFscGhhIH1cbiAgfSxcbiAgZGlmZmVyZW5jZToge1xuICAgIGg6IGRpZmZlcmVuY2VIdWVDaHJvbWFcbiAgfSxcbiAgYXZlcmFnZToge1xuICAgIGg6IGF2ZXJhZ2VBbmdsZVxuICB9XG59O1xuY29uc3QgZGVmaW5pdGlvbiRhID0ge1xuICAuLi5kZWZpbml0aW9uJHIsXG4gIG1vZGU6IFwibHJnYlwiLFxuICB0b01vZGU6IHtcbiAgICByZ2I6IGNvbnZlcnRMcmdiVG9SZ2JcbiAgfSxcbiAgZnJvbU1vZGU6IHtcbiAgICByZ2I6IGNvbnZlcnRSZ2JUb0xyZ2JcbiAgfSxcbiAgcGFyc2U6IFtcInNyZ2ItbGluZWFyXCJdLFxuICBzZXJpYWxpemU6IFwic3JnYi1saW5lYXJcIlxufTtcbmNvbnN0IGRlZmluaXRpb24kOSA9IHtcbiAgbW9kZTogXCJsdXZcIixcbiAgdG9Nb2RlOiB7XG4gICAgeHl6NTA6IGNvbnZlcnRMdXZUb1h5ejUwLFxuICAgIHJnYjogKGx1dikgPT4gY29udmVydFh5ejUwVG9SZ2IoY29udmVydEx1dlRvWHl6NTAobHV2KSlcbiAgfSxcbiAgZnJvbU1vZGU6IHtcbiAgICB4eXo1MDogY29udmVydFh5ejUwVG9MdXYsXG4gICAgcmdiOiAocmdiKSA9PiBjb252ZXJ0WHl6NTBUb0x1dihjb252ZXJ0UmdiVG9YeXo1MChyZ2IpKVxuICB9LFxuICBjaGFubmVsczogW1wibFwiLCBcInVcIiwgXCJ2XCIsIFwiYWxwaGFcIl0sXG4gIHBhcnNlOiBbXCItLWx1dlwiXSxcbiAgc2VyaWFsaXplOiBcIi0tbHV2XCIsXG4gIHJhbmdlczoge1xuICAgIGw6IFswLCAxMDBdLFxuICAgIHU6IFstODQuOTM2LCAxNzUuMDQyXSxcbiAgICB2OiBbLTEyNS44ODIsIDg3LjI0M11cbiAgfSxcbiAgaW50ZXJwb2xhdGU6IHtcbiAgICBsOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgdTogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIHY6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBhbHBoYTogeyB1c2U6IGludGVycG9sYXRvckxpbmVhciwgZml4dXA6IGZpeHVwQWxwaGEgfVxuICB9XG59O1xuY29uc3QgY29udmVydExyZ2JUb09rbGFiID0gKHsgciwgZywgYiwgYWxwaGEgfSkgPT4ge1xuICBpZiAociA9PT0gdm9pZCAwKSByID0gMDtcbiAgaWYgKGcgPT09IHZvaWQgMCkgZyA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBsZXQgTCA9IE1hdGguY2JydChcbiAgICAwLjQxMjIyMTQ2OTQ3MDc2MyAqIHIgKyAwLjUzNjMzMjUzNzI2MTczNDggKiBnICsgMC4wNTE0NDU5OTMyNjc1MDIyICogYlxuICApO1xuICBsZXQgTTMgPSBNYXRoLmNicnQoXG4gICAgMC4yMTE5MDM0OTU4MTc4MjUyICogciArIDAuNjgwNjk5NTUwNjQ1MjM0NCAqIGcgKyAwLjEwNzM5Njk1MzUzNjk0MDYgKiBiXG4gICk7XG4gIGxldCBTID0gTWF0aC5jYnJ0KFxuICAgIDAuMDg4MzAyNDU5MTkwMDU2NCAqIHIgKyAwLjI4MTcxODgzOTEzNjEyMTUgKiBnICsgMC42Mjk5Nzg3MDE2NzM4MjIyICogYlxuICApO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwib2tsYWJcIixcbiAgICBsOiAwLjIxMDQ1NDI2ODMwOTMxNCAqIEwgKyAwLjc5MzYxNzc3NDcwMjMwNTQgKiBNMyAtIDAuMDA0MDcyMDQzMDExNjE5MyAqIFMsXG4gICAgYTogMS45Nzc5OTg1MzI0MzExNjg0ICogTCAtIDIuNDI4NTkyMjQyMDQ4NTggKiBNMyArIDAuNDUwNTkzNzA5NjE3NDExICogUyxcbiAgICBiOiAwLjAyNTkwNDA0MjQ2NTU0NzggKiBMICsgMC43ODI3NzE3MTI0NTc1Mjk2ICogTTMgLSAwLjgwODY3NTc1NDkyMzA3NzQgKiBTXG4gIH07XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBjb252ZXJ0UmdiVG9Pa2xhYiA9IChyZ2IpID0+IHtcbiAgbGV0IHJlcyA9IGNvbnZlcnRMcmdiVG9Pa2xhYihjb252ZXJ0UmdiVG9McmdiKHJnYikpO1xuICBpZiAocmdiLnIgPT09IHJnYi5iICYmIHJnYi5iID09PSByZ2IuZykge1xuICAgIHJlcy5hID0gcmVzLmIgPSAwO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydE9rbGFiVG9McmdiID0gKHsgbCwgYSwgYiwgYWxwaGEgfSkgPT4ge1xuICBpZiAobCA9PT0gdm9pZCAwKSBsID0gMDtcbiAgaWYgKGEgPT09IHZvaWQgMCkgYSA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBsZXQgTCA9IE1hdGgucG93KGwgKyAwLjM5NjMzNzc3NzM3NjE3NDkgKiBhICsgMC4yMTU4MDM3NTczMDk5MTM2ICogYiwgMyk7XG4gIGxldCBNMyA9IE1hdGgucG93KGwgLSAwLjEwNTU2MTM0NTgxNTY1ODYgKiBhIC0gMC4wNjM4NTQxNzI4MjU4MTMzICogYiwgMyk7XG4gIGxldCBTID0gTWF0aC5wb3cobCAtIDAuMDg5NDg0MTc3NTI5ODExOSAqIGEgLSAxLjI5MTQ4NTU0ODAxOTQwOTIgKiBiLCAzKTtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcImxyZ2JcIixcbiAgICByOiA0LjA3Njc0MTYzNjA3NTk1NyAqIEwgLSAzLjMwNzcxMTUzOTI1ODA2MTYgKiBNMyArIDAuMjMwOTY5OTAzMTgyMTA0NCAqIFMsXG4gICAgZzogLTEuMjY4NDM3OTczMjg1MDMxNyAqIEwgKyAyLjYwOTc1NzM0OTI4NzY4ODcgKiBNMyAtIDAuMzQxMzE5Mzc2MDAyNjU3MyAqIFMsXG4gICAgYjogLTAuMDA0MTk2MDc2MTM4Njc1NiAqIEwgLSAwLjcwMzQxODYxNzkzNTkzNjIgKiBNMyArIDEuNzA3NjE0Njk0MDc0NjExNyAqIFNcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBhbHBoYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGNvbnZlcnRPa2xhYlRvUmdiID0gKGMyKSA9PiBjb252ZXJ0THJnYlRvUmdiKGNvbnZlcnRPa2xhYlRvTHJnYihjMikpO1xuZnVuY3Rpb24gdG9lKHgpIHtcbiAgY29uc3Qga18xID0gMC4yMDY7XG4gIGNvbnN0IGtfMiA9IDAuMDM7XG4gIGNvbnN0IGtfMyA9ICgxICsga18xKSAvICgxICsga18yKTtcbiAgcmV0dXJuIDAuNSAqIChrXzMgKiB4IC0ga18xICsgTWF0aC5zcXJ0KChrXzMgKiB4IC0ga18xKSAqIChrXzMgKiB4IC0ga18xKSArIDQgKiBrXzIgKiBrXzMgKiB4KSk7XG59XG5mdW5jdGlvbiB0b2VfaW52KHgpIHtcbiAgY29uc3Qga18xID0gMC4yMDY7XG4gIGNvbnN0IGtfMiA9IDAuMDM7XG4gIGNvbnN0IGtfMyA9ICgxICsga18xKSAvICgxICsga18yKTtcbiAgcmV0dXJuICh4ICogeCArIGtfMSAqIHgpIC8gKGtfMyAqICh4ICsga18yKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlX21heF9zYXR1cmF0aW9uKGEsIGIpIHtcbiAgbGV0IGswLCBrMSwgazIsIGszLCBrNCwgd2wsIHdtLCB3cztcbiAgaWYgKC0xLjg4MTcwMzI4ICogYSAtIDAuODA5MzY0OTMgKiBiID4gMSkge1xuICAgIGswID0gMS4xOTA4NjI3NztcbiAgICBrMSA9IDEuNzY1NzY3Mjg7XG4gICAgazIgPSAwLjU5NjYyNjQxO1xuICAgIGszID0gMC43NTUxNTE5NztcbiAgICBrNCA9IDAuNTY3NzEyNDU7XG4gICAgd2wgPSA0LjA3Njc0MTY2MjE7XG4gICAgd20gPSAtMy4zMDc3MTE1OTEzO1xuICAgIHdzID0gMC4yMzA5Njk5MjkyO1xuICB9IGVsc2UgaWYgKDEuODE0NDQxMDQgKiBhIC0gMS4xOTQ0NTI3NiAqIGIgPiAxKSB7XG4gICAgazAgPSAwLjczOTU2NTE1O1xuICAgIGsxID0gLTAuNDU5NTQ0MDQ7XG4gICAgazIgPSAwLjA4Mjg1NDI3O1xuICAgIGszID0gMC4xMjU0MTA3O1xuICAgIGs0ID0gMC4xNDUwMzIwNDtcbiAgICB3bCA9IC0xLjI2ODQzODAwNDY7XG4gICAgd20gPSAyLjYwOTc1NzQwMTE7XG4gICAgd3MgPSAtMC4zNDEzMTkzOTY1O1xuICB9IGVsc2Uge1xuICAgIGswID0gMS4zNTczMzY1MjtcbiAgICBrMSA9IC05MTU3OTllLTg7XG4gICAgazIgPSAtMS4xNTEzMDIxO1xuICAgIGszID0gLTAuNTA1NTk2MDY7XG4gICAgazQgPSA2OTIxNjdlLTg7XG4gICAgd2wgPSAtMC4wMDQxOTYwODYzO1xuICAgIHdtID0gLTAuNzAzNDE4NjE0NztcbiAgICB3cyA9IDEuNzA3NjE0NzAxO1xuICB9XG4gIGxldCBTID0gazAgKyBrMSAqIGEgKyBrMiAqIGIgKyBrMyAqIGEgKiBhICsgazQgKiBhICogYjtcbiAgbGV0IGtfbCA9IDAuMzk2MzM3Nzc3NCAqIGEgKyAwLjIxNTgwMzc1NzMgKiBiO1xuICBsZXQga19tID0gLTAuMTA1NTYxMzQ1OCAqIGEgLSAwLjA2Mzg1NDE3MjggKiBiO1xuICBsZXQga19zID0gLTAuMDg5NDg0MTc3NSAqIGEgLSAxLjI5MTQ4NTU0OCAqIGI7XG4gIHtcbiAgICBsZXQgbF8gPSAxICsgUyAqIGtfbDtcbiAgICBsZXQgbV8gPSAxICsgUyAqIGtfbTtcbiAgICBsZXQgc18gPSAxICsgUyAqIGtfcztcbiAgICBsZXQgbCA9IGxfICogbF8gKiBsXztcbiAgICBsZXQgbSA9IG1fICogbV8gKiBtXztcbiAgICBsZXQgcyA9IHNfICogc18gKiBzXztcbiAgICBsZXQgbF9kUyA9IDMgKiBrX2wgKiBsXyAqIGxfO1xuICAgIGxldCBtX2RTID0gMyAqIGtfbSAqIG1fICogbV87XG4gICAgbGV0IHNfZFMgPSAzICoga19zICogc18gKiBzXztcbiAgICBsZXQgbF9kUzIgPSA2ICoga19sICoga19sICogbF87XG4gICAgbGV0IG1fZFMyID0gNiAqIGtfbSAqIGtfbSAqIG1fO1xuICAgIGxldCBzX2RTMiA9IDYgKiBrX3MgKiBrX3MgKiBzXztcbiAgICBsZXQgZjIgPSB3bCAqIGwgKyB3bSAqIG0gKyB3cyAqIHM7XG4gICAgbGV0IGYxID0gd2wgKiBsX2RTICsgd20gKiBtX2RTICsgd3MgKiBzX2RTO1xuICAgIGxldCBmMjIgPSB3bCAqIGxfZFMyICsgd20gKiBtX2RTMiArIHdzICogc19kUzI7XG4gICAgUyA9IFMgLSBmMiAqIGYxIC8gKGYxICogZjEgLSAwLjUgKiBmMiAqIGYyMik7XG4gIH1cbiAgcmV0dXJuIFM7XG59XG5mdW5jdGlvbiBmaW5kX2N1c3AoYSwgYikge1xuICBsZXQgU19jdXNwID0gY29tcHV0ZV9tYXhfc2F0dXJhdGlvbihhLCBiKTtcbiAgbGV0IHJnYiA9IGNvbnZlcnRPa2xhYlRvTHJnYih7IGw6IDEsIGE6IFNfY3VzcCAqIGEsIGI6IFNfY3VzcCAqIGIgfSk7XG4gIGxldCBMX2N1c3AgPSBNYXRoLmNicnQoMSAvIE1hdGgubWF4KHJnYi5yLCByZ2IuZywgcmdiLmIpKTtcbiAgbGV0IENfY3VzcCA9IExfY3VzcCAqIFNfY3VzcDtcbiAgcmV0dXJuIFtMX2N1c3AsIENfY3VzcF07XG59XG5mdW5jdGlvbiBmaW5kX2dhbXV0X2ludGVyc2VjdGlvbihhLCBiLCBMMSwgQzEyLCBMMCwgY3VzcCA9IG51bGwpIHtcbiAgaWYgKCFjdXNwKSB7XG4gICAgY3VzcCA9IGZpbmRfY3VzcChhLCBiKTtcbiAgfVxuICBsZXQgdDtcbiAgaWYgKChMMSAtIEwwKSAqIGN1c3BbMV0gLSAoY3VzcFswXSAtIEwwKSAqIEMxMiA8PSAwKSB7XG4gICAgdCA9IGN1c3BbMV0gKiBMMCAvIChDMTIgKiBjdXNwWzBdICsgY3VzcFsxXSAqIChMMCAtIEwxKSk7XG4gIH0gZWxzZSB7XG4gICAgdCA9IGN1c3BbMV0gKiAoTDAgLSAxKSAvIChDMTIgKiAoY3VzcFswXSAtIDEpICsgY3VzcFsxXSAqIChMMCAtIEwxKSk7XG4gICAge1xuICAgICAgbGV0IGRMID0gTDEgLSBMMDtcbiAgICAgIGxldCBkQyA9IEMxMjtcbiAgICAgIGxldCBrX2wgPSAwLjM5NjMzNzc3NzQgKiBhICsgMC4yMTU4MDM3NTczICogYjtcbiAgICAgIGxldCBrX20gPSAtMC4xMDU1NjEzNDU4ICogYSAtIDAuMDYzODU0MTcyOCAqIGI7XG4gICAgICBsZXQga19zID0gLTAuMDg5NDg0MTc3NSAqIGEgLSAxLjI5MTQ4NTU0OCAqIGI7XG4gICAgICBsZXQgbF9kdCA9IGRMICsgZEMgKiBrX2w7XG4gICAgICBsZXQgbV9kdCA9IGRMICsgZEMgKiBrX207XG4gICAgICBsZXQgc19kdCA9IGRMICsgZEMgKiBrX3M7XG4gICAgICB7XG4gICAgICAgIGxldCBMID0gTDAgKiAoMSAtIHQpICsgdCAqIEwxO1xuICAgICAgICBsZXQgQyA9IHQgKiBDMTI7XG4gICAgICAgIGxldCBsXyA9IEwgKyBDICoga19sO1xuICAgICAgICBsZXQgbV8gPSBMICsgQyAqIGtfbTtcbiAgICAgICAgbGV0IHNfID0gTCArIEMgKiBrX3M7XG4gICAgICAgIGxldCBsID0gbF8gKiBsXyAqIGxfO1xuICAgICAgICBsZXQgbSA9IG1fICogbV8gKiBtXztcbiAgICAgICAgbGV0IHMgPSBzXyAqIHNfICogc187XG4gICAgICAgIGxldCBsZHQgPSAzICogbF9kdCAqIGxfICogbF87XG4gICAgICAgIGxldCBtZHQgPSAzICogbV9kdCAqIG1fICogbV87XG4gICAgICAgIGxldCBzZHQgPSAzICogc19kdCAqIHNfICogc187XG4gICAgICAgIGxldCBsZHQyID0gNiAqIGxfZHQgKiBsX2R0ICogbF87XG4gICAgICAgIGxldCBtZHQyID0gNiAqIG1fZHQgKiBtX2R0ICogbV87XG4gICAgICAgIGxldCBzZHQyID0gNiAqIHNfZHQgKiBzX2R0ICogc187XG4gICAgICAgIGxldCByID0gNC4wNzY3NDE2NjIxICogbCAtIDMuMzA3NzExNTkxMyAqIG0gKyAwLjIzMDk2OTkyOTIgKiBzIC0gMTtcbiAgICAgICAgbGV0IHIxID0gNC4wNzY3NDE2NjIxICogbGR0IC0gMy4zMDc3MTE1OTEzICogbWR0ICsgMC4yMzA5Njk5MjkyICogc2R0O1xuICAgICAgICBsZXQgcjIgPSA0LjA3Njc0MTY2MjEgKiBsZHQyIC0gMy4zMDc3MTE1OTEzICogbWR0MiArIDAuMjMwOTY5OTI5MiAqIHNkdDI7XG4gICAgICAgIGxldCB1X3IgPSByMSAvIChyMSAqIHIxIC0gMC41ICogciAqIHIyKTtcbiAgICAgICAgbGV0IHRfciA9IC1yICogdV9yO1xuICAgICAgICBsZXQgZyA9IC0xLjI2ODQzODAwNDYgKiBsICsgMi42MDk3NTc0MDExICogbSAtIDAuMzQxMzE5Mzk2NSAqIHMgLSAxO1xuICAgICAgICBsZXQgZzEgPSAtMS4yNjg0MzgwMDQ2ICogbGR0ICsgMi42MDk3NTc0MDExICogbWR0IC0gMC4zNDEzMTkzOTY1ICogc2R0O1xuICAgICAgICBsZXQgZzIgPSAtMS4yNjg0MzgwMDQ2ICogbGR0MiArIDIuNjA5NzU3NDAxMSAqIG1kdDIgLSAwLjM0MTMxOTM5NjUgKiBzZHQyO1xuICAgICAgICBsZXQgdV9nID0gZzEgLyAoZzEgKiBnMSAtIDAuNSAqIGcgKiBnMik7XG4gICAgICAgIGxldCB0X2cgPSAtZyAqIHVfZztcbiAgICAgICAgbGV0IGIyID0gLTAuMDA0MTk2MDg2MyAqIGwgLSAwLjcwMzQxODYxNDcgKiBtICsgMS43MDc2MTQ3MDEgKiBzIC0gMTtcbiAgICAgICAgbGV0IGIxID0gLTAuMDA0MTk2MDg2MyAqIGxkdCAtIDAuNzAzNDE4NjE0NyAqIG1kdCArIDEuNzA3NjE0NzAxICogc2R0O1xuICAgICAgICBsZXQgYjIyID0gLTAuMDA0MTk2MDg2MyAqIGxkdDIgLSAwLjcwMzQxODYxNDcgKiBtZHQyICsgMS43MDc2MTQ3MDEgKiBzZHQyO1xuICAgICAgICBsZXQgdV9iID0gYjEgLyAoYjEgKiBiMSAtIDAuNSAqIGIyICogYjIyKTtcbiAgICAgICAgbGV0IHRfYiA9IC1iMiAqIHVfYjtcbiAgICAgICAgdF9yID0gdV9yID49IDAgPyB0X3IgOiAxZTY7XG4gICAgICAgIHRfZyA9IHVfZyA+PSAwID8gdF9nIDogMWU2O1xuICAgICAgICB0X2IgPSB1X2IgPj0gMCA/IHRfYiA6IDFlNjtcbiAgICAgICAgdCArPSBNYXRoLm1pbih0X3IsIE1hdGgubWluKHRfZywgdF9iKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gZ2V0X1NUX21heChhXywgYl8sIGN1c3AgPSBudWxsKSB7XG4gIGlmICghY3VzcCkge1xuICAgIGN1c3AgPSBmaW5kX2N1c3AoYV8sIGJfKTtcbiAgfVxuICBsZXQgTCA9IGN1c3BbMF07XG4gIGxldCBDID0gY3VzcFsxXTtcbiAgcmV0dXJuIFtDIC8gTCwgQyAvICgxIC0gTCldO1xufVxuZnVuY3Rpb24gZ2V0X0NzKEwsIGFfLCBiXykge1xuICBsZXQgY3VzcCA9IGZpbmRfY3VzcChhXywgYl8pO1xuICBsZXQgQ19tYXggPSBmaW5kX2dhbXV0X2ludGVyc2VjdGlvbihhXywgYl8sIEwsIDEsIEwsIGN1c3ApO1xuICBsZXQgU1RfbWF4ID0gZ2V0X1NUX21heChhXywgYl8sIGN1c3ApO1xuICBsZXQgU19taWQgPSAwLjExNTE2OTkzICsgMSAvICg3LjQ0Nzc4OTcgKyA0LjE1OTAxMjQgKiBiXyArIGFfICogKC0yLjE5NTU3MzQ3ICsgMS43NTE5ODQwMSAqIGJfICsgYV8gKiAoLTIuMTM3MDQ5NDggLSAxMC4wMjMwMTA0MyAqIGJfICsgYV8gKiAoLTQuMjQ4OTQ1NjEgKyA1LjM4NzcwODE5ICogYl8gKyA0LjY5ODkxMDEzICogYV8pKSkpO1xuICBsZXQgVF9taWQgPSAwLjExMjM5NjQyICsgMSAvICgxLjYxMzIwMzIgLSAwLjY4MTI0Mzc5ICogYl8gKyBhXyAqICgwLjQwMzcwNjEyICsgMC45MDE0ODEyMyAqIGJfICsgYV8gKiAoLTAuMjcwODc5NDMgKyAwLjYxMjIzOTkgKiBiXyArIGFfICogKDI5OTIxNWUtOCAtIDAuNDUzOTk1NjggKiBiXyAtIDAuMTQ2NjE4NzIgKiBhXykpKSk7XG4gIGxldCBrMiA9IENfbWF4IC8gTWF0aC5taW4oTCAqIFNUX21heFswXSwgKDEgLSBMKSAqIFNUX21heFsxXSk7XG4gIGxldCBDX2EgPSBMICogU19taWQ7XG4gIGxldCBDX2IgPSAoMSAtIEwpICogVF9taWQ7XG4gIGxldCBDX21pZCA9IDAuOSAqIGsyICogTWF0aC5zcXJ0KFxuICAgIE1hdGguc3FydChcbiAgICAgIDEgLyAoMSAvIChDX2EgKiBDX2EgKiBDX2EgKiBDX2EpICsgMSAvIChDX2IgKiBDX2IgKiBDX2IgKiBDX2IpKVxuICAgIClcbiAgKTtcbiAgQ19hID0gTCAqIDAuNDtcbiAgQ19iID0gKDEgLSBMKSAqIDAuODtcbiAgbGV0IENfMCA9IE1hdGguc3FydCgxIC8gKDEgLyAoQ19hICogQ19hKSArIDEgLyAoQ19iICogQ19iKSkpO1xuICByZXR1cm4gW0NfMCwgQ19taWQsIENfbWF4XTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPa2xhYlRvT2toc2wobGFiKSB7XG4gIGNvbnN0IGwgPSBsYWIubCAhPT0gdm9pZCAwID8gbGFiLmwgOiAwO1xuICBjb25zdCBhID0gbGFiLmEgIT09IHZvaWQgMCA/IGxhYi5hIDogMDtcbiAgY29uc3QgYiA9IGxhYi5iICE9PSB2b2lkIDAgPyBsYWIuYiA6IDA7XG4gIGNvbnN0IHJldCA9IHsgbW9kZTogXCJva2hzbFwiLCBsOiB0b2UobCkgfTtcbiAgaWYgKGxhYi5hbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0LmFscGhhID0gbGFiLmFscGhhO1xuICB9XG4gIGxldCBjMiA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgaWYgKCFjMikge1xuICAgIHJldC5zID0gMDtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGxldCBbQ18wLCBDX21pZCwgQ19tYXhdID0gZ2V0X0NzKGwsIGEgLyBjMiwgYiAvIGMyKTtcbiAgbGV0IHM7XG4gIGlmIChjMiA8IENfbWlkKSB7XG4gICAgbGV0IGtfMCA9IDA7XG4gICAgbGV0IGtfMSA9IDAuOCAqIENfMDtcbiAgICBsZXQga18yID0gMSAtIGtfMSAvIENfbWlkO1xuICAgIGxldCB0ID0gKGMyIC0ga18wKSAvIChrXzEgKyBrXzIgKiAoYzIgLSBrXzApKTtcbiAgICBzID0gdCAqIDAuODtcbiAgfSBlbHNlIHtcbiAgICBsZXQga18wID0gQ19taWQ7XG4gICAgbGV0IGtfMSA9IDAuMiAqIENfbWlkICogQ19taWQgKiAxLjI1ICogMS4yNSAvIENfMDtcbiAgICBsZXQga18yID0gMSAtIGtfMSAvIChDX21heCAtIENfbWlkKTtcbiAgICBsZXQgdCA9IChjMiAtIGtfMCkgLyAoa18xICsga18yICogKGMyIC0ga18wKSk7XG4gICAgcyA9IDAuOCArIDAuMiAqIHQ7XG4gIH1cbiAgaWYgKHMpIHtcbiAgICByZXQucyA9IHM7XG4gICAgcmV0LmggPSBub3JtYWxpemVIdWUoTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2toc2xUb09rbGFiKGhzbCkge1xuICBsZXQgaCA9IGhzbC5oICE9PSB2b2lkIDAgPyBoc2wuaCA6IDA7XG4gIGxldCBzID0gaHNsLnMgIT09IHZvaWQgMCA/IGhzbC5zIDogMDtcbiAgbGV0IGwgPSBoc2wubCAhPT0gdm9pZCAwID8gaHNsLmwgOiAwO1xuICBjb25zdCByZXQgPSB7IG1vZGU6IFwib2tsYWJcIiwgbDogdG9lX2ludihsKSB9O1xuICBpZiAoaHNsLmFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXQuYWxwaGEgPSBoc2wuYWxwaGE7XG4gIH1cbiAgaWYgKCFzIHx8IGwgPT09IDEpIHtcbiAgICByZXQuYSA9IHJldC5iID0gMDtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGxldCBhXyA9IE1hdGguY29zKGggLyAxODAgKiBNYXRoLlBJKTtcbiAgbGV0IGJfID0gTWF0aC5zaW4oaCAvIDE4MCAqIE1hdGguUEkpO1xuICBsZXQgW0NfMCwgQ19taWQsIENfbWF4XSA9IGdldF9DcyhyZXQubCwgYV8sIGJfKTtcbiAgbGV0IHQsIGtfMCwga18xLCBrXzI7XG4gIGlmIChzIDwgMC44KSB7XG4gICAgdCA9IDEuMjUgKiBzO1xuICAgIGtfMCA9IDA7XG4gICAga18xID0gMC44ICogQ18wO1xuICAgIGtfMiA9IDEgLSBrXzEgLyBDX21pZDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gNSAqIChzIC0gMC44KTtcbiAgICBrXzAgPSBDX21pZDtcbiAgICBrXzEgPSAwLjIgKiBDX21pZCAqIENfbWlkICogMS4yNSAqIDEuMjUgLyBDXzA7XG4gICAga18yID0gMSAtIGtfMSAvIChDX21heCAtIENfbWlkKTtcbiAgfVxuICBsZXQgQyA9IGtfMCArIHQgKiBrXzEgLyAoMSAtIGtfMiAqIHQpO1xuICByZXQuYSA9IEMgKiBhXztcbiAgcmV0LmIgPSBDICogYl87XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBtb2RlT2toc2wgPSB7XG4gIC4uLmRlZmluaXRpb24kbCxcbiAgbW9kZTogXCJva2hzbFwiLFxuICBjaGFubmVsczogW1wiaFwiLCBcInNcIiwgXCJsXCIsIFwiYWxwaGFcIl0sXG4gIHBhcnNlOiBbXCItLW9raHNsXCJdLFxuICBzZXJpYWxpemU6IFwiLS1va2hzbFwiLFxuICBmcm9tTW9kZToge1xuICAgIG9rbGFiOiBjb252ZXJ0T2tsYWJUb09raHNsLFxuICAgIHJnYjogKGMyKSA9PiBjb252ZXJ0T2tsYWJUb09raHNsKGNvbnZlcnRSZ2JUb09rbGFiKGMyKSlcbiAgfSxcbiAgdG9Nb2RlOiB7XG4gICAgb2tsYWI6IGNvbnZlcnRPa2hzbFRvT2tsYWIsXG4gICAgcmdiOiAoYzIpID0+IGNvbnZlcnRPa2xhYlRvUmdiKGNvbnZlcnRPa2hzbFRvT2tsYWIoYzIpKVxuICB9XG59O1xuZnVuY3Rpb24gY29udmVydE9rbGFiVG9Pa2hzdihsYWIpIHtcbiAgbGV0IGwgPSBsYWIubCAhPT0gdm9pZCAwID8gbGFiLmwgOiAwO1xuICBsZXQgYSA9IGxhYi5hICE9PSB2b2lkIDAgPyBsYWIuYSA6IDA7XG4gIGxldCBiID0gbGFiLmIgIT09IHZvaWQgMCA/IGxhYi5iIDogMDtcbiAgbGV0IGMyID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICBsZXQgYV8gPSBjMiA/IGEgLyBjMiA6IDE7XG4gIGxldCBiXyA9IGMyID8gYiAvIGMyIDogMTtcbiAgbGV0IFtTX21heCwgVF0gPSBnZXRfU1RfbWF4KGFfLCBiXyk7XG4gIGxldCBTXzAgPSAwLjU7XG4gIGxldCBrMiA9IDEgLSBTXzAgLyBTX21heDtcbiAgbGV0IHQgPSBUIC8gKGMyICsgbCAqIFQpO1xuICBsZXQgTF92ID0gdCAqIGw7XG4gIGxldCBDX3YgPSB0ICogYzI7XG4gIGxldCBMX3Z0ID0gdG9lX2ludihMX3YpO1xuICBsZXQgQ192dCA9IENfdiAqIExfdnQgLyBMX3Y7XG4gIGxldCByZ2Jfc2NhbGUgPSBjb252ZXJ0T2tsYWJUb0xyZ2IoeyBsOiBMX3Z0LCBhOiBhXyAqIENfdnQsIGI6IGJfICogQ192dCB9KTtcbiAgbGV0IHNjYWxlX0wgPSBNYXRoLmNicnQoXG4gICAgMSAvIE1hdGgubWF4KHJnYl9zY2FsZS5yLCByZ2Jfc2NhbGUuZywgcmdiX3NjYWxlLmIsIDApXG4gICk7XG4gIGwgPSBsIC8gc2NhbGVfTDtcbiAgYzIgPSBjMiAvIHNjYWxlX0wgKiB0b2UobCkgLyBsO1xuICBsID0gdG9lKGwpO1xuICBjb25zdCByZXQgPSB7XG4gICAgbW9kZTogXCJva2hzdlwiLFxuICAgIHM6IGMyID8gKFNfMCArIFQpICogQ192IC8gKFQgKiBTXzAgKyBUICogazIgKiBDX3YpIDogMCxcbiAgICB2OiBsID8gbCAvIExfdiA6IDBcbiAgfTtcbiAgaWYgKHJldC5zKSB7XG4gICAgcmV0LmggPSBub3JtYWxpemVIdWUoTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEkpO1xuICB9XG4gIGlmIChsYWIuYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJldC5hbHBoYSA9IGxhYi5hbHBoYTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gY29udmVydE9raHN2VG9Pa2xhYihoc3YpIHtcbiAgY29uc3QgcmV0ID0geyBtb2RlOiBcIm9rbGFiXCIgfTtcbiAgaWYgKGhzdi5hbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmV0LmFscGhhID0gaHN2LmFscGhhO1xuICB9XG4gIGNvbnN0IGggPSBoc3YuaCAhPT0gdm9pZCAwID8gaHN2LmggOiAwO1xuICBjb25zdCBzID0gaHN2LnMgIT09IHZvaWQgMCA/IGhzdi5zIDogMDtcbiAgY29uc3QgdiA9IGhzdi52ICE9PSB2b2lkIDAgPyBoc3YudiA6IDA7XG4gIGNvbnN0IGFfID0gTWF0aC5jb3MoaCAvIDE4MCAqIE1hdGguUEkpO1xuICBjb25zdCBiXyA9IE1hdGguc2luKGggLyAxODAgKiBNYXRoLlBJKTtcbiAgY29uc3QgW1NfbWF4LCBUXSA9IGdldF9TVF9tYXgoYV8sIGJfKTtcbiAgY29uc3QgU18wID0gMC41O1xuICBjb25zdCBrMiA9IDEgLSBTXzAgLyBTX21heDtcbiAgY29uc3QgTF92ID0gMSAtIHMgKiBTXzAgLyAoU18wICsgVCAtIFQgKiBrMiAqIHMpO1xuICBjb25zdCBDX3YgPSBzICogVCAqIFNfMCAvIChTXzAgKyBUIC0gVCAqIGsyICogcyk7XG4gIGNvbnN0IExfdnQgPSB0b2VfaW52KExfdik7XG4gIGNvbnN0IENfdnQgPSBDX3YgKiBMX3Z0IC8gTF92O1xuICBjb25zdCByZ2Jfc2NhbGUgPSBjb252ZXJ0T2tsYWJUb0xyZ2Ioe1xuICAgIGw6IExfdnQsXG4gICAgYTogYV8gKiBDX3Z0LFxuICAgIGI6IGJfICogQ192dFxuICB9KTtcbiAgY29uc3Qgc2NhbGVfTCA9IE1hdGguY2JydChcbiAgICAxIC8gTWF0aC5tYXgocmdiX3NjYWxlLnIsIHJnYl9zY2FsZS5nLCByZ2Jfc2NhbGUuYiwgMClcbiAgKTtcbiAgY29uc3QgTF9uZXcgPSB0b2VfaW52KHYgKiBMX3YpO1xuICBjb25zdCBDID0gQ192ICogTF9uZXcgLyBMX3Y7XG4gIHJldC5sID0gTF9uZXcgKiBzY2FsZV9MO1xuICByZXQuYSA9IEMgKiBhXyAqIHNjYWxlX0w7XG4gIHJldC5iID0gQyAqIGJfICogc2NhbGVfTDtcbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IG1vZGVPa2hzdiA9IHtcbiAgLi4uZGVmaW5pdGlvbiRrLFxuICBtb2RlOiBcIm9raHN2XCIsXG4gIGNoYW5uZWxzOiBbXCJoXCIsIFwic1wiLCBcInZcIiwgXCJhbHBoYVwiXSxcbiAgcGFyc2U6IFtcIi0tb2toc3ZcIl0sXG4gIHNlcmlhbGl6ZTogXCItLW9raHN2XCIsXG4gIGZyb21Nb2RlOiB7XG4gICAgb2tsYWI6IGNvbnZlcnRPa2xhYlRvT2toc3YsXG4gICAgcmdiOiAoYzIpID0+IGNvbnZlcnRPa2xhYlRvT2toc3YoY29udmVydFJnYlRvT2tsYWIoYzIpKVxuICB9LFxuICB0b01vZGU6IHtcbiAgICBva2xhYjogY29udmVydE9raHN2VG9Pa2xhYixcbiAgICByZ2I6IChjMikgPT4gY29udmVydE9rbGFiVG9SZ2IoY29udmVydE9raHN2VG9Pa2xhYihjMikpXG4gIH1cbn07XG5mdW5jdGlvbiBwYXJzZU9rbGFiKGNvbG9yLCBwYXJzZWQpIHtcbiAgaWYgKCFwYXJzZWQgfHwgcGFyc2VkWzBdICE9PSBcIm9rbGFiXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHJlcyA9IHsgbW9kZTogXCJva2xhYlwiIH07XG4gIGNvbnN0IFssIGwsIGEsIGIsIGFscGhhXSA9IHBhcnNlZDtcbiAgaWYgKGwudHlwZSA9PT0gVG9rLkh1ZSB8fCBhLnR5cGUgPT09IFRvay5IdWUgfHwgYi50eXBlID09PSBUb2suSHVlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAobC50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIHJlcy5sID0gTWF0aC5taW4oXG4gICAgICBNYXRoLm1heCgwLCBsLnR5cGUgPT09IFRvay5OdW1iZXIgPyBsLnZhbHVlIDogbC52YWx1ZSAvIDEwMCksXG4gICAgICAxXG4gICAgKTtcbiAgfVxuICBpZiAoYS50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIHJlcy5hID0gYS50eXBlID09PSBUb2suTnVtYmVyID8gYS52YWx1ZSA6IGEudmFsdWUgKiAwLjQgLyAxMDA7XG4gIH1cbiAgaWYgKGIudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICByZXMuYiA9IGIudHlwZSA9PT0gVG9rLk51bWJlciA/IGIudmFsdWUgOiBiLnZhbHVlICogMC40IC8gMTAwO1xuICB9XG4gIGlmIChhbHBoYS50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIHJlcy5hbHBoYSA9IE1hdGgubWluKFxuICAgICAgMSxcbiAgICAgIE1hdGgubWF4KFxuICAgICAgICAwLFxuICAgICAgICBhbHBoYS50eXBlID09PSBUb2suTnVtYmVyID8gYWxwaGEudmFsdWUgOiBhbHBoYS52YWx1ZSAvIDEwMFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmNvbnN0IGRlZmluaXRpb24kOCA9IHtcbiAgLi4uZGVmaW5pdGlvbiRmLFxuICBtb2RlOiBcIm9rbGFiXCIsXG4gIHRvTW9kZToge1xuICAgIGxyZ2I6IGNvbnZlcnRPa2xhYlRvTHJnYixcbiAgICByZ2I6IGNvbnZlcnRPa2xhYlRvUmdiXG4gIH0sXG4gIGZyb21Nb2RlOiB7XG4gICAgbHJnYjogY29udmVydExyZ2JUb09rbGFiLFxuICAgIHJnYjogY29udmVydFJnYlRvT2tsYWJcbiAgfSxcbiAgcmFuZ2VzOiB7XG4gICAgbDogWzAsIDFdLFxuICAgIGE6IFstMC40LCAwLjRdLFxuICAgIGI6IFstMC40LCAwLjRdXG4gIH0sXG4gIHBhcnNlOiBbcGFyc2VPa2xhYl0sXG4gIHNlcmlhbGl6ZTogKGMyKSA9PiBgb2tsYWIoJHtjMi5sICE9PSB2b2lkIDAgPyBjMi5sIDogXCJub25lXCJ9ICR7YzIuYSAhPT0gdm9pZCAwID8gYzIuYSA6IFwibm9uZVwifSAke2MyLmIgIT09IHZvaWQgMCA/IGMyLmIgOiBcIm5vbmVcIn0ke2MyLmFscGhhIDwgMSA/IGAgLyAke2MyLmFscGhhfWAgOiBcIlwifSlgXG59O1xuZnVuY3Rpb24gcGFyc2VPa2xjaChjb2xvciwgcGFyc2VkKSB7XG4gIGlmICghcGFyc2VkIHx8IHBhcnNlZFswXSAhPT0gXCJva2xjaFwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCByZXMgPSB7IG1vZGU6IFwib2tsY2hcIiB9O1xuICBjb25zdCBbLCBsLCBjMiwgaCwgYWxwaGFdID0gcGFyc2VkO1xuICBpZiAobC50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIGlmIChsLnR5cGUgPT09IFRvay5IdWUpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJlcy5sID0gTWF0aC5taW4oXG4gICAgICBNYXRoLm1heCgwLCBsLnR5cGUgPT09IFRvay5OdW1iZXIgPyBsLnZhbHVlIDogbC52YWx1ZSAvIDEwMCksXG4gICAgICAxXG4gICAgKTtcbiAgfVxuICBpZiAoYzIudHlwZSAhPT0gVG9rLk5vbmUpIHtcbiAgICByZXMuYyA9IE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIGMyLnR5cGUgPT09IFRvay5OdW1iZXIgPyBjMi52YWx1ZSA6IGMyLnZhbHVlICogMC40IC8gMTAwXG4gICAgKTtcbiAgfVxuICBpZiAoaC50eXBlICE9PSBUb2suTm9uZSkge1xuICAgIGlmIChoLnR5cGUgPT09IFRvay5QZXJjZW50YWdlKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXMuaCA9IGgudmFsdWU7XG4gIH1cbiAgaWYgKGFscGhhLnR5cGUgIT09IFRvay5Ob25lKSB7XG4gICAgcmVzLmFscGhhID0gTWF0aC5taW4oXG4gICAgICAxLFxuICAgICAgTWF0aC5tYXgoXG4gICAgICAgIDAsXG4gICAgICAgIGFscGhhLnR5cGUgPT09IFRvay5OdW1iZXIgPyBhbHBoYS52YWx1ZSA6IGFscGhhLnZhbHVlIC8gMTAwXG4gICAgICApXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuY29uc3QgZGVmaW5pdGlvbiQ3ID0ge1xuICAuLi5kZWZpbml0aW9uJGQsXG4gIG1vZGU6IFwib2tsY2hcIixcbiAgdG9Nb2RlOiB7XG4gICAgb2tsYWI6IChjMikgPT4gY29udmVydExjaFRvTGFiKGMyLCBcIm9rbGFiXCIpLFxuICAgIHJnYjogKGMyKSA9PiBjb252ZXJ0T2tsYWJUb1JnYihjb252ZXJ0TGNoVG9MYWIoYzIsIFwib2tsYWJcIikpXG4gIH0sXG4gIGZyb21Nb2RlOiB7XG4gICAgcmdiOiAoYzIpID0+IGNvbnZlcnRMYWJUb0xjaChjb252ZXJ0UmdiVG9Pa2xhYihjMiksIFwib2tsY2hcIiksXG4gICAgb2tsYWI6IChjMikgPT4gY29udmVydExhYlRvTGNoKGMyLCBcIm9rbGNoXCIpXG4gIH0sXG4gIHBhcnNlOiBbcGFyc2VPa2xjaF0sXG4gIHNlcmlhbGl6ZTogKGMyKSA9PiBgb2tsY2goJHtjMi5sICE9PSB2b2lkIDAgPyBjMi5sIDogXCJub25lXCJ9ICR7YzIuYyAhPT0gdm9pZCAwID8gYzIuYyA6IFwibm9uZVwifSAke2MyLmggIT09IHZvaWQgMCA/IGMyLmggOiBcIm5vbmVcIn0ke2MyLmFscGhhIDwgMSA/IGAgLyAke2MyLmFscGhhfWAgOiBcIlwifSlgLFxuICByYW5nZXM6IHtcbiAgICBsOiBbMCwgMV0sXG4gICAgYzogWzAsIDAuNF0sXG4gICAgaDogWzAsIDM2MF1cbiAgfVxufTtcbmNvbnN0IGNvbnZlcnRQM1RvWHl6NjUgPSAocmdiKSA9PiB7XG4gIGxldCB7IHIsIGcsIGIsIGFscGhhIH0gPSBjb252ZXJ0UmdiVG9McmdiKHJnYik7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJ4eXo2NVwiLFxuICAgIHg6IDAuNDg2NTcwOTQ4NjQ4MjE2ICogciArIDAuMjY1NjY3NjkzMTY5MDkzICogZyArIDAuMTk4MjE3Mjg1MjM0MzYyNSAqIGIsXG4gICAgeTogMC4yMjg5NzQ1NjQwNjk3NDg3ICogciArIDAuNjkxNzM4NTIxODM2NTA2MiAqIGcgKyAwLjA3OTI4NjkxNDA5Mzc0NSAqIGIsXG4gICAgejogMCAqIHIgKyAwLjA0NTExMzM4MTg1ODkwMjYgKiBnICsgMS4wNDM5NDQzNjg5MDA5NzYgKiBiXG4gIH07XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBjb252ZXJ0WHl6NjVUb1AzID0gKHsgeCwgeSwgeiwgYWxwaGEgfSkgPT4ge1xuICBpZiAoeCA9PT0gdm9pZCAwKSB4ID0gMDtcbiAgaWYgKHkgPT09IHZvaWQgMCkgeSA9IDA7XG4gIGlmICh6ID09PSB2b2lkIDApIHogPSAwO1xuICBsZXQgcmVzID0gY29udmVydExyZ2JUb1JnYihcbiAgICB7XG4gICAgICByOiB4ICogMi40OTM0OTY5MTE5NDE0MjYzIC0geSAqIDAuOTMxMzgzNjE3OTE5MTI0MiAtIDAuNDAyNzEwNzg0NDUwNzE3ICogeixcbiAgICAgIGc6IHggKiAtMC44Mjk0ODg5Njk1NjE1NzQ5ICsgeSAqIDEuNzYyNjY0MDYwMzE4MzQ2NSArIDAuMDIzNjI0Njg1ODQxOTQzNiAqIHosXG4gICAgICBiOiB4ICogMC4wMzU4NDU4MzAyNDM3ODQ1IC0geSAqIDAuMDc2MTcyMzg5MjY4MDQxOCArIDAuOTU2ODg0NTI0MDA3Njg3MSAqIHpcbiAgICB9LFxuICAgIFwicDNcIlxuICApO1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZGVmaW5pdGlvbiQ2ID0ge1xuICAuLi5kZWZpbml0aW9uJHIsXG4gIG1vZGU6IFwicDNcIixcbiAgcGFyc2U6IFtcImRpc3BsYXktcDNcIl0sXG4gIHNlcmlhbGl6ZTogXCJkaXNwbGF5LXAzXCIsXG4gIGZyb21Nb2RlOiB7XG4gICAgcmdiOiAoY29sb3IpID0+IGNvbnZlcnRYeXo2NVRvUDMoY29udmVydFJnYlRvWHl6NjUoY29sb3IpKSxcbiAgICB4eXo2NTogY29udmVydFh5ejY1VG9QM1xuICB9LFxuICB0b01vZGU6IHtcbiAgICByZ2I6IChjb2xvcikgPT4gY29udmVydFh5ejY1VG9SZ2IoY29udmVydFAzVG9YeXo2NShjb2xvcikpLFxuICAgIHh5ejY1OiBjb252ZXJ0UDNUb1h5ejY1XG4gIH1cbn07XG5jb25zdCBnYW1tYSQxID0gKHYpID0+IHtcbiAgbGV0IGFiczIgPSBNYXRoLmFicyh2KTtcbiAgaWYgKGFiczIgPj0gMSAvIDUxMikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLnBvdyhhYnMyLCAxIC8gMS44KTtcbiAgfVxuICByZXR1cm4gMTYgKiB2O1xufTtcbmNvbnN0IGNvbnZlcnRYeXo1MFRvUHJvcGhvdG8gPSAoeyB4LCB5LCB6LCBhbHBoYSB9KSA9PiB7XG4gIGlmICh4ID09PSB2b2lkIDApIHggPSAwO1xuICBpZiAoeSA9PT0gdm9pZCAwKSB5ID0gMDtcbiAgaWYgKHogPT09IHZvaWQgMCkgeiA9IDA7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJwcm9waG90b1wiLFxuICAgIHI6IGdhbW1hJDEoXG4gICAgICB4ICogMS4zNDU3ODY4ODE2NDcxNTg1IC0geSAqIDAuMjU1NTcyMDg3Mzc5Nzk0NiAtIDAuMDUxMTAxODY0OTc1NTQ1MyAqIHpcbiAgICApLFxuICAgIGc6IGdhbW1hJDEoXG4gICAgICB4ICogLTAuNTQ0NjMwNzA1MTI0OTAxOSArIHkgKiAxLjUwODI0Nzc0Mjg0NTE0NjYgKyAwLjAyMDUyNzQ0NzQzNjQyMTQgKiB6XG4gICAgKSxcbiAgICBiOiBnYW1tYSQxKHggKiAwICsgeSAqIDAgKyAxLjIxMTk2NzU0NTYzODk0NTIgKiB6KVxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgbGluZWFyaXplJDEgPSAodiA9IDApID0+IHtcbiAgbGV0IGFiczIgPSBNYXRoLmFicyh2KTtcbiAgaWYgKGFiczIgPj0gMTYgLyA1MTIpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5wb3coYWJzMiwgMS44KTtcbiAgfVxuICByZXR1cm4gdiAvIDE2O1xufTtcbmNvbnN0IGNvbnZlcnRQcm9waG90b1RvWHl6NTAgPSAocHJvcGhvdG8pID0+IHtcbiAgbGV0IHIgPSBsaW5lYXJpemUkMShwcm9waG90by5yKTtcbiAgbGV0IGcgPSBsaW5lYXJpemUkMShwcm9waG90by5nKTtcbiAgbGV0IGIgPSBsaW5lYXJpemUkMShwcm9waG90by5iKTtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcInh5ejUwXCIsXG4gICAgeDogMC43OTc3NjY2NDQ5MDA2NDIzICogciArIDAuMTM1MTgxMjk3NDAwNTMzMSAqIGcgKyAwLjAzMTM0NzczNDEyODM5MjIgKiBiLFxuICAgIHk6IDAuMjg4MDc0ODI4ODE5NDAxMyAqIHIgKyAwLjcxMTgzNTIzNDI0MTg3MzEgKiBnICsgODk5MzY5Mzg3MjU2ZS0xNiAqIGIsXG4gICAgejogMCAqIHIgKyAwICogZyArIDAuODI1MTA0NjAyNTEwNDYwMiAqIGJcbiAgfTtcbiAgaWYgKHByb3Bob3RvLmFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBwcm9waG90by5hbHBoYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGRlZmluaXRpb24kNSA9IHtcbiAgLi4uZGVmaW5pdGlvbiRyLFxuICBtb2RlOiBcInByb3Bob3RvXCIsXG4gIHBhcnNlOiBbXCJwcm9waG90by1yZ2JcIl0sXG4gIHNlcmlhbGl6ZTogXCJwcm9waG90by1yZ2JcIixcbiAgZnJvbU1vZGU6IHtcbiAgICB4eXo1MDogY29udmVydFh5ejUwVG9Qcm9waG90byxcbiAgICByZ2I6IChjb2xvcikgPT4gY29udmVydFh5ejUwVG9Qcm9waG90byhjb252ZXJ0UmdiVG9YeXo1MChjb2xvcikpXG4gIH0sXG4gIHRvTW9kZToge1xuICAgIHh5ejUwOiBjb252ZXJ0UHJvcGhvdG9Ub1h5ejUwLFxuICAgIHJnYjogKGNvbG9yKSA9PiBjb252ZXJ0WHl6NTBUb1JnYihjb252ZXJ0UHJvcGhvdG9Ub1h5ejUwKGNvbG9yKSlcbiAgfVxufTtcbmNvbnN0IM6xJDEgPSAxLjA5OTI5NjgyNjgwOTQ0O1xuY29uc3QgzrIkMSA9IDAuMDE4MDUzOTY4NTEwODA3O1xuY29uc3QgZ2FtbWEgPSAodikgPT4ge1xuICBjb25zdCBhYnMyID0gTWF0aC5hYnModik7XG4gIGlmIChhYnMyID4gzrIkMSkge1xuICAgIHJldHVybiAoTWF0aC5zaWduKHYpIHx8IDEpICogKM6xJDEgKiBNYXRoLnBvdyhhYnMyLCAwLjQ1KSAtICjOsSQxIC0gMSkpO1xuICB9XG4gIHJldHVybiA0LjUgKiB2O1xufTtcbmNvbnN0IGNvbnZlcnRYeXo2NVRvUmVjMjAyMCA9ICh7IHgsIHksIHosIGFscGhhIH0pID0+IHtcbiAgaWYgKHggPT09IHZvaWQgMCkgeCA9IDA7XG4gIGlmICh5ID09PSB2b2lkIDApIHkgPSAwO1xuICBpZiAoeiA9PT0gdm9pZCAwKSB6ID0gMDtcbiAgbGV0IHJlcyA9IHtcbiAgICBtb2RlOiBcInJlYzIwMjBcIixcbiAgICByOiBnYW1tYShcbiAgICAgIHggKiAxLjcxNjY1MTE4Nzk3MTI2ODMgLSB5ICogMC4zNTU2NzA3ODM3NzYzOTI1IC0gMC4yNTMzNjYyODEzNzM2NTk5ICogelxuICAgICksXG4gICAgZzogZ2FtbWEoXG4gICAgICB4ICogLTAuNjY2Njg0MzUxODMyNDg5MyArIHkgKiAxLjYxNjQ4MTIzNjYzNDkzOTUgKyAwLjAxNTc2ODU0NTgxMzkxMTEgKiB6XG4gICAgKSxcbiAgICBiOiBnYW1tYShcbiAgICAgIHggKiAwLjAxNzYzOTg1NzQ0NTMxMDggLSB5ICogMC4wNDI3NzA2MTMyNTc4MDg1ICsgMC45NDIxMDMxMjEyMzU0NzM5ICogelxuICAgIClcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSBhbHBoYTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IM6xID0gMS4wOTkyOTY4MjY4MDk0NDtcbmNvbnN0IM6yID0gMC4wMTgwNTM5Njg1MTA4MDc7XG5jb25zdCBsaW5lYXJpemUgPSAodiA9IDApID0+IHtcbiAgbGV0IGFiczIgPSBNYXRoLmFicyh2KTtcbiAgaWYgKGFiczIgPCDOsiAqIDQuNSkge1xuICAgIHJldHVybiB2IC8gNC41O1xuICB9XG4gIHJldHVybiAoTWF0aC5zaWduKHYpIHx8IDEpICogTWF0aC5wb3coKGFiczIgKyDOsSAtIDEpIC8gzrEsIDEgLyAwLjQ1KTtcbn07XG5jb25zdCBjb252ZXJ0UmVjMjAyMFRvWHl6NjUgPSAocmVjMjAyMCkgPT4ge1xuICBsZXQgciA9IGxpbmVhcml6ZShyZWMyMDIwLnIpO1xuICBsZXQgZyA9IGxpbmVhcml6ZShyZWMyMDIwLmcpO1xuICBsZXQgYiA9IGxpbmVhcml6ZShyZWMyMDIwLmIpO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwieHl6NjVcIixcbiAgICB4OiAwLjYzNjk1ODA0ODMwMTI5MTEgKiByICsgMC4xNDQ2MTY5MDM1ODYyMDgzICogZyArIDAuMTY4ODgwOTc1MTY0MTcyMSAqIGIsXG4gICAgeTogMC4yNjI3MDAyMTIwMTEyNjcgKiByICsgMC42Nzc5OTgwNzE1MTg4NzA4ICogZyArIDAuMDU5MzAxNzE2NDY5ODYyICogYixcbiAgICB6OiAwICogciArIDAuMDI4MDcyNjkzMDQ5MDg3NCAqIGcgKyAxLjA2MDk4NTA1NzcxMDc5MDkgKiBiXG4gIH07XG4gIGlmIChyZWMyMDIwLmFscGhhICE9PSB2b2lkIDApIHtcbiAgICByZXMuYWxwaGEgPSByZWMyMDIwLmFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZGVmaW5pdGlvbiQ0ID0ge1xuICAuLi5kZWZpbml0aW9uJHIsXG4gIG1vZGU6IFwicmVjMjAyMFwiLFxuICBmcm9tTW9kZToge1xuICAgIHh5ejY1OiBjb252ZXJ0WHl6NjVUb1JlYzIwMjAsXG4gICAgcmdiOiAoY29sb3IpID0+IGNvbnZlcnRYeXo2NVRvUmVjMjAyMChjb252ZXJ0UmdiVG9YeXo2NShjb2xvcikpXG4gIH0sXG4gIHRvTW9kZToge1xuICAgIHh5ejY1OiBjb252ZXJ0UmVjMjAyMFRvWHl6NjUsXG4gICAgcmdiOiAoY29sb3IpID0+IGNvbnZlcnRYeXo2NVRvUmdiKGNvbnZlcnRSZWMyMDIwVG9YeXo2NShjb2xvcikpXG4gIH0sXG4gIHBhcnNlOiBbXCJyZWMyMDIwXCJdLFxuICBzZXJpYWxpemU6IFwicmVjMjAyMFwiXG59O1xuY29uc3QgYmlhcyA9IDAuMDAzNzkzMDczMjU1Mjc1NDQ5MztcbmNvbnN0IGJpYXNfY2JydCA9IE1hdGguY2JydChiaWFzKTtcbmNvbnN0IHRyYW5zZmVyJDEgPSAodikgPT4gTWF0aC5jYnJ0KHYpIC0gYmlhc19jYnJ0O1xuY29uc3QgY29udmVydFJnYlRvWHliID0gKGNvbG9yKSA9PiB7XG4gIGNvbnN0IHsgciwgZywgYiwgYWxwaGEgfSA9IGNvbnZlcnRSZ2JUb0xyZ2IoY29sb3IpO1xuICBjb25zdCBsID0gdHJhbnNmZXIkMSgwLjMgKiByICsgMC42MjIgKiBnICsgMC4wNzggKiBiICsgYmlhcyk7XG4gIGNvbnN0IG0gPSB0cmFuc2ZlciQxKDAuMjMgKiByICsgMC42OTIgKiBnICsgMC4wNzggKiBiICsgYmlhcyk7XG4gIGNvbnN0IHMgPSB0cmFuc2ZlciQxKFxuICAgIDAuMjQzNDIyNjg5MjQ1NDc4MiAqIHIgKyAwLjIwNDc2NzQ0NDI0NDk2ODIgKiBnICsgMC41NTE4MDk4NjY1MDk1NTM1ICogYiArIGJpYXNcbiAgKTtcbiAgY29uc3QgcmVzID0ge1xuICAgIG1vZGU6IFwieHliXCIsXG4gICAgeDogKGwgLSBtKSAvIDIsXG4gICAgeTogKGwgKyBtKSAvIDIsXG4gICAgLyogQXBwbHkgZGVmYXVsdCBjaHJvbWEgZnJvbSBsdW1hIChzdWJ0cmFjdCBZIGZyb20gQikgKi9cbiAgICBiOiBzIC0gKGwgKyBtKSAvIDJcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHJlcy5hbHBoYSA9IGFscGhhO1xuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IHRyYW5zZmVyID0gKHYpID0+IE1hdGgucG93KHYgKyBiaWFzX2NicnQsIDMpO1xuY29uc3QgY29udmVydFh5YlRvUmdiID0gKHsgeCwgeSwgYiwgYWxwaGEgfSkgPT4ge1xuICBpZiAoeCA9PT0gdm9pZCAwKSB4ID0gMDtcbiAgaWYgKHkgPT09IHZvaWQgMCkgeSA9IDA7XG4gIGlmIChiID09PSB2b2lkIDApIGIgPSAwO1xuICBjb25zdCBsID0gdHJhbnNmZXIoeCArIHkpIC0gYmlhcztcbiAgY29uc3QgbSA9IHRyYW5zZmVyKHkgLSB4KSAtIGJpYXM7XG4gIGNvbnN0IHMgPSB0cmFuc2ZlcihiICsgeSkgLSBiaWFzO1xuICBjb25zdCByZXMgPSBjb252ZXJ0THJnYlRvUmdiKHtcbiAgICByOiAxMS4wMzE1NjY5MDQ2Mzk4NjEgKiBsIC0gOS44NjY5NDM5MDgxMzE1NjIgKiBtIC0gMC4xNjQ2MjI5OTY1MDgyOTkzNCAqIHMsXG4gICAgZzogLTMuMjU0MTQ3MzgxMDc0NDIzNyAqIGwgKyA0LjQxODc3MDM3NzU4MjcyMyAqIG0gLSAwLjE2NDYyMjk5NjUwODI5OTM0ICogcyxcbiAgICBiOiAtMy42NTg4NTEyODY3MTM2ODE1ICogbCArIDIuNzEyOTIzMDQ1OTM2MDkyMiAqIG0gKyAxLjk0NTkyODI0MDc3NzU4OTUgKiBzXG4gIH0pO1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgZGVmaW5pdGlvbiQzID0ge1xuICBtb2RlOiBcInh5YlwiLFxuICBjaGFubmVsczogW1wieFwiLCBcInlcIiwgXCJiXCIsIFwiYWxwaGFcIl0sXG4gIHBhcnNlOiBbXCItLXh5YlwiXSxcbiAgc2VyaWFsaXplOiBcIi0teHliXCIsXG4gIHRvTW9kZToge1xuICAgIHJnYjogY29udmVydFh5YlRvUmdiXG4gIH0sXG4gIGZyb21Nb2RlOiB7XG4gICAgcmdiOiBjb252ZXJ0UmdiVG9YeWJcbiAgfSxcbiAgcmFuZ2VzOiB7XG4gICAgeDogWy0wLjAxNTQsIDAuMDI4MV0sXG4gICAgeTogWzAsIDAuODQ1M10sXG4gICAgYjogWy0wLjI3NzgsIDAuMzg4XVxuICB9LFxuICBpbnRlcnBvbGF0ZToge1xuICAgIHg6IGludGVycG9sYXRvckxpbmVhcixcbiAgICB5OiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYjogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGFscGhhOiB7IHVzZTogaW50ZXJwb2xhdG9yTGluZWFyLCBmaXh1cDogZml4dXBBbHBoYSB9XG4gIH1cbn07XG5jb25zdCBkZWZpbml0aW9uJDIgPSB7XG4gIG1vZGU6IFwieHl6NTBcIixcbiAgcGFyc2U6IFtcInh5ei1kNTBcIl0sXG4gIHNlcmlhbGl6ZTogXCJ4eXotZDUwXCIsXG4gIHRvTW9kZToge1xuICAgIHJnYjogY29udmVydFh5ejUwVG9SZ2IsXG4gICAgbGFiOiBjb252ZXJ0WHl6NTBUb0xhYlxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHJnYjogY29udmVydFJnYlRvWHl6NTAsXG4gICAgbGFiOiBjb252ZXJ0TGFiVG9YeXo1MFxuICB9LFxuICBjaGFubmVsczogW1wieFwiLCBcInlcIiwgXCJ6XCIsIFwiYWxwaGFcIl0sXG4gIHJhbmdlczoge1xuICAgIHg6IFswLCAwLjk2NF0sXG4gICAgeTogWzAsIDAuOTk5XSxcbiAgICB6OiBbMCwgMC44MjVdXG4gIH0sXG4gIGludGVycG9sYXRlOiB7XG4gICAgeDogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIHk6IGludGVycG9sYXRvckxpbmVhcixcbiAgICB6OiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYWxwaGE6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEFscGhhIH1cbiAgfVxufTtcbmNvbnN0IGNvbnZlcnRYeXo2NVRvWHl6NTAgPSAoeHl6NjUpID0+IHtcbiAgbGV0IHsgeCwgeSwgeiwgYWxwaGEgfSA9IHh5ejY1O1xuICBpZiAoeCA9PT0gdm9pZCAwKSB4ID0gMDtcbiAgaWYgKHkgPT09IHZvaWQgMCkgeSA9IDA7XG4gIGlmICh6ID09PSB2b2lkIDApIHogPSAwO1xuICBsZXQgcmVzID0ge1xuICAgIG1vZGU6IFwieHl6NTBcIixcbiAgICB4OiAxLjA0NzkyOTgyMDg0MDU0ODggKiB4ICsgMC4wMjI5NDY3OTMzNDEwMTkxICogeSAtIDAuMDUwMTkyMjI5NTQzMTM1NiAqIHosXG4gICAgeTogMC4wMjk2Mjc4MTU2ODgxNTkzICogeCArIDAuOTkwNDM0NDg0NTczMjQ5ICogeSAtIDAuMDE3MDczODI1MDI5Mzg1MSAqIHosXG4gICAgejogLTAuMDA5MjQzMDU4MTUyNTkxMiAqIHggKyAwLjAxNTA1NTE0NDg5NjU3NzkgKiB5ICsgMC43NTE4NzQyODk5NTgwMDA4ICogelxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkge1xuICAgIHJlcy5hbHBoYSA9IGFscGhhO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydFh5ejUwVG9YeXo2NSA9ICh4eXo1MCkgPT4ge1xuICBsZXQgeyB4LCB5LCB6LCBhbHBoYSB9ID0geHl6NTA7XG4gIGlmICh4ID09PSB2b2lkIDApIHggPSAwO1xuICBpZiAoeSA9PT0gdm9pZCAwKSB5ID0gMDtcbiAgaWYgKHogPT09IHZvaWQgMCkgeiA9IDA7XG4gIGxldCByZXMgPSB7XG4gICAgbW9kZTogXCJ4eXo2NVwiLFxuICAgIHg6IDAuOTU1NDczNDUyNzA0MjE4MiAqIHggLSAwLjAyMzA5ODUzNjg3NDI2MTQgKiB5ICsgMC4wNjMyNTkzMDg2NjEwMjE3ICogeixcbiAgICB5OiAtMC4wMjgzNjk3MDY5NjMyMDgxICogeCArIDEuMDA5OTk1NDU4MDA1ODIyNiAqIHkgKyAwLjAyMTA0MTM5ODk2Njk0MyAqIHosXG4gICAgejogMC4wMTIzMTQwMDE2ODgzMTk5ICogeCAtIDAuMDIwNTA3Njk2NDMzNDc3OSAqIHkgKyAxLjMzMDM2NTkzNjYwODA3NTMgKiB6XG4gIH07XG4gIGlmIChhbHBoYSAhPT0gdm9pZCAwKSB7XG4gICAgcmVzLmFscGhhID0gYWxwaGE7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBkZWZpbml0aW9uJDEgPSB7XG4gIG1vZGU6IFwieHl6NjVcIixcbiAgdG9Nb2RlOiB7XG4gICAgcmdiOiBjb252ZXJ0WHl6NjVUb1JnYixcbiAgICB4eXo1MDogY29udmVydFh5ejY1VG9YeXo1MFxuICB9LFxuICBmcm9tTW9kZToge1xuICAgIHJnYjogY29udmVydFJnYlRvWHl6NjUsXG4gICAgeHl6NTA6IGNvbnZlcnRYeXo1MFRvWHl6NjVcbiAgfSxcbiAgcmFuZ2VzOiB7XG4gICAgeDogWzAsIDAuOTVdLFxuICAgIHk6IFswLCAxXSxcbiAgICB6OiBbMCwgMS4wODhdXG4gIH0sXG4gIGNoYW5uZWxzOiBbXCJ4XCIsIFwieVwiLCBcInpcIiwgXCJhbHBoYVwiXSxcbiAgcGFyc2U6IFtcInh5elwiLCBcInh5ei1kNjVcIl0sXG4gIHNlcmlhbGl6ZTogXCJ4eXotZDY1XCIsXG4gIGludGVycG9sYXRlOiB7XG4gICAgeDogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIHk6IGludGVycG9sYXRvckxpbmVhcixcbiAgICB6OiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYWxwaGE6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEFscGhhIH1cbiAgfVxufTtcbmNvbnN0IGNvbnZlcnRSZ2JUb1lpcSA9ICh7IHIsIGcsIGIsIGFscGhhIH0pID0+IHtcbiAgaWYgKHIgPT09IHZvaWQgMCkgciA9IDA7XG4gIGlmIChnID09PSB2b2lkIDApIGcgPSAwO1xuICBpZiAoYiA9PT0gdm9pZCAwKSBiID0gMDtcbiAgY29uc3QgcmVzID0ge1xuICAgIG1vZGU6IFwieWlxXCIsXG4gICAgeTogMC4yOTg4OTUzMSAqIHIgKyAwLjU4NjYyMjQ3ICogZyArIDAuMTE0NDgyMjMgKiBiLFxuICAgIGk6IDAuNTk1OTc3OTkgKiByIC0gMC4yNzQxNzYxICogZyAtIDAuMzIxODAxODkgKiBiLFxuICAgIHE6IDAuMjExNDcwMTcgKiByIC0gMC41MjI2MTcxMSAqIGcgKyAwLjMxMTE0Njk0ICogYlxuICB9O1xuICBpZiAoYWxwaGEgIT09IHZvaWQgMCkgcmVzLmFscGhhID0gYWxwaGE7XG4gIHJldHVybiByZXM7XG59O1xuY29uc3QgY29udmVydFlpcVRvUmdiID0gKHsgeSwgaSwgcSwgYWxwaGEgfSkgPT4ge1xuICBpZiAoeSA9PT0gdm9pZCAwKSB5ID0gMDtcbiAgaWYgKGkgPT09IHZvaWQgMCkgaSA9IDA7XG4gIGlmIChxID09PSB2b2lkIDApIHEgPSAwO1xuICBjb25zdCByZXMgPSB7XG4gICAgbW9kZTogXCJyZ2JcIixcbiAgICByOiB5ICsgMC45NTYwODQ0NSAqIGkgKyAwLjYyMDg4ODUgKiBxLFxuICAgIGc6IHkgLSAwLjI3MTM3NjY0ICogaSAtIDAuNjQ4NjA1OSAqIHEsXG4gICAgYjogeSAtIDEuMTA1NjE3MjQgKiBpICsgMS43MDI1MDEyNiAqIHFcbiAgfTtcbiAgaWYgKGFscGhhICE9PSB2b2lkIDApIHJlcy5hbHBoYSA9IGFscGhhO1xuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGRlZmluaXRpb24gPSB7XG4gIG1vZGU6IFwieWlxXCIsXG4gIHRvTW9kZToge1xuICAgIHJnYjogY29udmVydFlpcVRvUmdiXG4gIH0sXG4gIGZyb21Nb2RlOiB7XG4gICAgcmdiOiBjb252ZXJ0UmdiVG9ZaXFcbiAgfSxcbiAgY2hhbm5lbHM6IFtcInlcIiwgXCJpXCIsIFwicVwiLCBcImFscGhhXCJdLFxuICBwYXJzZTogW1wiLS15aXFcIl0sXG4gIHNlcmlhbGl6ZTogXCItLXlpcVwiLFxuICByYW5nZXM6IHtcbiAgICBpOiBbLTAuNTk1LCAwLjU5NV0sXG4gICAgcTogWy0wLjUyMiwgMC41MjJdXG4gIH0sXG4gIGludGVycG9sYXRlOiB7XG4gICAgeTogaW50ZXJwb2xhdG9yTGluZWFyLFxuICAgIGk6IGludGVycG9sYXRvckxpbmVhcixcbiAgICBxOiBpbnRlcnBvbGF0b3JMaW5lYXIsXG4gICAgYWxwaGE6IHsgdXNlOiBpbnRlcnBvbGF0b3JMaW5lYXIsIGZpeHVwOiBmaXh1cEFscGhhIH1cbiAgfVxufTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRxKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRwKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRvKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRuKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRtKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRsKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRrKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRqKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRpKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRoKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRnKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRmKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRlKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRkKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRjKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRiKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRhKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQ5KTtcbnVzZU1vZGUobW9kZU9raHNsKTtcbnVzZU1vZGUobW9kZU9raHN2KTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQ4KTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQ3KTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQ2KTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQ1KTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQ0KTtcbnVzZU1vZGUoZGVmaW5pdGlvbiRyKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQzKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQyKTtcbnVzZU1vZGUoZGVmaW5pdGlvbiQxKTtcbnVzZU1vZGUoZGVmaW5pdGlvbik7XG52YXIgRXZlbnREaXNwYXRjaGVyQmFzZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpYmFibGUgPSBuZXcgU3Vic2NyaWJhYmxlKHRoaXMpO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIC8qKlxuICAgKiB7QGluaGVyaXREb2MgU3Vic2NyaWJhYmxlLnN1YnNjcmliZX1cbiAgICovXG4gIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5hZGQoaGFuZGxlcik7XG4gICAgcmV0dXJuICgpID0+IHRoaXMudW5zdWJzY3JpYmUoaGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIHtAaW5oZXJpdERvYyBTdWJzY3JpYmFibGUudW5zdWJzY3JpYmV9XG4gICAqL1xuICB1bnN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoaGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGFsbCBzdWJzY3JpYmVycyBmcm9tIHRoZSBldmVudC5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgfVxuICBub3RpZnlTdWJzY3JpYmVycyh2YWx1ZSkge1xuICAgIHJldHVybiBbLi4udGhpcy5zdWJzY3JpYmVyc10ubWFwKChoYW5kbGVyKSA9PiBoYW5kbGVyKHZhbHVlKSk7XG4gIH1cbn07XG52YXIgU3Vic2NyaWJhYmxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihkaXNwYXRjaGVyKSB7XG4gICAgdGhpcy5kaXNwYXRjaGVyID0gZGlzcGF0Y2hlcjtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGhhbmRsZXIgLSBUaGUgaGFuZGxlciB0byBpbnZva2Ugd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgY2FuY2VscyB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaGVyLnN1YnNjcmliZShoYW5kbGVyKTtcbiAgfVxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIGhhbmRsZXIgdG8gdW5zdWJzY3JpYmUuXG4gICAqL1xuICB1bnN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgdGhpcy5kaXNwYXRjaGVyLnVuc3Vic2NyaWJlKGhhbmRsZXIpO1xuICB9XG59O1xudmFyIEFzeW5jRXZlbnREaXNwYXRjaGVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJCYXNlIHtcbiAgYXN5bmMgZGlzcGF0Y2godmFsdWUpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHZhbHVlKSk7XG4gIH1cbn07XG52YXIgRXZlbnREaXNwYXRjaGVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJCYXNlIHtcbiAgZGlzcGF0Y2godmFsdWUpIHtcbiAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHZhbHVlKTtcbiAgfVxufTtcbnZhciBGbGFnRGlzcGF0Y2hlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWx1ZSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBOb3RpZnkgYWxsIGN1cnJlbnQgYW5kIGZ1dHVyZSBzdWJzY3JpYmVycy5cbiAgICovXG4gIHJhaXNlKCkge1xuICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHRydWU7XG4gICAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdG9wIG5vdGlmeWluZyBmdXR1cmUgc3Vic2NyaWJlcnMuXG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnZhbHVlID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFyZSBzdWJzY3JpYmVycyBiZWluZyBub3RpZmllZD9cbiAgICovXG4gIGlzUmFpc2VkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG4gIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdXBlci5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgIGhhbmRsZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICB9XG59O1xudmFyIFZhbHVlRGlzcGF0Y2hlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5zdWJzY3JpYmFibGUgPSBuZXcgU3Vic2NyaWJhYmxlVmFsdWVFdmVudCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICoge0Bpbmhlcml0RG9jIFN1YnNjcmliYWJsZVZhbHVlRXZlbnQuY3VycmVudH1cbiAgICovXG4gIGdldCBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhpcyBkaXNwYXRjaGVyLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBTZXR0aW5nIHRoZSB2YWx1ZSB3aWxsIGltbWVkaWF0ZWx5IG5vdGlmeSBhbGwgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBuZXcgdmFsdWUuXG4gICAqL1xuICBzZXQgY3VycmVudCh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5vdGlmeVN1YnNjcmliZXJzKHZhbHVlKTtcbiAgfVxuICAvKipcbiAgICoge0Bpbmhlcml0RG9jIFN1YnNjcmliYWJsZVZhbHVlRXZlbnQuc3Vic2NyaWJlfVxuICAgKi9cbiAgc3Vic2NyaWJlKGhhbmRsZXIsIGRpc3BhdGNoSW1tZWRpYXRlbHkgPSB0cnVlKSB7XG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdXBlci5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgaWYgKGRpc3BhdGNoSW1tZWRpYXRlbHkpIHtcbiAgICAgIGhhbmRsZXIodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgfVxufTtcbnZhciBTdWJzY3JpYmFibGVWYWx1ZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBTdWJzY3JpYmFibGUge1xuICAvKipcbiAgICogR2V0IHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBvZiB0aGlzIGRpc3BhdGNoZXIuXG4gICAqL1xuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaGVyLmN1cnJlbnQ7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnQuXG4gICAqXG4gICAqIFN1YnNjcmliaW5nIHdpbGwgaW1tZWRpYXRlbHkgaW52b2tlIHRoZSBoYW5kbGVyIHdpdGggdGhlIG1vc3QgcmVjZW50IHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBoYW5kbGVyIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG4gICAqIEBwYXJhbSBkaXNwYXRjaEltbWVkaWF0ZWx5IC0gV2hldGhlciB0aGUgaGFuZGxlciBzaG91bGQgYmUgaW1tZWRpYXRlbHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZva2VkIHdpdGggdGhlIG1vc3QgcmVjZW50IHZhbHVlLlxuICAgKlxuICAgKiBAcmV0dXJucyBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGNhbmNlbHMgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIHN1YnNjcmliZShoYW5kbGVyLCBkaXNwYXRjaEltbWVkaWF0ZWx5ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoZXIuc3Vic2NyaWJlKFxuICAgICAgaGFuZGxlcixcbiAgICAgIGRpc3BhdGNoSW1tZWRpYXRlbHlcbiAgICApO1xuICB9XG59O1xubmV3IEV2ZW50RGlzcGF0Y2hlcigpO1xuZnVuY3Rpb24gbWFwKGZyb20sIHRvLCB2YWx1ZSkge1xuICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogdmFsdWU7XG59XG5mdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbn1cbnZhciBTY2VuZVN0YWNrID0gW107XG5mdW5jdGlvbiB1c2VMb2dnZXIoKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBTY2VuZVN0YWNrLmF0KC0xKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmxvZ2dlcikgPz8gY29uc29sZTtcbn1cbnZhciBEZXRhaWxlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzLCByZW1hcmtzKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgdGhpcy5yZW1hcmtzID0gcmVtYXJrcztcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIocHJvcHMubWVzc2FnZSk7XG4gICAgICB0aGlzLnJlbWFya3MgPSBwcm9wcy5yZW1hcmtzO1xuICAgICAgdGhpcy5vYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICB0aGlzLmR1cmF0aW9uTXMgPSBwcm9wcy5kdXJhdGlvbk1zO1xuICAgICAgdGhpcy5pbnNwZWN0ID0gcHJvcHMuaW5zcGVjdDtcbiAgICB9XG4gIH1cbn07XG52YXIgVGhyZWFkU3RhY2sgPSBbXTtcbmZ1bmN0aW9uIHVzZVRocmVhZCgpIHtcbiAgY29uc3QgdGhyZWFkID0gVGhyZWFkU3RhY2suYXQoLTEpO1xuICBpZiAoIXRocmVhZCkge1xuICAgIHRocm93IG5ldyBEZXRhaWxlZEVycm9yKFxuICAgICAgXCJUaGUgdGhyZWFkIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cIixcbiAgICAgIC8vIGxhbmd1YWdlPW1hcmtkb3duXG4gICAgICBgXFxgdXNlVGhyZWFkKClcXGAgY2FuIG9ubHkgYmUgY2FsbGVkIGZyb20gd2l0aGluIGdlbmVyYXRvciBmdW5jdGlvbnMuXG4gICAgICBJdCdzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHJlbmRlcmluZy5gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhyZWFkO1xufVxuZnVuY3Rpb24gc3RhcnRUaHJlYWQodGhyZWFkKSB7XG4gIFRocmVhZFN0YWNrLnB1c2godGhyZWFkKTtcbn1cbmZ1bmN0aW9uIGVuZFRocmVhZCh0aHJlYWQpIHtcbiAgaWYgKFRocmVhZFN0YWNrLnBvcCgpICE9PSB0aHJlYWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydFRocmVhZC9lbmRUaHJlYWQgd2FzIGNhbGxlZCBvdXQgb2Ygb3JkZXIuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvclRvTG9nKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICBzdGFjazogZXJyb3Iuc3RhY2ssXG4gICAgcmVtYXJrczogZXJyb3IucmVtYXJrc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dChvcHRpb25zLCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIG9wdGlvbnMpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgY3JlYXRlIGEgMkQgY29udGV4dC5cIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG52YXIgUkFEMkRFRyA9IDE4MCAvIE1hdGguUEk7XG52YXIgREVHMlJBRCA9IE1hdGguUEkgLyAxODA7XG52YXIgU2VtYXBob3JlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlc29sdmVDdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICB9XG4gIGFzeW5jIGFjcXVpcmUoKSB7XG4gICAgd2hpbGUgKHRoaXMuY3VycmVudCkge1xuICAgICAgYXdhaXQgdGhpcy5jdXJyZW50O1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlQ3VycmVudCA9IHJlc29sdmU7XG4gICAgfSk7XG4gIH1cbiAgcmVsZWFzZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAoX2EgPSB0aGlzLnJlc29sdmVDdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnJlc29sdmVDdXJyZW50ID0gbnVsbDtcbiAgfVxufTtcbnZhciBQbGF5YmFja1N0YWNrID0gW107XG5mdW5jdGlvbiB1c2VQbGF5YmFjaygpIHtcbiAgY29uc3QgcGxheWJhY2sgPSBQbGF5YmFja1N0YWNrLmF0KC0xKTtcbiAgaWYgKCFwbGF5YmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBwbGF5YmFjayBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXCIpO1xuICB9XG4gIHJldHVybiBwbGF5YmFjaztcbn1cbmZ1bmN0aW9uIHRleHRMZXJwKGZyb20sIHRvLCB2YWx1ZSkge1xuICBpZiAodG8ubGVuZ3RoID49IGZyb20ubGVuZ3RoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IE1hdGguZmxvb3IodG8ubGVuZ3RoICogdmFsdWUpO1xuICAgIGNvbnN0IGN1cnJlbnRMZW5ndGggPSBNYXRoLmZsb29yKG1hcChmcm9tLmxlbmd0aCAtIDEsIHRvLmxlbmd0aCwgdmFsdWUpKTtcbiAgICBsZXQgdGV4dCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0by5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPCBjdXJyZW50KSB7XG4gICAgICAgIHRleHQgKz0gdG9baV07XG4gICAgICB9IGVsc2UgaWYgKGZyb21baV0gfHwgaSA8PSBjdXJyZW50TGVuZ3RoKSB7XG4gICAgICAgIHRleHQgKz0gZnJvbVtpXSA/PyB0b1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3VycmVudCA9IE1hdGgucm91bmQoZnJvbS5sZW5ndGggKiAoMSAtIHZhbHVlKSk7XG4gICAgY29uc3QgY3VycmVudExlbmd0aCA9IE1hdGguZmxvb3IobWFwKGZyb20ubGVuZ3RoICsgMSwgdG8ubGVuZ3RoLCB2YWx1ZSkpO1xuICAgIGNvbnN0IHRleHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gZnJvbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGkgPCBjdXJyZW50KSB7XG4gICAgICAgIHRleHQudW5zaGlmdChmcm9tW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAodG9baV0gfHwgaSA8IGN1cnJlbnRMZW5ndGgpIHtcbiAgICAgICAgdGV4dC51bnNoaWZ0KHRvW2ldID8/IGZyb21baV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBkZWVwTGVycChmcm9tLCB0bywgdmFsdWUsIHN1cHByZXNzV2FybmluZ3MgPSBmYWxzZSkge1xuICBpZiAodmFsdWUgPT09IDApIHJldHVybiBmcm9tO1xuICBpZiAodmFsdWUgPT09IDEpIHJldHVybiB0bztcbiAgaWYgKGZyb20gPT0gbnVsbCB8fCB0byA9PSBudWxsKSB7XG4gICAgaWYgKCFzdXBwcmVzc1dhcm5pbmdzKSB7XG4gICAgICB1c2VMb2dnZXIoKS53YXJuKFxuICAgICAgICBgQXR0ZW1wdGluZyB0byBsZXJwICR7ZnJvbX0gLT4gJHt0b30gbWF5IHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcm9tID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBtYXAoZnJvbSwgdG8sIHZhbHVlKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyb20gPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHRleHRMZXJwKGZyb20sIHRvLCB2YWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmcm9tID09PSBcImJvb2xlYW5cIiAmJiB0eXBlb2YgdG8gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMC41ID8gZnJvbSA6IHRvO1xuICB9XG4gIGlmIChcImxlcnBcIiBpbiBmcm9tKSB7XG4gICAgcmV0dXJuIGZyb20ubGVycCh0bywgdmFsdWUpO1xuICB9XG4gIGlmIChmcm9tICYmIHRvICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB0byA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZyb20pICYmIEFycmF5LmlzQXJyYXkodG8pKSB7XG4gICAgICBpZiAoZnJvbS5sZW5ndGggPT09IHRvLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZnJvbS5tYXAoKGYyLCBpKSA9PiBkZWVwTGVycChmMiwgdG9baV0sIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0b09iamVjdCA9IGZhbHNlO1xuICAgICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIE1hcCkgJiYgISh0byBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgdG9PYmplY3QgPSB0cnVlO1xuICAgICAgICBmcm9tID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhmcm9tKSk7XG4gICAgICAgIHRvID0gbmV3IE1hcChPYmplY3QuZW50cmllcyh0bykpO1xuICAgICAgfVxuICAgICAgaWYgKGZyb20gaW5zdGFuY2VvZiBNYXAgJiYgdG8gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmZyb20ua2V5cygpLCAuLi50by5rZXlzKCldKSkge1xuICAgICAgICAgIGNvbnN0IGludGVyID0gZGVlcExlcnAoZnJvbS5nZXQoa2V5KSwgdG8uZ2V0KGtleSksIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICBpZiAoaW50ZXIgIT09IHZvaWQgMCkgcmVzdWx0LnNldChrZXksIGludGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9PYmplY3QgPyBPYmplY3QuZnJvbUVudHJpZXMocmVzdWx0KSA6IHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuZnVuY3Rpb24gYXJjTGVycCh2YWx1ZSwgcmV2ZXJzZSwgcmF0aW8pIHtcbiAgbGV0IGZsaXAgPSByZXZlcnNlO1xuICBpZiAocmF0aW8gPiAxKSB7XG4gICAgcmF0aW8gPSAxIC8gcmF0aW87XG4gIH0gZWxzZSB7XG4gICAgZmxpcCA9ICFmbGlwO1xuICB9XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBmbGlwID8gTWF0aC5hY29zKGNsYW1wKC0xLCAxLCAxIC0gdmFsdWUpKSA6IE1hdGguYXNpbih2YWx1ZSk7XG4gIGNvbnN0IHJhZGlhbnMgPSBtYXAobm9ybWFsaXplZCwgbWFwKDAsIE1hdGguUEkgLyAyLCB2YWx1ZSksIHJhdGlvKTtcbiAgbGV0IHhWYWx1ZSA9IE1hdGguc2luKHJhZGlhbnMpO1xuICBsZXQgeVZhbHVlID0gMSAtIE1hdGguY29zKHJhZGlhbnMpO1xuICBpZiAocmV2ZXJzZSkge1xuICAgIFt4VmFsdWUsIHlWYWx1ZV0gPSBbeVZhbHVlLCB4VmFsdWVdO1xuICB9XG4gIHJldHVybiB7IHg6IHhWYWx1ZSwgeTogeVZhbHVlIH07XG59XG5mdW5jdGlvbiBkZWNvcmF0ZShmbjIsIC4uLmRlY29yYXRvcnMpIHtcbiAgY29uc3QgdGFyZ2V0ID0geyBbZm4yLm5hbWVdOiBmbjIgfTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBmbjIubmFtZSk7XG4gIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgZm9yIChsZXQgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGRlY29yYXRvcnNbaV0odGFyZ2V0LCBmbjIubmFtZSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0aHJlYWRhYmxlKGN1c3RvbU5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKF8sIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKSB7XG4gICAgY29uc3QgdmFsdWUgPSBkZXNjcmlwdG9yID09IG51bGwgPyB2b2lkIDAgOiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiAmJiB2YWx1ZS5wcm90b3R5cGUpIHtcbiAgICAgIGNvbnN0IHByb3RvdHlwZSA9IHZhbHVlLnByb3RvdHlwZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hbWVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBwcm90b3R5cGUsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFuYW1lRGVzY3JpcHRvciB8fCBuYW1lRGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICAgIHByb3RvdHlwZS5uYW1lID0gY3VzdG9tTmFtZSA/PyBwcm9wZXJ0eUtleTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBwcm90b3R5cGUudGhyZWFkYWJsZSA9IHRydWU7XG4gICAgfVxuICB9O1xufVxuZGVjb3JhdGUoc3ByaW5nLCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIHNwcmluZyhzcHJpbmcyLCBmcm9tLCB0bywgc2V0dGxlVG9sZXJhbmNlT3JPblByb2dyZXNzLCBvblByb2dyZXNzT3JPbkVuZCwgb25FbmQpIHtcbiAgY29uc3Qgc2V0dGxlVG9sZXJhbmNlID0gdHlwZW9mIHNldHRsZVRvbGVyYW5jZU9yT25Qcm9ncmVzcyA9PT0gXCJudW1iZXJcIiA/IHNldHRsZVRvbGVyYW5jZU9yT25Qcm9ncmVzcyA6IDFlLTM7XG4gIG9uRW5kID0gdHlwZW9mIHNldHRsZVRvbGVyYW5jZU9yT25Qcm9ncmVzcyA9PT0gXCJudW1iZXJcIiA/IG9uRW5kIDogb25Qcm9ncmVzc09yT25FbmQ7XG4gIGNvbnN0IG9uUHJvZ3Jlc3MgPSAodmFsdWUsIHRpbWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHNldHRsZVRvbGVyYW5jZU9yT25Qcm9ncmVzcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzZXR0bGVUb2xlcmFuY2VPck9uUHJvZ3Jlc3ModmFsdWUsIHRpbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9uUHJvZ3Jlc3NPck9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9uUHJvZ3Jlc3NPck9uRW5kKHZhbHVlLCB0aW1lKTtcbiAgICB9XG4gIH07XG4gIHNwcmluZzIgPSBzcHJpbmcyID8/IHtcbiAgICBtYXNzOiAwLjA1LFxuICAgIHN0aWZmbmVzczogMTAsXG4gICAgZGFtcGluZzogMC41XG4gIH07XG4gIGlmIChzcHJpbmcyLm1hc3MgPD0gMCkge1xuICAgIHVzZUxvZ2dlcigpLmVycm9yKG5ldyBFcnJvcihcIlNwcmluZyBtYXNzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuXCIpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNwcmluZzIuc3RpZmZuZXNzIDwgMCkge1xuICAgIHVzZUxvZ2dlcigpLmVycm9yKFxuICAgICAgbmV3IEVycm9yKFwiU3ByaW5nIHN0aWZmbmVzcyBtdXN0IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdG8gMC5cIilcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc3ByaW5nMi5kYW1waW5nIDwgMCkge1xuICAgIHVzZUxvZ2dlcigpLmVycm9yKFxuICAgICAgbmV3IEVycm9yKFwiU3ByaW5nIGRhbXBpbmcgbXVzdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRvIDAuXCIpXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGhyZWFkID0gdXNlVGhyZWFkKCk7XG4gIGxldCBwb3NpdGlvbiA9IGZyb207XG4gIGxldCB2ZWxvY2l0eSA9IHNwcmluZzIuaW5pdGlhbFZlbG9jaXR5ID8/IDA7XG4gIGNvbnN0IHVwZGF0ZSA9IChkdCkgPT4ge1xuICAgIGlmIChzcHJpbmcyID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uRGVsdGEgPSBwb3NpdGlvbiAtIHRvO1xuICAgIGNvbnN0IGZvcmNlID0gLXNwcmluZzIuc3RpZmZuZXNzICogcG9zaXRpb25EZWx0YSAtIHNwcmluZzIuZGFtcGluZyAqIHZlbG9jaXR5O1xuICAgIHZlbG9jaXR5ICs9IGZvcmNlIC8gc3ByaW5nMi5tYXNzICogZHQ7XG4gICAgcG9zaXRpb24gKz0gdmVsb2NpdHkgKiBkdDtcbiAgfTtcbiAgY29uc3Qgc2ltdWxhdGlvbkZyYW1lcyA9IDEyMDtcbiAgY29uc3QgdGltZVN0ZXAgPSAxIC8gc2ltdWxhdGlvbkZyYW1lcztcbiAgb25Qcm9ncmVzcyhmcm9tLCAwKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gdGhyZWFkLnRpbWUoKTtcbiAgbGV0IHNpbXVsYXRpb25UaW1lID0gc3RhcnRUaW1lO1xuICBsZXQgc2V0dGxlZCA9IGZhbHNlO1xuICB3aGlsZSAoIXNldHRsZWQpIHtcbiAgICB3aGlsZSAoc2ltdWxhdGlvblRpbWUgPCB0aHJlYWQuZml4ZWQpIHtcbiAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aHJlYWQuZml4ZWQgLSBzaW11bGF0aW9uVGltZTtcbiAgICAgIGlmICh0aW1lU3RlcCA+IGRpZmZlcmVuY2UpIHtcbiAgICAgICAgdXBkYXRlKGRpZmZlcmVuY2UpO1xuICAgICAgICBzaW11bGF0aW9uVGltZSA9IHRocmVhZC5maXhlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZSh0aW1lU3RlcCk7XG4gICAgICAgIHNpbXVsYXRpb25UaW1lICs9IHRpbWVTdGVwO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKHRvIC0gcG9zaXRpb24pIDwgc2V0dGxlVG9sZXJhbmNlICYmIE1hdGguYWJzKHZlbG9jaXR5KSA8IHNldHRsZVRvbGVyYW5jZSkge1xuICAgICAgICB0aHJlYWQudGltZShzaW11bGF0aW9uVGltZSk7XG4gICAgICAgIHNldHRsZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzZXR0bGVkKSB7XG4gICAgICBvblByb2dyZXNzKHBvc2l0aW9uLCB0aHJlYWQuZml4ZWQgLSBzdGFydFRpbWUpO1xuICAgICAgeWllbGQ7XG4gICAgfVxuICB9XG4gIG9uUHJvZ3Jlc3ModG8sIHRocmVhZC5maXhlZCAtIHN0YXJ0VGltZSk7XG4gIG9uRW5kID09IG51bGwgPyB2b2lkIDAgOiBvbkVuZCh0bywgdGhyZWFkLmZpeGVkIC0gc3RhcnRUaW1lKTtcbn1cbmZ1bmN0aW9uIGVhc2VJbk91dEN1YmljKHZhbHVlLCBmcm9tID0gMCwgdG8gPSAxKSB7XG4gIHZhbHVlID0gdmFsdWUgPCAwLjUgPyA0ICogdmFsdWUgKiB2YWx1ZSAqIHZhbHVlIDogMSAtIE1hdGgucG93KC0yICogdmFsdWUgKyAyLCAzKSAvIDI7XG4gIHJldHVybiBtYXAoZnJvbSwgdG8sIHZhbHVlKTtcbn1cbmRlY29yYXRlKHR3ZWVuLCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIHR3ZWVuKHNlY29uZHMsIG9uUHJvZ3Jlc3MsIG9uRW5kKSB7XG4gIGNvbnN0IHRocmVhZCA9IHVzZVRocmVhZCgpO1xuICBjb25zdCBzdGFydFRpbWUgPSB0aHJlYWQudGltZSgpO1xuICBjb25zdCBlbmRUaW1lID0gdGhyZWFkLnRpbWUoKSArIHNlY29uZHM7XG4gIG9uUHJvZ3Jlc3MoMCwgMCk7XG4gIHdoaWxlIChlbmRUaW1lID4gdGhyZWFkLmZpeGVkKSB7XG4gICAgY29uc3QgdGltZSA9IHRocmVhZC5maXhlZCAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCB2YWx1ZSA9IHRpbWUgLyBzZWNvbmRzO1xuICAgIGlmICh0aW1lID4gMCkge1xuICAgICAgb25Qcm9ncmVzcyh2YWx1ZSwgdGltZSk7XG4gICAgfVxuICAgIHlpZWxkO1xuICB9XG4gIHRocmVhZC50aW1lKGVuZFRpbWUpO1xuICBvblByb2dyZXNzKDEsIHNlY29uZHMpO1xuICBvbkVuZCA9PSBudWxsID8gdm9pZCAwIDogb25FbmQoMSwgc2Vjb25kcyk7XG59XG5uZXcgRXZlbnREaXNwYXRjaGVyKCk7XG5kZWNvcmF0ZShqb2luLCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIGpvaW4oZmlyc3QsIC4uLnRhc2tzKSB7XG4gIGxldCBhbGwyID0gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBhbGwyID0gZmlyc3Q7XG4gIH0gZWxzZSB7XG4gICAgdGFza3MucHVzaChmaXJzdCk7XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gdXNlVGhyZWFkKCk7XG4gIGNvbnN0IHRocmVhZHMyID0gdGFza3MubWFwKCh0YXNrKSA9PiBwYXJlbnQuY2hpbGRyZW4uZmluZCgodGhyZWFkKSA9PiB0aHJlYWQucnVubmVyID09PSB0YXNrKSkuZmlsdGVyKCh0aHJlYWQpID0+IHRocmVhZCk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHBhcmVudC50aW1lKCk7XG4gIGxldCBjaGlsZFRpbWU7XG4gIGlmIChhbGwyKSB7XG4gICAgd2hpbGUgKHRocmVhZHMyLmZpbmQoKHRocmVhZCkgPT4gIXRocmVhZC5jYW5jZWxlZCkpIHtcbiAgICAgIHlpZWxkO1xuICAgIH1cbiAgICBjaGlsZFRpbWUgPSBNYXRoLm1heCguLi50aHJlYWRzMi5tYXAoKHRocmVhZCkgPT4gdGhyZWFkLnRpbWUoKSkpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlICghdGhyZWFkczIuZmluZCgodGhyZWFkKSA9PiB0aHJlYWQuY2FuY2VsZWQpKSB7XG4gICAgICB5aWVsZDtcbiAgICB9XG4gICAgY29uc3QgY2FuY2VsZWQgPSB0aHJlYWRzMi5maWx0ZXIoKHRocmVhZCkgPT4gdGhyZWFkLmNhbmNlbGVkKTtcbiAgICBjaGlsZFRpbWUgPSBNYXRoLm1pbiguLi5jYW5jZWxlZC5tYXAoKHRocmVhZCkgPT4gdGhyZWFkLnRpbWUoKSkpO1xuICB9XG4gIHBhcmVudC50aW1lKE1hdGgubWF4KHN0YXJ0VGltZSwgY2hpbGRUaW1lKSk7XG59XG5kZWNvcmF0ZShhbGwsIHRocmVhZGFibGUoKSk7XG5mdW5jdGlvbiogYWxsKC4uLnRhc2tzKSB7XG4gIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgIHlpZWxkIHRhc2s7XG4gIH1cbiAgeWllbGQqIGpvaW4oLi4udGFza3MpO1xufVxuZGVjb3JhdGUoYW55LCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIGFueSguLi50YXNrcykge1xuICBmb3IgKGNvbnN0IHRhc2sgb2YgdGFza3MpIHtcbiAgICB5aWVsZCB0YXNrO1xuICB9XG4gIHlpZWxkKiBqb2luKGZhbHNlLCAuLi50YXNrcyk7XG59XG5kZWNvcmF0ZShjaGFpbiwgdGhyZWFkYWJsZSgpKTtcbmZ1bmN0aW9uKiBjaGFpbiguLi50YXNrcykge1xuICBmb3IgKGNvbnN0IGdlbmVyYXRvciBvZiB0YXNrcykge1xuICAgIGlmIChcIm5leHRcIiBpbiBnZW5lcmF0b3IpIHtcbiAgICAgIHlpZWxkKiBnZW5lcmF0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbmVyYXRvcigpO1xuICAgIH1cbiAgfVxufVxuZGVjb3JhdGUod2FpdEZvciwgdGhyZWFkYWJsZSgpKTtcbmZ1bmN0aW9uKiB3YWl0Rm9yKHNlY29uZHMgPSAwLCBhZnRlcikge1xuICBjb25zdCB0aHJlYWQgPSB1c2VUaHJlYWQoKTtcbiAgY29uc3Qgc3RlcCA9IHVzZVBsYXliYWNrKCkuZnJhbWVzVG9TZWNvbmRzKDEpO1xuICBjb25zdCB0YXJnZXRUaW1lID0gdGhyZWFkLnRpbWUoKSArIHNlY29uZHM7XG4gIHdoaWxlICh0YXJnZXRUaW1lIC0gc3RlcCA+IHRocmVhZC5maXhlZCkge1xuICAgIHlpZWxkO1xuICB9XG4gIHRocmVhZC50aW1lKHRhcmdldFRpbWUpO1xuICBpZiAoYWZ0ZXIpIHtcbiAgICB5aWVsZCogYWZ0ZXI7XG4gIH1cbn1cbmRlY29yYXRlKGRlbGF5LCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIGRlbGF5KHRpbWUsIHRhc2spIHtcbiAgeWllbGQqIHdhaXRGb3IodGltZSk7XG4gIGlmIChcIm5leHRcIiBpbiB0YXNrKSB7XG4gICAgeWllbGQqIHRhc2s7XG4gIH0gZWxzZSB7XG4gICAgdGFzaygpO1xuICB9XG59XG52YXIgaW5maW5pdGVMb29wID0gYFxuTWFrZSBzdXJlIHRvIHVzZSBcXGB5aWVsZFxcYCBvciBcXGBzcGF3bigpXFxgIHRvIGV4ZWN1dGUgdGhlIGxvb3AgY29uY3VycmVudGx5IGluIGFcbnNlcGFyYXRlIHRocmVhZDpcblxuXFxgXFxgXFxgdHMgd3Jvbmdcbi8vIHByZXR0aWVyLWlnbm9yZVxueWllbGQqIGxvb3AoKCkgPT4gcmVjdCgpLm9wYWNpdHkoMCkub3BhY2l0eSgxLCAxKSk7XG5cXGBcXGBcXGBcblxuXFxgXFxgXFxgdHMgY29ycmVjdFxueWllbGQgbG9vcCgoKSA9PiByZWN0KCkub3BhY2l0eSgwKS5vcGFjaXR5KDEsIDEpKTtcbi8vIG9yXG5zcGF3bihsb29wKCgpID0+IHJlY3QoKS5vcGFjaXR5KDApLm9wYWNpdHkoMSwgMSkpKTtcblxcYFxcYFxcYFxuXG5JZiB5b3Ugd2FudCB0byBleGVjdXRlIHRoZSBsb29wIGEgZmluaXRlIG51bWJlciBvZiB0aW1lcywgc3BlY2lmeSB0aGUgaXRlcmF0aW9uXG5jb3VudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQ6XG5cblxcYFxcYFxcYHRzXG4vLyBwcmV0dGllci1pZ25vcmVcbnlpZWxkKiBsb29wKDEwLCAoKSA9PiByZWN0KCkub3BhY2l0eSgwKS5vcGFjaXR5KDEsIDEpKTtcbi8vICAgICAgICAgIF4gaXRlcmF0aW9uIGNvdW50XG5cXGBcXGBcXGBcbmA7XG5kZWNvcmF0ZShsb29wLCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIGxvb3AoaXRlcmF0aW9ucywgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGl0ZXJhdGlvbnMgIT09IFwibnVtYmVyXCIpIHtcbiAgICBmYWN0b3J5ID0gaXRlcmF0aW9ucztcbiAgICBpdGVyYXRpb25zID0gSW5maW5pdHk7XG4gIH1cbiAgaWYgKGl0ZXJhdGlvbnMgPT09IEluZmluaXR5ICYmIHVzZVRocmVhZCgpLnBhcmVudCA9PT0gbnVsbCkge1xuICAgIHVzZUxvZ2dlcigpLmVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IFwiVHJpZWQgdG8gZXhlY3V0ZSBhbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtYWluIHRocmVhZC5cIixcbiAgICAgIHJlbWFya3M6IGluZmluaXRlTG9vcCxcbiAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFja1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IGZhY3RvcnkoaSk7XG4gICAgaWYgKGdlbmVyYXRvcikge1xuICAgICAgeWllbGQqIGdlbmVyYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQ7XG4gICAgfVxuICB9XG59XG5kZWNvcmF0ZShsb29wRm9yLCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIGxvb3BGb3Ioc2Vjb25kcywgZmFjdG9yeSkge1xuICBjb25zdCB0aHJlYWQgPSB1c2VUaHJlYWQoKTtcbiAgY29uc3Qgc3RlcCA9IHVzZVBsYXliYWNrKCkuZnJhbWVzVG9TZWNvbmRzKDEpO1xuICBjb25zdCB0YXJnZXRUaW1lID0gdGhyZWFkLnRpbWUoKSArIHNlY29uZHM7XG4gIGxldCBpdGVyYXRpb24gPSAwO1xuICB3aGlsZSAodGFyZ2V0VGltZSAtIHN0ZXAgPiB0aHJlYWQuZml4ZWQpIHtcbiAgICBjb25zdCBnZW5lcmF0b3IgPSBmYWN0b3J5KGl0ZXJhdGlvbik7XG4gICAgaWYgKGdlbmVyYXRvcikge1xuICAgICAgeWllbGQqIGdlbmVyYXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgeWllbGQ7XG4gICAgfVxuICAgIGl0ZXJhdGlvbiArPSAxO1xuICB9XG4gIHRocmVhZC50aW1lKHRhcmdldFRpbWUpO1xufVxuZnVuY3Rpb24gc2V0VGFza05hbWUodGFzaywgc291cmNlKSB7XG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXNrKTtcbiAgaWYgKHByb3RvdHlwZSAmJiAhcHJvdG90eXBlLnRocmVhZGFibGUpIHtcbiAgICBwcm90b3R5cGUudGhyZWFkYWJsZSA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc29sdmVkTmFtZSA9IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgPyBzb3VyY2UgOiBnZXRUYXNrTmFtZShzb3VyY2UpO1xuICAgICAgY29uc3QgbmFtZURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuICAgICAgICBwcm90b3R5cGUsXG4gICAgICAgIFwibmFtZVwiXG4gICAgICApO1xuICAgICAgaWYgKCFuYW1lRGVzY3JpcHRvciB8fCBuYW1lRGVzY3JpcHRvci53cml0YWJsZSkge1xuICAgICAgICBwcm90b3R5cGUubmFtZSA9IHJlc29sdmVkTmFtZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRhc2tOYW1lKHRhc2spIHtcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXNrKS5uYW1lID8/IG51bGw7XG59XG5mdW5jdGlvbiBydW4oZmlyc3RBcmcsIHJ1bm5lcikge1xuICBsZXQgdGFzaztcbiAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRhc2sgPSBydW5uZXIoKTtcbiAgICBzZXRUYXNrTmFtZSh0YXNrLCBmaXJzdEFyZyk7XG4gIH0gZWxzZSB7XG4gICAgdGFzayA9IGZpcnN0QXJnKCk7XG4gICAgc2V0VGFza05hbWUodGFzaywgdGFzayk7XG4gIH1cbiAgcmV0dXJuIHRhc2s7XG59XG5kZWNvcmF0ZShzZXF1ZW5jZSwgdGhyZWFkYWJsZSgpKTtcbmZ1bmN0aW9uKiBzZXF1ZW5jZShkZWxheTIsIC4uLnRhc2tzKSB7XG4gIGZvciAoY29uc3QgdGFzayBvZiB0YXNrcykge1xuICAgIHlpZWxkIHRhc2s7XG4gICAgeWllbGQqIHdhaXRGb3IoZGVsYXkyKTtcbiAgfVxuICB5aWVsZCogam9pbiguLi50YXNrcyk7XG59XG52YXIgX0RlcGVuZGVuY3lDb250ZXh0ID0gY2xhc3MgX0RlcGVuZGVuY3lDb250ZXh0MiB7XG4gIGNvbnN0cnVjdG9yKG93bmVyKSB7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmV2ZW50ID0gbmV3IEZsYWdEaXNwYXRjaGVyKCk7XG4gICAgdGhpcy5tYXJrRGlydHkgPSAoKSA9PiB0aGlzLmV2ZW50LnJhaXNlKCk7XG4gICAgdGhpcy5pbnZva2FibGUgPSB0aGlzLmludm9rZS5iaW5kKHRoaXMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmludm9rYWJsZSwgXCJjb250ZXh0XCIsIHtcbiAgICAgIHZhbHVlOiB0aGlzXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuaW52b2thYmxlLCBcInRvUHJvbWlzZVwiLCB7XG4gICAgICB2YWx1ZTogdGhpcy50b1Byb21pc2UuYmluZCh0aGlzKVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjb2xsZWN0UHJvbWlzZShwcm9taXNlLCBpbml0aWFsVmFsdWUgPSBudWxsKSB7XG4gICAgY29uc3QgaGFuZGxlID0ge1xuICAgICAgcHJvbWlzZSxcbiAgICAgIHZhbHVlOiBpbml0aWFsVmFsdWUsXG4gICAgICBzdGFjazogbmV3IEVycm9yKCkuc3RhY2tcbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNvbGxlY3Rpb25TdGFjay5hdCgtMSk7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGhhbmRsZS5vd25lciA9IGNvbnRleHQub3duZXI7XG4gICAgfVxuICAgIHByb21pc2UudGhlbigodmFsdWUpID0+IHtcbiAgICAgIGhhbmRsZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5tYXJrRGlydHkoKTtcbiAgICB9KTtcbiAgICB0aGlzLnByb21pc2VzLnB1c2goaGFuZGxlKTtcbiAgICByZXR1cm4gaGFuZGxlO1xuICB9XG4gIHN0YXRpYyBoYXNQcm9taXNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlcy5sZW5ndGggPiAwO1xuICB9XG4gIHN0YXRpYyBhc3luYyBjb25zdW1lUHJvbWlzZXMoKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbLi4udGhpcy5wcm9taXNlc107XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMubWFwKChoYW5kbGUpID0+IGhhbmRsZS5wcm9taXNlKSk7XG4gICAgdGhpcy5wcm9taXNlcyA9IHRoaXMucHJvbWlzZXMuZmlsdGVyKCh2KSA9PiAhcHJvbWlzZXMuaW5jbHVkZXModikpO1xuICAgIHJldHVybiBwcm9taXNlcztcbiAgfVxuICBpbnZva2UoKSB7XG4gIH1cbiAgc3RhcnRDb2xsZWN0aW5nKCkge1xuICAgIGlmIChfRGVwZW5kZW5jeUNvbnRleHQyLmNvbGxlY3Rpb25TZXQuaGFzKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRGV0YWlsZWRFcnJvcihcbiAgICAgICAgXCJBIGNpcmN1bGFyIGRlcGVuZGVuY3kgb2NjdXJyZWQgYmV0d2VlbiBzaWduYWxzLlwiLFxuICAgICAgICBgVGhpcyBjYW4gaGFwcGVuIHdoZW4gc2lnbmFscyByZWZlcmVuY2UgZWFjaCBvdGhlciBpbiBhIGxvb3AuXG4gICAgICAgIFRyeSB1c2luZyB0aGUgYXR0YWNoZWQgc3RhY2sgdHJhY2UgdG8gbG9jYXRlIHNhaWQgbG9vcC5gXG4gICAgICApO1xuICAgIH1cbiAgICBfRGVwZW5kZW5jeUNvbnRleHQyLmNvbGxlY3Rpb25TZXQuYWRkKHRoaXMpO1xuICAgIF9EZXBlbmRlbmN5Q29udGV4dDIuY29sbGVjdGlvblN0YWNrLnB1c2godGhpcyk7XG4gIH1cbiAgZmluaXNoQ29sbGVjdGluZygpIHtcbiAgICBfRGVwZW5kZW5jeUNvbnRleHQyLmNvbGxlY3Rpb25TZXQuZGVsZXRlKHRoaXMpO1xuICAgIGlmIChfRGVwZW5kZW5jeUNvbnRleHQyLmNvbGxlY3Rpb25TdGFjay5wb3AoKSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGVjdFN0YXJ0L2NvbGxlY3RFbmQgd2FzIGNhbGxlZCBvdXQgb2Ygb3JkZXIuXCIpO1xuICAgIH1cbiAgfVxuICBjbGVhckRlcGVuZGVuY2llcygpIHtcbiAgICB0aGlzLmRlcGVuZGVuY2llcy5mb3JFYWNoKChkZXApID0+IGRlcC51bnN1YnNjcmliZSh0aGlzLm1hcmtEaXJ0eSkpO1xuICAgIHRoaXMuZGVwZW5kZW5jaWVzLmNsZWFyKCk7XG4gIH1cbiAgY29sbGVjdCgpIHtcbiAgICBjb25zdCBzaWduYWwgPSBfRGVwZW5kZW5jeUNvbnRleHQyLmNvbGxlY3Rpb25TdGFjay5hdCgtMSk7XG4gICAgaWYgKHNpZ25hbCkge1xuICAgICAgc2lnbmFsLmRlcGVuZGVuY2llcy5hZGQodGhpcy5ldmVudC5zdWJzY3JpYmFibGUpO1xuICAgICAgdGhpcy5ldmVudC5zdWJzY3JpYmUoc2lnbmFsLm1hcmtEaXJ0eSk7XG4gICAgfVxuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5jbGVhckRlcGVuZGVuY2llcygpO1xuICAgIHRoaXMuZXZlbnQuY2xlYXIoKTtcbiAgICB0aGlzLm93bmVyID0gbnVsbDtcbiAgfVxuICBhc3luYyB0b1Byb21pc2UoKSB7XG4gICAgZG8ge1xuICAgICAgYXdhaXQgX0RlcGVuZGVuY3lDb250ZXh0Mi5jb25zdW1lUHJvbWlzZXMoKTtcbiAgICAgIHRoaXMuaW52b2thYmxlKCk7XG4gICAgfSB3aGlsZSAoX0RlcGVuZGVuY3lDb250ZXh0Mi5oYXNQcm9taXNlcygpKTtcbiAgICByZXR1cm4gdGhpcy5pbnZva2FibGU7XG4gIH1cbn07XG5fRGVwZW5kZW5jeUNvbnRleHQuY29sbGVjdGlvblNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5fRGVwZW5kZW5jeUNvbnRleHQuY29sbGVjdGlvblN0YWNrID0gW107XG5fRGVwZW5kZW5jeUNvbnRleHQucHJvbWlzZXMgPSBbXTtcbnZhciBEZXBlbmRlbmN5Q29udGV4dCA9IF9EZXBlbmRlbmN5Q29udGV4dDtcbnZhciBERUZBVUxUID0gLyogQF9fUFVSRV9fICovIFN5bWJvbC5mb3IoXCJAdHdpY2svY29yZS9zaWduYWxzL2RlZmF1bHRcIik7XG5mdW5jdGlvbiBpc1JlYWN0aXZlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIG1vZGlmeSh2YWx1ZSwgbW9kaWZpY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSA/ICgpID0+IG1vZGlmaWNhdGlvbih2YWx1ZSgpKSA6IG1vZGlmaWNhdGlvbih2YWx1ZSk7XG59XG5mdW5jdGlvbiB1bndyYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzUmVhY3RpdmUodmFsdWUpID8gdmFsdWUoKSA6IHZhbHVlO1xufVxudmFyIFNpZ25hbENvbnRleHQgPSBjbGFzcyBleHRlbmRzIERlcGVuZGVuY3lDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoaW5pdGlhbCwgaW50ZXJwb2xhdGlvbiwgb3duZXIgPSB2b2lkIDAsIHBhcnNlciA9ICh2YWx1ZSkgPT4gdmFsdWUsIGV4dGVuc2lvbnMgPSB7fSkge1xuICAgIHN1cGVyKG93bmVyKTtcbiAgICB0aGlzLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy50d2VlbmluZyA9IGZhbHNlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmludm9rYWJsZSwgXCJyZXNldFwiLCB7XG4gICAgICB2YWx1ZTogdGhpcy5yZXNldC5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuaW52b2thYmxlLCBcInNhdmVcIiwge1xuICAgICAgdmFsdWU6IHRoaXMuc2F2ZS5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuaW52b2thYmxlLCBcImlzSW5pdGlhbFwiLCB7XG4gICAgICB2YWx1ZTogdGhpcy5pc0luaXRpYWwuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIGlmICh0aGlzLmluaXRpYWwgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5pbml0aWFsO1xuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgIGlmICghaXNSZWFjdGl2ZSh0aGlzLmluaXRpYWwpKSB7XG4gICAgICAgIHRoaXMubGFzdCA9IHRoaXMucGFyc2UodGhpcy5pbml0aWFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHRlbnNpb25zID0ge1xuICAgICAgZ2V0dGVyOiB0aGlzLmdldHRlci5iaW5kKHRoaXMpLFxuICAgICAgc2V0dGVyOiB0aGlzLnNldHRlci5iaW5kKHRoaXMpLFxuICAgICAgdHdlZW5lcjogdGhpcy50d2VlbmVyLmJpbmQodGhpcyksXG4gICAgICAuLi5leHRlbnNpb25zXG4gICAgfTtcbiAgfVxuICB0b1NpZ25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZva2FibGU7XG4gIH1cbiAgcGFyc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZXIodmFsdWUpO1xuICB9XG4gIHNldCh2YWx1ZSkge1xuICAgIHRoaXMuZXh0ZW5zaW9ucy5zZXR0ZXIodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLm93bmVyO1xuICB9XG4gIHNldHRlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gREVGQVVMVCkge1xuICAgICAgdmFsdWUgPSB0aGlzLmluaXRpYWw7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnJlbnQgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lcjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gdmFsdWU7XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICB0aGlzLmNsZWFyRGVwZW5kZW5jaWVzKCk7XG4gICAgaWYgKCFpc1JlYWN0aXZlKHZhbHVlKSkge1xuICAgICAgdGhpcy5sYXN0ID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm93bmVyO1xuICB9XG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldHRlcigpO1xuICB9XG4gIGdldHRlcigpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuZXZlbnQuaXNSYWlzZWQoKSAmJiBpc1JlYWN0aXZlKHRoaXMuY3VycmVudCkpIHtcbiAgICAgIHRoaXMuY2xlYXJEZXBlbmRlbmNpZXMoKTtcbiAgICAgIHRoaXMuc3RhcnRDb2xsZWN0aW5nKCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLnBhcnNlKHRoaXMuY3VycmVudCgpKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHVzZUxvZ2dlcigpLmVycm9yKHtcbiAgICAgICAgICAuLi5lcnJvclRvTG9nKGUyKSxcbiAgICAgICAgICBpbnNwZWN0OiAoX2EgPSB0aGlzLm93bmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2Eua2V5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5maW5pc2hDb2xsZWN0aW5nKCk7XG4gICAgfVxuICAgIHRoaXMuZXZlbnQucmVzZXQoKTtcbiAgICB0aGlzLmNvbGxlY3QoKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0O1xuICB9XG4gIGludm9rZSh2YWx1ZSwgZHVyYXRpb24sIHRpbWluZ0Z1bmN0aW9uID0gZWFzZUluT3V0Q3ViaWMsIGludGVycG9sYXRpb25GdW5jdGlvbiA9IHRoaXMuaW50ZXJwb2xhdGlvbikge1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoKTtcbiAgICB9XG4gICAgaWYgKGR1cmF0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5jcmVhdGVRdWV1ZSh0aW1pbmdGdW5jdGlvbiwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKTtcbiAgICByZXR1cm4gcXVldWUudG8odmFsdWUsIGR1cmF0aW9uKTtcbiAgfVxuICBjcmVhdGVRdWV1ZShkZWZhdWx0VGltaW5nRnVuY3Rpb24sIGRlZmF1bHRJbnRlcnBvbGF0aW9uRnVuY3Rpb24pIHtcbiAgICBjb25zdCBpbml0aWFsID0gdGhpcy5nZXQoKTtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGNvbnN0IHRhc2sgPSBydW4oXCJhbmltYXRpb24gY2hhaW5cIiwgZnVuY3Rpb24qIGFuaW1hdGUoKSB7XG4gICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICB5aWVsZCogcXVldWUuc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YXNrLnRvID0gKHZhbHVlLCBkdXJhdGlvbiwgdGltaW5nRnVuY3Rpb24gPSBkZWZhdWx0VGltaW5nRnVuY3Rpb24sIGludGVycG9sYXRpb25GdW5jdGlvbiA9IGRlZmF1bHRJbnRlcnBvbGF0aW9uRnVuY3Rpb24pID0+IHtcbiAgICAgIGRlZmF1bHRUaW1pbmdGdW5jdGlvbiA9IHRpbWluZ0Z1bmN0aW9uO1xuICAgICAgZGVmYXVsdEludGVycG9sYXRpb25GdW5jdGlvbiA9IGludGVycG9sYXRpb25GdW5jdGlvbjtcbiAgICAgIHF1ZXVlLnB1c2goXG4gICAgICAgIHRoaXMudHdlZW4odmFsdWUsIGR1cmF0aW9uLCB0aW1pbmdGdW5jdGlvbiwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH07XG4gICAgdGFzay5iYWNrID0gKHRpbWUsIHRpbWluZ0Z1bmN0aW9uID0gZGVmYXVsdFRpbWluZ0Z1bmN0aW9uLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBkZWZhdWx0SW50ZXJwb2xhdGlvbkZ1bmN0aW9uKSA9PiB7XG4gICAgICBkZWZhdWx0VGltaW5nRnVuY3Rpb24gPSB0aW1pbmdGdW5jdGlvbjtcbiAgICAgIGRlZmF1bHRJbnRlcnBvbGF0aW9uRnVuY3Rpb24gPSBpbnRlcnBvbGF0aW9uRnVuY3Rpb247XG4gICAgICBxdWV1ZS5wdXNoKFxuICAgICAgICB0aGlzLnR3ZWVuKFxuICAgICAgICAgIGluaXRpYWwsXG4gICAgICAgICAgdGltZSxcbiAgICAgICAgICBkZWZhdWx0VGltaW5nRnVuY3Rpb24sXG4gICAgICAgICAgZGVmYXVsdEludGVycG9sYXRpb25GdW5jdGlvblxuICAgICAgICApXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfTtcbiAgICB0YXNrLndhaXQgPSAoZHVyYXRpb24pID0+IHtcbiAgICAgIHF1ZXVlLnB1c2god2FpdEZvcihkdXJhdGlvbikpO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfTtcbiAgICB0YXNrLnJ1biA9IChnZW5lcmF0b3IpID0+IHtcbiAgICAgIHF1ZXVlLnB1c2goZ2VuZXJhdG9yKTtcbiAgICAgIHJldHVybiB0YXNrO1xuICAgIH07XG4gICAgdGFzay5kbyA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgcXVldWUucHVzaChcbiAgICAgICAgcnVuKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGFzaztcbiAgICB9O1xuICAgIHJldHVybiB0YXNrO1xuICB9XG4gICp0d2Vlbih2YWx1ZSwgZHVyYXRpb24sIHRpbWluZ0Z1bmN0aW9uLCBpbnRlcnBvbGF0aW9uRnVuY3Rpb24pIHtcbiAgICBpZiAodmFsdWUgPT09IERFRkFVTFQpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5pbml0aWFsO1xuICAgIH1cbiAgICB0aGlzLnR3ZWVuaW5nID0gdHJ1ZTtcbiAgICB5aWVsZCogdGhpcy5leHRlbnNpb25zLnR3ZWVuZXIoXG4gICAgICB2YWx1ZSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGltaW5nRnVuY3Rpb24sXG4gICAgICBpbnRlcnBvbGF0aW9uRnVuY3Rpb25cbiAgICApO1xuICAgIHRoaXMuc2V0KHZhbHVlKTtcbiAgICB0aGlzLnR3ZWVuaW5nID0gZmFsc2U7XG4gIH1cbiAgKnR3ZWVuZXIodmFsdWUsIGR1cmF0aW9uLCB0aW1pbmdGdW5jdGlvbiwgaW50ZXJwb2xhdGlvbkZ1bmN0aW9uKSB7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuZ2V0KCk7XG4gICAgeWllbGQqIHR3ZWVuKGR1cmF0aW9uLCAodikgPT4ge1xuICAgICAgdGhpcy5zZXQoXG4gICAgICAgIGludGVycG9sYXRpb25GdW5jdGlvbihcbiAgICAgICAgICBmcm9tLFxuICAgICAgICAgIHRoaXMucGFyc2UodW53cmFwKHZhbHVlKSksXG4gICAgICAgICAgdGltaW5nRnVuY3Rpb24odilcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmluaXRpYWwgPSB2b2lkIDA7XG4gICAgdGhpcy5jdXJyZW50ID0gdm9pZCAwO1xuICAgIHRoaXMubGFzdCA9IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogUmVzZXQgdGhlIHNpZ25hbCB0byBpdHMgaW5pdGlhbCB2YWx1ZSAoaWYgb25lIGhhcyBiZWVuIHNldCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IHNpZ25hbCA9IGNyZWF0ZVNpZ25hbCg3KTtcbiAgICpcbiAgICogc2lnbmFsLnJlc2V0KCk7XG4gICAqIC8vIHNhbWUgYXM6XG4gICAqIHNpZ25hbCg3KTtcbiAgICogYGBgXG4gICAqL1xuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuc2V0KHRoaXMuaW5pdGlhbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm93bmVyO1xuICB9XG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzaWduYWwgYW5kIGltbWVkaWF0ZWx5IHNldCBpdC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgdG8gc3RvcCB0aGUgc2lnbmFsIGZyb20gdXBkYXRpbmcgd2hpbGUga2VlcGluZyBpdHNcbiAgICogY3VycmVudCB2YWx1ZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogc2lnbmFsLnNhdmUoKTtcbiAgICogLy8gc2FtZSBhczpcbiAgICogc2lnbmFsKHNpZ25hbCgpKTtcbiAgICogYGBgXG4gICAqL1xuICBzYXZlKCkge1xuICAgIHJldHVybiB0aGlzLnNldCh0aGlzLmdldCgpKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHNpZ25hbCBpcyBjdXJyZW50bHkgdXNpbmcgaXRzIGluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqXG4gICAqIGNvbnN0IHNpZ25hbCA9IGNyZWF0ZVNpZ25hbCgwKTtcbiAgICogc2lnbmFsLmlzSW5pdGlhbCgpOyAvLyB0cnVlXG4gICAqXG4gICAqIHNpZ25hbCg1KTtcbiAgICogc2lnbmFsLmlzSW5pdGlhbCgpOyAvLyBmYWxzZVxuICAgKlxuICAgKiBzaWduYWwoREVGQVVMVCk7XG4gICAqIHNpZ25hbC5pc0luaXRpYWwoKTsgLy8gdHJ1ZVxuICAgKiBgYGBcbiAgICovXG4gIGlzSW5pdGlhbCgpIHtcbiAgICB0aGlzLmNvbGxlY3QoKTtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSB0aGlzLmluaXRpYWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGlzIHNpZ25hbC5cbiAgICovXG4gIGdldEluaXRpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdGlhbDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSByYXcgdmFsdWUgb2YgdGhpcyBzaWduYWwuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIElmIHRoZSBzaWduYWwgd2FzIHByb3ZpZGVkIHdpdGggYSBmYWN0b3J5IGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXRzZWxmXG4gICAqIHdpbGwgYmUgcmV0dXJuZWQsIHdpdGhvdXQgaW52b2tpbmcgaXQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBjb3BpZXMgb2Ygc2lnbmFscy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgYSA9IGNyZWF0ZVNpZ25hbCgyKTtcbiAgICogY29uc3QgYiA9IGNyZWF0ZVNpZ25hbCgoKSA9PiBhKTtcbiAgICogLy8gYigpID09IDJcbiAgICpcbiAgICogY29uc3QgYkNsb25lID0gY3JlYXRlU2lnbmFsKGIucmF3KCkpO1xuICAgKiAvLyBiQ2xvbmUoKSA9PSAyXG4gICAqXG4gICAqIGEoNCk7XG4gICAqIC8vIGIoKSA9PSA0XG4gICAqIC8vIGJDbG9uZSgpID09IDRcbiAgICogYGBgXG4gICAqL1xuICByYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgfVxuICAvKipcbiAgICogSXMgdGhlIHNpZ25hbCB1bmRlcmdvaW5nIGEgdHdlZW4/XG4gICAqL1xuICBpc1R3ZWVuaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnR3ZWVuaW5nO1xuICB9XG59O1xudmFyIENvbXBvdW5kU2lnbmFsQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgU2lnbmFsQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMsIHBhcnNlciwgaW5pdGlhbCwgaW50ZXJwb2xhdGlvbiwgb3duZXIgPSB2b2lkIDAsIGV4dGVuc2lvbnMgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBzdXBlcih2b2lkIDAsIGludGVycG9sYXRpb24sIG93bmVyLCBwYXJzZXIsIGV4dGVuc2lvbnMpO1xuICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgdGhpcy5zaWduYWxzID0gW107XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICBsZXQga2V5O1xuICAgICAgbGV0IHNpZ25hbDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5KSkge1xuICAgICAgICBba2V5LCBzaWduYWxdID0gZW50cnk7XG4gICAgICAgIChfYSA9IHNpZ25hbC5jb250ZXh0KS5vd25lciA/PyAoX2Eub3duZXIgPSB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IGVudHJ5O1xuICAgICAgICBzaWduYWwgPSBuZXcgU2lnbmFsQ29udGV4dChcbiAgICAgICAgICBtb2RpZnkoaW5pdGlhbCwgKHZhbHVlKSA9PiBwYXJzZXIodmFsdWUpW2VudHJ5XSksXG4gICAgICAgICAgbWFwLFxuICAgICAgICAgIG93bmVyID8/IHRoaXMuaW52b2thYmxlXG4gICAgICAgICkudG9TaWduYWwoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnbmFscy5wdXNoKFtrZXksIHNpZ25hbF0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuaW52b2thYmxlLCBrZXksIHsgdmFsdWU6IHNpZ25hbCB9KTtcbiAgICB9XG4gIH1cbiAgdG9TaWduYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52b2thYmxlO1xuICB9XG4gIHBhcnNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VyKHZhbHVlKTtcbiAgfVxuICBnZXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIHRoaXMuc2lnbmFscy5tYXAoKFtrZXksIHByb3BlcnR5XSkgPT4gW2tleSwgcHJvcGVydHkoKV0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBzZXR0ZXIodmFsdWUpIHtcbiAgICBpZiAoaXNSZWFjdGl2ZSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcGVydHldIG9mIHRoaXMuc2lnbmFscykge1xuICAgICAgICBwcm9wZXJ0eSgoKSA9PiB0aGlzLnBhcnNlcih2YWx1ZSgpKVtrZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BlcnR5XSBvZiB0aGlzLnNpZ25hbHMpIHtcbiAgICAgICAgcHJvcGVydHkocGFyc2VkW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vd25lcjtcbiAgfVxuICByZXNldCgpIHtcbiAgICBmb3IgKGNvbnN0IFssIHNpZ25hbF0gb2YgdGhpcy5zaWduYWxzKSB7XG4gICAgICBzaWduYWwucmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3duZXI7XG4gIH1cbiAgc2F2ZSgpIHtcbiAgICBmb3IgKGNvbnN0IFssIHNpZ25hbF0gb2YgdGhpcy5zaWduYWxzKSB7XG4gICAgICBzaWduYWwuc2F2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5vd25lcjtcbiAgfVxuICBpc0luaXRpYWwoKSB7XG4gICAgZm9yIChjb25zdCBbLCBzaWduYWxdIG9mIHRoaXMuc2lnbmFscykge1xuICAgICAgaWYgKCFzaWduYWwuaXNJbml0aWFsKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByYXcoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIHRoaXMuc2lnbmFscy5tYXAoKFtrZXksIHByb3BlcnR5XSkgPT4gW2tleSwgcHJvcGVydHkuY29udGV4dC5yYXcoKV0pXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVNpZ25hbChpbml0aWFsLCBpbnRlcnBvbGF0aW9uID0gZGVlcExlcnAsIG93bmVyKSB7XG4gIHJldHVybiBuZXcgU2lnbmFsQ29udGV4dChcbiAgICBpbml0aWFsLFxuICAgIGludGVycG9sYXRpb24sXG4gICAgb3duZXJcbiAgKS50b1NpZ25hbCgpO1xufVxudmFyIEVQU0lMT04gPSAxZS02O1xudmFyIF9WZWN0b3IyID0gY2xhc3MgX1ZlY3RvcjIyIHtcbiAgY29uc3RydWN0b3Iob25lLCB0d28pIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgaWYgKG9uZSA9PT0gdm9pZCAwIHx8IG9uZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhpcy54ID0gb25lO1xuICAgICAgdGhpcy55ID0gdHdvID8/IG9uZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob25lKSkge1xuICAgICAgdGhpcy54ID0gb25lWzBdO1xuICAgICAgdGhpcy55ID0gb25lWzFdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoXCJ3aWR0aFwiIGluIG9uZSkge1xuICAgICAgdGhpcy54ID0gb25lLndpZHRoO1xuICAgICAgdGhpcy55ID0gb25lLmhlaWdodDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy54ID0gb25lLng7XG4gICAgdGhpcy55ID0gb25lLnk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVNpZ25hbChpbml0aWFsLCBpbnRlcnBvbGF0aW9uID0gX1ZlY3RvcjIyLmxlcnAsIG93bmVyKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wb3VuZFNpZ25hbENvbnRleHQoXG4gICAgICBbXCJ4XCIsIFwieVwiXSxcbiAgICAgICh2YWx1ZSkgPT4gbmV3IF9WZWN0b3IyMih2YWx1ZSksXG4gICAgICBpbml0aWFsLFxuICAgICAgaW50ZXJwb2xhdGlvbixcbiAgICAgIG93bmVyXG4gICAgKS50b1NpZ25hbCgpO1xuICB9XG4gIHN0YXRpYyBsZXJwKGZyb20sIHRvLCB2YWx1ZSkge1xuICAgIGxldCB2YWx1ZVg7XG4gICAgbGV0IHZhbHVlWTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YWx1ZVggPSB2YWx1ZVkgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVYID0gdmFsdWUueDtcbiAgICAgIHZhbHVlWSA9IHZhbHVlLnk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1ZlY3RvcjIyKG1hcChmcm9tLngsIHRvLngsIHZhbHVlWCksIG1hcChmcm9tLnksIHRvLnksIHZhbHVlWSkpO1xuICB9XG4gIHN0YXRpYyBhcmNMZXJwKGZyb20sIHRvLCB2YWx1ZSwgcmV2ZXJzZSA9IGZhbHNlLCByYXRpbykge1xuICAgIHJhdGlvID8/IChyYXRpbyA9IGZyb20uc3ViKHRvKS5jdGcpO1xuICAgIHJldHVybiBfVmVjdG9yMjIubGVycChmcm9tLCB0bywgbmV3IF9WZWN0b3IyMihhcmNMZXJwKHZhbHVlLCByZXZlcnNlLCByYXRpbykpKTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlQXJjTGVycChyZXZlcnNlLCByYXRpbykge1xuICAgIHJldHVybiAoZnJvbSwgdG8sIHZhbHVlKSA9PiBfVmVjdG9yMjIuYXJjTGVycChmcm9tLCB0bywgdmFsdWUsIHJldmVyc2UsIHJhdGlvKTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIHZlY3RvcnMgb24gdGhlIHBvbGFyIHBsYW5lIGJ5IGludGVycG9sYXRpbmdcbiAgICogdGhlIGFuZ2xlcyBhbmQgbWFnbml0dWRlcyBvZiB0aGUgdmVjdG9ycyBpbmRpdmlkdWFsbHkuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0aW5nIHZlY3Rvci5cbiAgICogQHBhcmFtIHRvIC0gVGhlIHRhcmdldCB2ZWN0b3IuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB0LXZhbHVlIG9mIHRoZSBpbnRlcnBvbGF0aW9uLlxuICAgKiBAcGFyYW0gY291bnRlcmNsb2Nrd2lzZSAtIFdoZXRoZXIgdGhlIHZlY3RvciBzaG91bGQgZ2V0IHJvdGF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyY2xvY2t3aXNlLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIGNlbnRlciBvZiByb3RhdGlvbi4gRGVmYXVsdHMgdG8gdGhlIG9yaWdpbi5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VmdWwgd2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIHJvdGF0ZX0gdG9cbiAgICogYW5pbWF0ZSBhbiBvYmplY3QncyBwb3NpdGlvbiBvbiBhIGNpcmN1bGFyIGFyYyAoc2VlIGV4YW1wbGVzKS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogQW5pbWF0aW5nIGFuIG9iamVjdCBpbiBhIGNpcmNsZSBhcm91bmQgdGhlIG9yaWdpblxuICAgKiBgYGB0c3hcbiAgICogY2lyY2xlKCkucG9zaXRpb24oXG4gICAqICAgY2lyY2xlKCkucG9zaXRpb24oKS5yb3RhdGUoMTgwKSxcbiAgICogICAxLFxuICAgKiAgIGVhc2VJbk91dEN1YmljLFxuICAgKiAgIFZlY3RvcjIucG9sYXJMZXJwXG4gICAqICk7XG4gICAqIGBgYFxuICAgKiBAZXhhbXBsZVxuICAgKiBSb3RhdGluZyBhbiBvYmplY3QgYXJvdW5kIHRoZSBwb2ludCBgWy0yMDAsIDEwMF1gXG4gICAqIGBgYHRzXG4gICAqIGNpcmNsZSgpLnBvc2l0aW9uKFxuICAgKiAgIGNpcmNsZSgpLnBvc2l0aW9uKCkucm90YXRlKDE4MCwgWy0yMDAsIDEwMF0pLFxuICAgKiAgIDEsXG4gICAqICAgZWFzZUluT3V0Q3ViaWMsXG4gICAqICAgVmVjdG9yMi5jcmVhdGVQb2xhckxlcnAoZmFsc2UsIFstMjAwLCAxMDBdKSxcbiAgICogKTtcbiAgICogYGBgXG4gICAqIEBleGFtcGxlXG4gICAqIFJvdGF0aW5nIGFuIG9iamVjdCBjb3VudGVyY2xvY2t3aXNlIGFyb3VuZCB0aGUgb3JpZ2luXG4gICAqIGBgYHRzXG4gICAqIGNpcmNsZSgpLnBvc2l0aW9uKFxuICAgKiAgIGNpcmNsZSgpLnBvc2l0aW9uKCkucm90YXRlKDE4MCksXG4gICAqICAgMSxcbiAgICogICBlYXNlSW5PdXRDdWJpYyxcbiAgICogICBWZWN0b3IyLmNyZWF0ZVBvbGFyTGVycCh0cnVlKSxcbiAgICogKTtcbiAgICogYGBgXG4gICAqL1xuICBzdGF0aWMgcG9sYXJMZXJwKGZyb20sIHRvLCB2YWx1ZSwgY291bnRlcmNsb2Nrd2lzZSA9IGZhbHNlLCBvcmlnaW4gPSBfVmVjdG9yMjIuemVybykge1xuICAgIGZyb20gPSBmcm9tLnN1YihvcmlnaW4pO1xuICAgIHRvID0gdG8uc3ViKG9yaWdpbik7XG4gICAgY29uc3QgZnJvbUFuZ2xlID0gZnJvbS5kZWdyZWVzO1xuICAgIGxldCB0b0FuZ2xlID0gdG8uZGVncmVlcztcbiAgICBjb25zdCBpc0NvdW50ZXJjbG9ja3dpc2UgPSBmcm9tQW5nbGUgPiB0b0FuZ2xlO1xuICAgIGlmIChpc0NvdW50ZXJjbG9ja3dpc2UgIT09IGNvdW50ZXJjbG9ja3dpc2UpIHtcbiAgICAgIHRvQW5nbGUgPSB0b0FuZ2xlICsgKGNvdW50ZXJjbG9ja3dpc2UgPyAtMzYwIDogMzYwKTtcbiAgICB9XG4gICAgY29uc3QgYW5nbGUgPSBtYXAoZnJvbUFuZ2xlLCB0b0FuZ2xlLCB2YWx1ZSkgKiBERUcyUkFEO1xuICAgIGNvbnN0IG1hZ25pdHVkZSA9IG1hcChmcm9tLm1hZ25pdHVkZSwgdG8ubWFnbml0dWRlLCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBfVmVjdG9yMjIoXG4gICAgICBtYWduaXR1ZGUgKiBNYXRoLmNvcyhhbmdsZSkgKyBvcmlnaW4ueCxcbiAgICAgIG1hZ25pdHVkZSAqIE1hdGguc2luKGFuZ2xlKSArIG9yaWdpbi55XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHtAbGluayBWZWN0b3IyLnBvbGFyTGVycH0gaW50ZXJwb2xhdGlvblxuICAgKiBmdW5jdGlvbiB3aXRoIGFkZGl0aW9uYWwgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIGNvdW50ZXJjbG9ja3dpc2UgLSBXaGV0aGVyIHRoZSBwb2ludCBzaG91bGQgZ2V0IHJvdGF0ZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyY2xvY2t3aXNlLlxuICAgKiBAcGFyYW0gY2VudGVyIC0gVGhlIGNlbnRlciBvZiByb3RhdGlvbi4gRGVmYXVsdHMgdG8gdGhlIG9yaWdpbi5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVQb2xhckxlcnAoY291bnRlcmNsb2Nrd2lzZSA9IGZhbHNlLCBjZW50ZXIgPSBfVmVjdG9yMjIuemVybykge1xuICAgIHJldHVybiAoZnJvbSwgdG8sIHZhbHVlKSA9PiBfVmVjdG9yMjIucG9sYXJMZXJwKGZyb20sIHRvLCB2YWx1ZSwgY291bnRlcmNsb2Nrd2lzZSwgbmV3IF9WZWN0b3IyMihjZW50ZXIpKTtcbiAgfVxuICBzdGF0aWMgZnJvbU9yaWdpbihvcmlnaW4pIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG5ldyBfVmVjdG9yMjIoKTtcbiAgICBpZiAob3JpZ2luID09PSAzKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuICAgIGlmIChvcmlnaW4gJiAxNikge1xuICAgICAgcG9zaXRpb24ueCA9IC0xO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luICYgMzIpIHtcbiAgICAgIHBvc2l0aW9uLnggPSAxO1xuICAgIH1cbiAgICBpZiAob3JpZ2luICYgNCkge1xuICAgICAgcG9zaXRpb24ueSA9IC0xO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luICYgOCkge1xuICAgICAgcG9zaXRpb24ueSA9IDE7XG4gICAgfVxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuICBzdGF0aWMgZnJvbVNjYWxhcih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1ZlY3RvcjIyKHZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgc3RhdGljIGZyb21SYWRpYW5zKHJhZGlhbnMpIHtcbiAgICByZXR1cm4gbmV3IF9WZWN0b3IyMihNYXRoLmNvcyhyYWRpYW5zKSwgTWF0aC5zaW4ocmFkaWFucykpO1xuICB9XG4gIHN0YXRpYyBmcm9tRGVncmVlcyhkZWdyZWVzKSB7XG4gICAgcmV0dXJuIF9WZWN0b3IyMi5mcm9tUmFkaWFucyhkZWdyZWVzICogREVHMlJBRCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYW5nbGUgaW4gcmFkaWFucyBiZXR3ZWVuIHRoZSB2ZWN0b3IgZGVzY3JpYmVkIGJ5IHggYW5kIHkgYW5kIHRoZVxuICAgKiBwb3NpdGl2ZSB4LWF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSB4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXG4gICAqL1xuICBzdGF0aWMgcmFkaWFucyh4LCB5KSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYW5nbGUgaW4gZGVncmVlcyBiZXR3ZWVuIHRoZSB2ZWN0b3IgZGVzY3JpYmVkIGJ5IHggYW5kIHkgYW5kIHRoZVxuICAgKiBwb3NpdGl2ZSB4LWF4aXMuXG4gICAqXG4gICAqIEBwYXJhbSB4IC0gVGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXG4gICAqIEBwYXJhbSB5IC0gVGhlIHkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSByZXR1cm5lZCBhbmdsZSB3aWxsIGJlIGJldHdlZW4gLTE4MCBhbmQgMTgwIGRlZ3JlZXMuXG4gICAqL1xuICBzdGF0aWMgZGVncmVlcyh4LCB5KSB7XG4gICAgcmV0dXJuIF9WZWN0b3IyMi5yYWRpYW5zKHgsIHkpICogUkFEMkRFRztcbiAgfVxuICBzdGF0aWMgbWFnbml0dWRlKHgsIHkpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICB9XG4gIHN0YXRpYyBzcXVhcmVkTWFnbml0dWRlKHgsIHkpIHtcbiAgICByZXR1cm4geCAqIHggKyB5ICogeTtcbiAgfVxuICBzdGF0aWMgYW5nbGVCZXR3ZWVuKHUsIHYpIHtcbiAgICByZXR1cm4gTWF0aC5hY29zKGNsYW1wKC0xLCAxLCB1LmRvdCh2KSAvICh1Lm1hZ25pdHVkZSAqIHYubWFnbml0dWRlKSkpICogKHUuY3Jvc3ModikgPj0gMCA/IDEgOiAtMSk7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLng7XG4gIH1cbiAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgdGhpcy54ID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy55O1xuICB9XG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgfVxuICBnZXQgbWFnbml0dWRlKCkge1xuICAgIHJldHVybiBfVmVjdG9yMjIubWFnbml0dWRlKHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBnZXQgc3F1YXJlZE1hZ25pdHVkZSgpIHtcbiAgICByZXR1cm4gX1ZlY3RvcjIyLnNxdWFyZWRNYWduaXR1ZGUodGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGdldCBub3JtYWxpemVkKCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlKDEgLyBfVmVjdG9yMjIubWFnbml0dWRlKHRoaXMueCwgdGhpcy55KSk7XG4gIH1cbiAgZ2V0IHNhZmUoKSB7XG4gICAgcmV0dXJuIG5ldyBfVmVjdG9yMjIoaXNOYU4odGhpcy54KSA/IDAgOiB0aGlzLngsIGlzTmFOKHRoaXMueSkgPyAwIDogdGhpcy55KTtcbiAgfVxuICBnZXQgZmxpcHBlZCgpIHtcbiAgICByZXR1cm4gbmV3IF9WZWN0b3IyMigtdGhpcy54LCAtdGhpcy55KTtcbiAgfVxuICBnZXQgZmxvb3JlZCgpIHtcbiAgICByZXR1cm4gbmV3IF9WZWN0b3IyMihNYXRoLmZsb29yKHRoaXMueCksIE1hdGguZmxvb3IodGhpcy55KSk7XG4gIH1cbiAgZ2V0IHBlcnBlbmRpY3VsYXIoKSB7XG4gICAgcmV0dXJuIG5ldyBfVmVjdG9yMjIodGhpcy55LCAtdGhpcy54KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdGhlIHZlY3RvciBhbmQgdGhlIHBvc2l0aXZlIHgtYXhpcy5cbiAgICovXG4gIGdldCByYWRpYW5zKCkge1xuICAgIHJldHVybiBfVmVjdG9yMjIucmFkaWFucyh0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYW5nbGUgaW4gZGVncmVlcyBiZXR3ZWVuIHRoZSB2ZWN0b3IgYW5kIHRoZSBwb3NpdGl2ZSB4LWF4aXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSByZXR1cm5lZCBhbmdsZSB3aWxsIGJlIGJldHdlZW4gLTE4MCBhbmQgMTgwIGRlZ3JlZXMuXG4gICAqL1xuICBnZXQgZGVncmVlcygpIHtcbiAgICByZXR1cm4gX1ZlY3RvcjIyLmRlZ3JlZXModGhpcy54LCB0aGlzLnkpO1xuICB9XG4gIGdldCBjdGcoKSB7XG4gICAgcmV0dXJuIHRoaXMueCAvIHRoaXMueTtcbiAgfVxuICBsZXJwKHRvLCB2YWx1ZSkge1xuICAgIHJldHVybiBfVmVjdG9yMjIubGVycCh0aGlzLCB0bywgdmFsdWUpO1xuICB9XG4gIGdldE9yaWdpbk9mZnNldChvcmlnaW4pIHtcbiAgICBjb25zdCBvZmZzZXQgPSBfVmVjdG9yMjIuZnJvbU9yaWdpbihvcmlnaW4pO1xuICAgIG9mZnNldC54ICo9IHRoaXMueCAvIDI7XG4gICAgb2Zmc2V0LnkgKj0gdGhpcy55IC8gMjtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIHNjYWxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVmVjdG9yMjIodGhpcy54ICogdmFsdWUsIHRoaXMueSAqIHZhbHVlKTtcbiAgfVxuICBtdWwocG9zc2libGVWZWN0b3IpIHtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgX1ZlY3RvcjIyKHBvc3NpYmxlVmVjdG9yKTtcbiAgICByZXR1cm4gbmV3IF9WZWN0b3IyMih0aGlzLnggKiB2ZWN0b3IueCwgdGhpcy55ICogdmVjdG9yLnkpO1xuICB9XG4gIGRpdihwb3NzaWJsZVZlY3Rvcikge1xuICAgIGNvbnN0IHZlY3RvciA9IG5ldyBfVmVjdG9yMjIocG9zc2libGVWZWN0b3IpO1xuICAgIHJldHVybiBuZXcgX1ZlY3RvcjIyKHRoaXMueCAvIHZlY3Rvci54LCB0aGlzLnkgLyB2ZWN0b3IueSk7XG4gIH1cbiAgYWRkKHBvc3NpYmxlVmVjdG9yKSB7XG4gICAgY29uc3QgdmVjdG9yID0gbmV3IF9WZWN0b3IyMihwb3NzaWJsZVZlY3Rvcik7XG4gICAgcmV0dXJuIG5ldyBfVmVjdG9yMjIodGhpcy54ICsgdmVjdG9yLngsIHRoaXMueSArIHZlY3Rvci55KTtcbiAgfVxuICBzdWIocG9zc2libGVWZWN0b3IpIHtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgX1ZlY3RvcjIyKHBvc3NpYmxlVmVjdG9yKTtcbiAgICByZXR1cm4gbmV3IF9WZWN0b3IyMih0aGlzLnggLSB2ZWN0b3IueCwgdGhpcy55IC0gdmVjdG9yLnkpO1xuICB9XG4gIGRvdChwb3NzaWJsZVZlY3Rvcikge1xuICAgIGNvbnN0IHZlY3RvciA9IG5ldyBfVmVjdG9yMjIocG9zc2libGVWZWN0b3IpO1xuICAgIHJldHVybiB0aGlzLnggKiB2ZWN0b3IueCArIHRoaXMueSAqIHZlY3Rvci55O1xuICB9XG4gIGNyb3NzKHBvc3NpYmxlVmVjdG9yKSB7XG4gICAgY29uc3QgdmVjdG9yID0gbmV3IF9WZWN0b3IyMihwb3NzaWJsZVZlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMueCAqIHZlY3Rvci55IC0gdGhpcy55ICogdmVjdG9yLng7XG4gIH1cbiAgbW9kKHBvc3NpYmxlVmVjdG9yKSB7XG4gICAgY29uc3QgdmVjdG9yID0gbmV3IF9WZWN0b3IyMihwb3NzaWJsZVZlY3Rvcik7XG4gICAgcmV0dXJuIG5ldyBfVmVjdG9yMjIodGhpcy54ICUgdmVjdG9yLngsIHRoaXMueSAlIHZlY3Rvci55KTtcbiAgfVxuICBhZGRYKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBfVmVjdG9yMjIodGhpcy54ICsgdmFsdWUsIHRoaXMueSk7XG4gIH1cbiAgYWRkWSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgX1ZlY3RvcjIyKHRoaXMueCwgdGhpcy55ICsgdmFsdWUpO1xuICB9XG4gIHRvU3ltYm9sKCkge1xuICAgIHJldHVybiBfVmVjdG9yMjIuc3ltYm9sO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgVmVjdG9yMigke3RoaXMueH0sICR7dGhpcy55fSlgO1xuICB9XG4gIHRvVW5pZm9ybShnbCwgbG9jYXRpb24pIHtcbiAgICBnbC51bmlmb3JtMmYobG9jYXRpb24sIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHsgeDogdGhpcy54LCB5OiB0aGlzLnkgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdHdvIHZlY3RvcnMgYXJlIGV4YWN0bHkgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogSWYgeW91IG5lZWQgdG8gY29tcGVuc2F0ZSBmb3IgZmxvYXRpbmcgcG9pbnQgaW5hY2N1cmFjaWVzLCB1c2UgdGhlXG4gICAqIHtAbGluayBlcXVhbHN9IG1ldGhvZCwgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIG90aGVyIC0gVGhlIHZlY3RvciB0byBjb21wYXJlLlxuICAgKi9cbiAgZXhhY3RseUVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0d28gdmVjdG9ycyBhcmUgZXF1YWwgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2QgYWxsb3dzIHBhc3NpbmcgYW4gYWxsb3dlZCBlcnJvciBtYXJnaW4gd2hlbiBjb21wYXJpbmcgdmVjdG9yc1xuICAgKiB0byBjb21wZW5zYXRlIGZvciBmbG9hdGluZyBwb2ludCBpbmFjY3VyYWNpZXMuIFRvIGNoZWNrIGlmIHR3byB2ZWN0b3JzIGFyZVxuICAgKiBleGFjdGx5IGVxdWFsLCB1c2UgdGhlIHtAbGluayBleGFjdGx5RXF1YWxzfSBtZXRob2QsIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSB2ZWN0b3IgdG8gY29tcGFyZS5cbiAgICogQHBhcmFtIHRocmVzaG9sZCAtIFRoZSBhbGxvd2VkIGVycm9yIHRocmVzaG9sZCB3aGVuIGNvbXBhcmluZyB0aGUgdmVjdG9ycy5cbiAgICovXG4gIGVxdWFscyhvdGhlciwgdGhyZXNob2xkID0gRVBTSUxPTikge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8PSB0aHJlc2hvbGQgKyBOdW1iZXIuRVBTSUxPTiAmJiBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8PSB0aHJlc2hvbGQgKyBOdW1iZXIuRVBTSUxPTjtcbiAgfVxufTtcbl9WZWN0b3IyLnN5bWJvbCA9IC8qIEBfX1BVUkVfXyAqLyBTeW1ib2wuZm9yKFwiQHR3aWNrL2NvcmUvdHlwZXMvVmVjdG9yMlwiKTtcbl9WZWN0b3IyLnplcm8gPSBuZXcgX1ZlY3RvcjIoKTtcbl9WZWN0b3IyLm9uZSA9IG5ldyBfVmVjdG9yMigxLCAxKTtcbl9WZWN0b3IyLnJpZ2h0ID0gbmV3IF9WZWN0b3IyKDEsIDApO1xuX1ZlY3RvcjIubGVmdCA9IG5ldyBfVmVjdG9yMigtMSwgMCk7XG5fVmVjdG9yMi51cCA9IG5ldyBfVmVjdG9yMigwLCAxKTtcbl9WZWN0b3IyLmRvd24gPSBuZXcgX1ZlY3RvcjIoMCwgLTEpO1xuX1ZlY3RvcjIudG9wID0gbmV3IF9WZWN0b3IyKDAsIC0xKTtcbl9WZWN0b3IyLmJvdHRvbSA9IG5ldyBfVmVjdG9yMigwLCAxKTtcbl9WZWN0b3IyLnRvcExlZnQgPSBuZXcgX1ZlY3RvcjIoLTEsIC0xKTtcbl9WZWN0b3IyLnRvcFJpZ2h0ID0gbmV3IF9WZWN0b3IyKDEsIC0xKTtcbl9WZWN0b3IyLmJvdHRvbUxlZnQgPSBuZXcgX1ZlY3RvcjIoLTEsIDEpO1xuX1ZlY3RvcjIuYm90dG9tUmlnaHQgPSBuZXcgX1ZlY3RvcjIoMSwgMSk7XG52YXIgVmVjdG9yMiA9IF9WZWN0b3IyO1xudmFyIF9NYXRyaXgyRCA9IGNsYXNzIF9NYXRyaXgyRDIge1xuICBjb25zdHJ1Y3RvcihhLCBiLCBjMiwgZCwgdHgsIHR5KSB7XG4gICAgdGhpcy52YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDEsIDAsIDBdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDYpIHtcbiAgICAgIHRoaXMudmFsdWVzWzBdID0gYTtcbiAgICAgIHRoaXMudmFsdWVzWzFdID0gYjtcbiAgICAgIHRoaXMudmFsdWVzWzJdID0gYzI7XG4gICAgICB0aGlzLnZhbHVlc1szXSA9IGQ7XG4gICAgICB0aGlzLnZhbHVlc1s0XSA9IHR4O1xuICAgICAgdGhpcy52YWx1ZXNbNV0gPSB0eTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBET01NYXRyaXgpIHtcbiAgICAgIHRoaXMudmFsdWVzWzBdID0gYS5tMTE7XG4gICAgICB0aGlzLnZhbHVlc1sxXSA9IGEubTEyO1xuICAgICAgdGhpcy52YWx1ZXNbMl0gPSBhLm0yMTtcbiAgICAgIHRoaXMudmFsdWVzWzNdID0gYS5tMjI7XG4gICAgICB0aGlzLnZhbHVlc1s0XSA9IGEubTQxO1xuICAgICAgdGhpcy52YWx1ZXNbNV0gPSBhLm00MjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfTWF0cml4MkQyKSB7XG4gICAgICB0aGlzLnZhbHVlcyA9IGEudmFsdWVzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgaWYgKGEubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMudmFsdWVzWzBdID0gYVswXTtcbiAgICAgICAgdGhpcy52YWx1ZXNbMV0gPSBhWzFdO1xuICAgICAgICB0aGlzLnZhbHVlc1syXSA9IGJbMF07XG4gICAgICAgIHRoaXMudmFsdWVzWzNdID0gYlsxXTtcbiAgICAgICAgdGhpcy52YWx1ZXNbNF0gPSBjMlswXTtcbiAgICAgICAgdGhpcy52YWx1ZXNbNV0gPSBjMlsxXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbnN0IHgyID0gbmV3IFZlY3RvcjIoYVswXSk7XG4gICAgICAgIGNvbnN0IHkyID0gbmV3IFZlY3RvcjIoYVsxXSk7XG4gICAgICAgIGNvbnN0IHoyID0gbmV3IFZlY3RvcjIoYVsyXSk7XG4gICAgICAgIHRoaXMudmFsdWVzWzBdID0geDIueDtcbiAgICAgICAgdGhpcy52YWx1ZXNbMV0gPSB4Mi55O1xuICAgICAgICB0aGlzLnZhbHVlc1syXSA9IHkyLng7XG4gICAgICAgIHRoaXMudmFsdWVzWzNdID0geTIueTtcbiAgICAgICAgdGhpcy52YWx1ZXNbNF0gPSB6Mi54O1xuICAgICAgICB0aGlzLnZhbHVlc1s1XSA9IHoyLnk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWVzWzBdID0gYVswXTtcbiAgICAgIHRoaXMudmFsdWVzWzFdID0gYVsxXTtcbiAgICAgIHRoaXMudmFsdWVzWzJdID0gYVsyXTtcbiAgICAgIHRoaXMudmFsdWVzWzNdID0gYVszXTtcbiAgICAgIHRoaXMudmFsdWVzWzRdID0gYVs0XTtcbiAgICAgIHRoaXMudmFsdWVzWzVdID0gYVs1XTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeCA9IG5ldyBWZWN0b3IyKGEpO1xuICAgIGNvbnN0IHkgPSBuZXcgVmVjdG9yMihiKTtcbiAgICBjb25zdCB6ID0gbmV3IFZlY3RvcjIoYzIpO1xuICAgIHRoaXMudmFsdWVzWzBdID0geC54O1xuICAgIHRoaXMudmFsdWVzWzFdID0geC55O1xuICAgIHRoaXMudmFsdWVzWzJdID0geS54O1xuICAgIHRoaXMudmFsdWVzWzNdID0geS55O1xuICAgIHRoaXMudmFsdWVzWzRdID0gei54O1xuICAgIHRoaXMudmFsdWVzWzVdID0gei55O1xuICB9XG4gIHN0YXRpYyBmcm9tUm90YXRpb24oYW5nbGUpIHtcbiAgICByZXR1cm4gX01hdHJpeDJEMi5pZGVudGl0eS5yb3RhdGUoYW5nbGUpO1xuICB9XG4gIHN0YXRpYyBmcm9tVHJhbnNsYXRpb24odHJhbnNsYXRpb24pIHtcbiAgICByZXR1cm4gX01hdHJpeDJEMi5pZGVudGl0eS50cmFuc2xhdGUobmV3IFZlY3RvcjIodHJhbnNsYXRpb24pKTtcbiAgfVxuICBzdGF0aWMgZnJvbVNjYWxpbmcoc2NhbGUpIHtcbiAgICByZXR1cm4gX01hdHJpeDJEMi5pZGVudGl0eS5zY2FsZShuZXcgVmVjdG9yMihzY2FsZSkpO1xuICB9XG4gIGdldCB4KCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnZhbHVlc1swXSwgdGhpcy52YWx1ZXNbMV0pO1xuICB9XG4gIGdldCB5KCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnZhbHVlc1syXSwgdGhpcy52YWx1ZXNbM10pO1xuICB9XG4gIGdldCBzY2FsZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzWzBdO1xuICB9XG4gIHNldCBzY2FsZVgodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlc1swXSA9IHRoaXMueC5ub3JtYWxpemVkLnNjYWxlKHZhbHVlKS54O1xuICB9XG4gIGdldCBza2V3WCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbMV07XG4gIH1cbiAgc2V0IHNrZXdYKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZXNbMV0gPSB2YWx1ZTtcbiAgfVxuICBnZXQgc2NhbGVZKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1szXTtcbiAgfVxuICBzZXQgc2NhbGVZKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZXNbM10gPSB0aGlzLnkubm9ybWFsaXplZC5zY2FsZSh2YWx1ZSkueTtcbiAgfVxuICBnZXQgc2tld1koKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzWzJdO1xuICB9XG4gIHNldCBza2V3WSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWVzWzJdID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHRyYW5zbGF0ZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzWzRdO1xuICB9XG4gIHNldCB0cmFuc2xhdGVYKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZXNbNF0gPSB2YWx1ZTtcbiAgfVxuICBnZXQgdHJhbnNsYXRlWSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbNV07XG4gIH1cbiAgc2V0IHRyYW5zbGF0ZVkodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlc1s1XSA9IHZhbHVlO1xuICB9XG4gIGdldCByb3RhdGlvbigpIHtcbiAgICByZXR1cm4gVmVjdG9yMi5kZWdyZWVzKHRoaXMudmFsdWVzWzBdLCB0aGlzLnZhbHVlc1sxXSk7XG4gIH1cbiAgc2V0IHJvdGF0aW9uKGFuZ2xlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yb3RhdGUoYW5nbGUgLSB0aGlzLnJvdGF0aW9uKTtcbiAgICB0aGlzLnZhbHVlc1swXSA9IHJlc3VsdC52YWx1ZXNbMF07XG4gICAgdGhpcy52YWx1ZXNbMV0gPSByZXN1bHQudmFsdWVzWzFdO1xuICAgIHRoaXMudmFsdWVzWzJdID0gcmVzdWx0LnZhbHVlc1syXTtcbiAgICB0aGlzLnZhbHVlc1szXSA9IHJlc3VsdC52YWx1ZXNbM107XG4gIH1cbiAgZ2V0IHRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnZhbHVlc1s0XSwgdGhpcy52YWx1ZXNbNV0pO1xuICB9XG4gIHNldCB0cmFuc2xhdGlvbih0cmFuc2xhdGlvbikge1xuICAgIGNvbnN0IHZlYyA9IG5ldyBWZWN0b3IyKHRyYW5zbGF0aW9uKTtcbiAgICB0aGlzLnZhbHVlc1s0XSA9IHZlYy54O1xuICAgIHRoaXMudmFsdWVzWzVdID0gdmVjLnk7XG4gIH1cbiAgZ2V0IHNjYWxpbmcoKSB7XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMudmFsdWVzWzBdLCB0aGlzLnZhbHVlc1szXSk7XG4gIH1cbiAgc2V0IHNjYWxpbmcodmFsdWUpIHtcbiAgICBjb25zdCBzY2FsZSA9IG5ldyBWZWN0b3IyKHZhbHVlKTtcbiAgICBjb25zdCB4ID0gbmV3IFZlY3RvcjIodGhpcy52YWx1ZXNbMF0sIHRoaXMudmFsdWVzWzFdKS5ub3JtYWxpemVkO1xuICAgIGNvbnN0IHkgPSBuZXcgVmVjdG9yMih0aGlzLnZhbHVlc1syXSwgdGhpcy52YWx1ZXNbM10pLm5vcm1hbGl6ZWQ7XG4gICAgdGhpcy52YWx1ZXNbMF0gPSB4LnggKiBzY2FsZS54O1xuICAgIHRoaXMudmFsdWVzWzFdID0geC55ICogc2NhbGUueTtcbiAgICB0aGlzLnZhbHVlc1syXSA9IHkueCAqIHNjYWxlLng7XG4gICAgdGhpcy52YWx1ZXNbM10gPSB5LnkgKiBzY2FsZS55O1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGludmVyc2Ugb2YgdGhlIG1hdHJpeC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogSWYgdGhlIG1hdHJpeCBpcyBub3QgaW52ZXJ0aWJsZSwgaS5lLiBpdHMgZGV0ZXJtaW5hbnQgaXMgYDBgLCB0aGlzIHdpbGxcbiAgICogcmV0dXJuIGBudWxsYCwgaW5zdGVhZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDJEKFxuICAgKiAgIFsxLCAyXSxcbiAgICogICBbMywgNF0sXG4gICAqICAgWzUsIDZdLFxuICAgKiApO1xuICAgKlxuICAgKiBjb25zdCBpbnZlcnNlID0gbWF0cml4LmludmVyc2U7XG4gICAqIC8vID0+IE1hdHJpeDJEKFxuICAgKiAvLyAgICAgIFstMiwgMV0sXG4gICAqIC8vICAgICAgWzEuNSwgLTAuNV0sXG4gICAqIC8vICAgICAgWzEsIC0yXSxcbiAgICogLy8gICApXG4gICAqIGBgYFxuICAgKi9cbiAgZ2V0IGludmVyc2UoKSB7XG4gICAgY29uc3QgYWEgPSB0aGlzLnZhbHVlc1swXSwgYWIgPSB0aGlzLnZhbHVlc1sxXSwgYWMgPSB0aGlzLnZhbHVlc1syXSwgYWQgPSB0aGlzLnZhbHVlc1szXTtcbiAgICBjb25zdCBhdHggPSB0aGlzLnZhbHVlc1s0XSwgYXR5ID0gdGhpcy52YWx1ZXNbNV07XG4gICAgbGV0IGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmICghZGV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMSAvIGRldDtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgyRDIoXG4gICAgICBhZCAqIGRldCxcbiAgICAgIC1hYiAqIGRldCxcbiAgICAgIC1hYyAqIGRldCxcbiAgICAgIGFhICogZGV0LFxuICAgICAgKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0LFxuICAgICAgKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBkZXRlcm1pbmFudCBvZiB0aGUgbWF0cml4LlxuICAgKi9cbiAgZ2V0IGRldGVybWluYW50KCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1swXSAqIHRoaXMudmFsdWVzWzNdIC0gdGhpcy52YWx1ZXNbMV0gKiB0aGlzLnZhbHVlc1syXTtcbiAgfVxuICBnZXQgZG9tTWF0cml4KCkge1xuICAgIHJldHVybiBuZXcgRE9NTWF0cml4KFtcbiAgICAgIHRoaXMudmFsdWVzWzBdLFxuICAgICAgdGhpcy52YWx1ZXNbMV0sXG4gICAgICB0aGlzLnZhbHVlc1syXSxcbiAgICAgIHRoaXMudmFsdWVzWzNdLFxuICAgICAgdGhpcy52YWx1ZXNbNF0sXG4gICAgICB0aGlzLnZhbHVlc1s1XVxuICAgIF0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIG50aCBjb21wb25lbnQgdmVjdG9yIG9mIHRoZSBtYXRyaXguIE9ubHkgZGVmaW5lZCBmb3IgMCwgMSwgYW5kIDIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgyRChcbiAgICogICBbMSwgMF0sXG4gICAqICAgWzAsIDBdLFxuICAgKiAgIFsxLCAwXSxcbiAgICogKTtcbiAgICpcbiAgICogY29uc3QgeCA9IG1hdHJpeC5jb2x1bW4oMCk7XG4gICAqIC8vIFZlY3RvcjIoMSwgMClcbiAgICpcbiAgICogY29uc3QgeSA9IG1hdHJpeC5jb2x1bW4oMSk7XG4gICAqIC8vIFZlY3RvcjIoMCwgMClcbiAgICpcbiAgICogY29uc3QgeiA9IG1hdHJpeC5jb2x1bW4oMSk7XG4gICAqIC8vIFZlY3RvcjIoMSwgMClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgY29tcG9uZW50IHZlY3RvciB0byByZXRyaWV2ZS5cbiAgICovXG4gIGNvbHVtbihpbmRleCkge1xuICAgIHJldHVybiBuZXcgVmVjdG9yMih0aGlzLnZhbHVlc1tpbmRleCAqIDJdLCB0aGlzLnZhbHVlc1tpbmRleCAqIDIgKyAxXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG50aCByb3cgb2YgdGhlIG1hdHJpeC4gT25seSBkZWZpbmVkIGZvciAwIGFuZCAxLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4MkQoXG4gICAqICAgWzEsIDBdLFxuICAgKiAgIFswLCAwXSxcbiAgICogICBbMSwgMF0sXG4gICAqICk7XG4gICAqXG4gICAqIGNvbnN0IGZpcnN0Um93ID0gbWF0cml4LmNvbHVtbigwKTtcbiAgICogLy8gWzEsIDAsIDFdXG4gICAqXG4gICAqIGNvbnN0IHNlY29uZFJvdyA9IG1hdHJpeC5jb2x1bW4oMSk7XG4gICAqIC8vIFswLCAwLCAwXVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSByb3cgdG8gcmV0cmlldmUuXG4gICAqL1xuICByb3coaW5kZXgpIHtcbiAgICByZXR1cm4gW3RoaXMudmFsdWVzW2luZGV4XSwgdGhpcy52YWx1ZXNbaW5kZXggKyAyXSwgdGhpcy52YWx1ZXNbaW5kZXggKyA0XV07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1hdHJpeCBwcm9kdWN0IG9mIHRoaXMgbWF0cml4IHdpdGggdGhlIHByb3ZpZGVkIG1hdHJpeC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqIGNvbXB1dGF0aW9uLiBJdCB3aWxsIG5vdCBtb2RpZnkgdGhlIHNvdXJjZSBtYXRyaXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGEgPSBuZXcgTWF0cml4MkQoXG4gICAqICAgWzEsIDJdLFxuICAgKiAgIFswLCAxXSxcbiAgICogICBbMSwgMV0sXG4gICAqICk7XG4gICAqIGNvbnN0IGIgPSBuZXcgTWF0cml4MkQoXG4gICAqICAgWzIsIDFdLFxuICAgKiAgIFsxLCAxXSxcbiAgICogICBbMSwgMV0sXG4gICAqICk7XG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdCA9IGEubXVsKGIpO1xuICAgKiAvLyA9PiBNYXRyaXgyRChcbiAgICogLy8gICAgIFsyLCA1XSxcbiAgICogLy8gICAgIFsxLCAzXSxcbiAgICogLy8gICAgIFsyLCA0XSxcbiAgICogLy8gICApXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgbWF0cml4IHRvIG11bHRpcGx5IHdpdGhcbiAgICovXG4gIG11bChvdGhlcikge1xuICAgIGNvbnN0IGEwID0gdGhpcy52YWx1ZXNbMF0sIGExID0gdGhpcy52YWx1ZXNbMV0sIGEyID0gdGhpcy52YWx1ZXNbMl0sIGEzID0gdGhpcy52YWx1ZXNbM10sIGE0ID0gdGhpcy52YWx1ZXNbNF0sIGE1ID0gdGhpcy52YWx1ZXNbNV07XG4gICAgY29uc3QgYjAgPSBvdGhlci52YWx1ZXNbMF0sIGIxID0gb3RoZXIudmFsdWVzWzFdLCBiMiA9IG90aGVyLnZhbHVlc1syXSwgYjMgPSBvdGhlci52YWx1ZXNbM10sIGI0ID0gb3RoZXIudmFsdWVzWzRdLCBiNSA9IG90aGVyLnZhbHVlc1s1XTtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgyRDIoXG4gICAgICBhMCAqIGIwICsgYTIgKiBiMSxcbiAgICAgIGExICogYjAgKyBhMyAqIGIxLFxuICAgICAgYTAgKiBiMiArIGEyICogYjMsXG4gICAgICBhMSAqIGIyICsgYTMgKiBiMyxcbiAgICAgIGEwICogYjQgKyBhMiAqIGI1ICsgYTQsXG4gICAgICBhMSAqIGI0ICsgYTMgKiBiNSArIGE1XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogUm90YXRlIHRoZSBtYXRyaXggYnkgdGhlIHByb3ZpZGVkIGFuZ2xlLiBCeSBkZWZhdWx0LCB0aGUgYW5nbGUgaXNcbiAgICogcHJvdmlkZWQgaW4gZGVncmVlcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBtYXRyaXggcmVwcmVzZW50aW5nIHRoZSByZXN1bHQgb2YgdGhlXG4gICAqIGNvbXB1dGF0aW9uLiBJdCB3aWxsIG5vdCBtb2RpZnkgdGhlIHNvdXJjZSBtYXRyaXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNvbnN0IGEgPSBuZXcgTWF0cml4MkQoXG4gICAqICAgWzEsIDJdLFxuICAgKiAgIFszLCA0XSxcbiAgICogICBbNSwgNl0sXG4gICAqICk7XG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdCA9IGEucm90YXRlKDkwKTtcbiAgICogLy8gPT4gTWF0cml4MkQoXG4gICAqIC8vICAgICBbMywgNF0sXG4gICAqIC8vICAgICBbLTEsIC0yXSxcbiAgICogLy8gICAgIFs1LCA2XSxcbiAgICogLy8gICApXG4gICAqXG4gICAqIC8vIFByb3ZpZGUgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAgICogY29uc3QgcmVzdWx0ID0gYS5yb3RhdGUoTWF0aC5QSSAqIDAuNSwgdHJ1ZSk7XG4gICAqIC8vID0+IE1hdHJpeDJEKFxuICAgKiAvLyAgICAgWzMsIDRdLFxuICAgKiAvLyAgICAgWy0xLCAtMl0sXG4gICAqIC8vICAgICBbNSwgNl0sXG4gICAqIC8vICAgKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIGJ5IHdoaWNoIHRvIHJvdGF0ZSB0aGUgbWF0cml4LlxuICAgKiBAcGFyYW0gZGVncmVlcyAtIFdoZXRoZXIgdGhlIGFuZ2xlIGlzIHByb3ZpZGVkIGluIGRlZ3JlZXMuXG4gICAqL1xuICByb3RhdGUoYW5nbGUsIGRlZ3JlZXMgPSB0cnVlKSB7XG4gICAgaWYgKGRlZ3JlZXMpIHtcbiAgICAgIGFuZ2xlICo9IERFRzJSQUQ7XG4gICAgfVxuICAgIGNvbnN0IGEwID0gdGhpcy52YWx1ZXNbMF0sIGExID0gdGhpcy52YWx1ZXNbMV0sIGEyID0gdGhpcy52YWx1ZXNbMl0sIGEzID0gdGhpcy52YWx1ZXNbM10sIGE0ID0gdGhpcy52YWx1ZXNbNF0sIGE1ID0gdGhpcy52YWx1ZXNbNV07XG4gICAgY29uc3QgcyA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCBjMiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgyRDIoXG4gICAgICBhMCAqIGMyICsgYTIgKiBzLFxuICAgICAgYTEgKiBjMiArIGEzICogcyxcbiAgICAgIGEwICogLXMgKyBhMiAqIGMyLFxuICAgICAgYTEgKiAtcyArIGEzICogYzIsXG4gICAgICBhNCxcbiAgICAgIGE1XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2NhbGUgdGhlIHggYW5kIHkgY29tcG9uZW50IHZlY3RvcnMgb2YgdGhlIG1hdHJpeC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogSWYgYHZlY2AgaXMgcHJvdmlkZWQgYXMgYSB2ZWN0b3IsIHRoZSB4IGFuZCB5IGNvbXBvbmVudCB2ZWN0b3JzIG9mIHRoZVxuICAgKiBtYXRyaXggd2lsbCBiZSBzY2FsZWQgYnkgdGhlIHggYW5kIHkgcGFydHMgb2YgdGhlIHZlY3RvciwgcmVzcGVjdGl2ZWx5LlxuICAgKlxuICAgKiBJZiBgdmVjYCBpcyBwcm92aWRlZCBhcyBhIHNjYWxhciwgdGhlIHggYW5kIHkgY29tcG9uZW50IHZlY3RvcnMgd2lsbCBiZVxuICAgKiBzY2FsZWQgdW5pZm9ybWx5IGJ5IHRoaXMgZmFjdG9yLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IG1hdHJpeCByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICogY29tcHV0YXRpb24uIEl0IHdpbGwgbm90IG1vZGlmeSB0aGUgc291cmNlIG1hdHJpeC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDJEKFxuICAgKiAgIFsxLCAyXSxcbiAgICogICBbMywgNF0sXG4gICAqICAgWzUsIDZdLFxuICAgKiApO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHQxID0gbWF0cml4LnNjYWxlKFsyLCAzXSk7XG4gICAqIC8vID0+IG5ldyBNYXRyaXgyRChcbiAgICogLy8gICAgICBbMiwgNF0sXG4gICAqIC8vICAgICAgWzksIDEyXSxcbiAgICogLy8gICAgICBbNSwgNl0sXG4gICAqIC8vICAgIClcbiAgICpcbiAgICogY29uc3QgcmVzdWx0MiA9IG1hdHJpeC5zY2FsZSgyKTtcbiAgICogLy8gPT4gbmV3IE1hdHJpeDJEKFxuICAgKiAvLyAgICAgIFsyLCA0XSxcbiAgICogLy8gICAgICBbNiwgOF0sXG4gICAqIC8vICAgICAgWzUsIDZdLFxuICAgKiAvLyAgICApXG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gdmVjIC0gVGhlIGZhY3RvciBieSB3aGljaCB0byBzY2FsZSB0aGUgbWF0cml4XG4gICAqL1xuICBzY2FsZSh2ZWMpIHtcbiAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjIodmVjKTtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgyRDIoXG4gICAgICB0aGlzLnZhbHVlc1swXSAqIHYueCxcbiAgICAgIHRoaXMudmFsdWVzWzFdICogdi54LFxuICAgICAgdGhpcy52YWx1ZXNbMl0gKiB2LnksXG4gICAgICB0aGlzLnZhbHVlc1szXSAqIHYueSxcbiAgICAgIHRoaXMudmFsdWVzWzRdLFxuICAgICAgdGhpcy52YWx1ZXNbNV1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBNdWx0aXBseSBlYWNoIHZhbHVlIG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXG4gICAqXG4gICAqICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDJEKFxuICAgKiAgIFsxLCAyXSxcbiAgICogICBbMywgNF0sXG4gICAqICAgWzUsIDZdLFxuICAgKiApO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHQxID0gbWF0cml4Lm11bFNjYWxhcigyKTtcbiAgICogLy8gPT4gbmV3IE1hdHJpeDJEKFxuICAgKiAvLyAgICAgIFsyLCA0XSxcbiAgICogLy8gICAgICBbNiwgOF0sXG4gICAqIC8vICAgICAgWzEwLCAxMl0sXG4gICAqIC8vICAgIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBzIC0gVGhlIHZhbHVlIGJ5IHdoaWNoIHRvIHNjYWxlIGVhY2ggdGVybVxuICAgKi9cbiAgbXVsU2NhbGFyKHMpIHtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgyRDIoXG4gICAgICB0aGlzLnZhbHVlc1swXSAqIHMsXG4gICAgICB0aGlzLnZhbHVlc1sxXSAqIHMsXG4gICAgICB0aGlzLnZhbHVlc1syXSAqIHMsXG4gICAgICB0aGlzLnZhbHVlc1szXSAqIHMsXG4gICAgICB0aGlzLnZhbHVlc1s0XSAqIHMsXG4gICAgICB0aGlzLnZhbHVlc1s1XSAqIHNcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgdGhlIG1hdHJpeCBieSB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcHJvdmlkZWQgdmVjdG9yLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiBgdmVjYCBpcyBwcm92aWRlZCBhcyBhIHNjYWxhciwgbWF0cml4IHdpbGwgYmUgdHJhbnNsYXRlZCB1bmlmb3JtbHlcbiAgICogYnkgdGhpcyBmYWN0b3IuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgbWF0cml4IHJlcHJlc2VudGluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICAgKiBjb21wdXRhdGlvbi4gSXQgd2lsbCBub3QgbW9kaWZ5IHRoZSBzb3VyY2UgbWF0cml4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBtYXRyaXggPSBuZXcgTWF0cml4MkQoXG4gICAqICAgWzEsIDJdLFxuICAgKiAgIFszLCA0XSxcbiAgICogICBbNSwgNl0sXG4gICAqICk7XG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdDEgPSBtYXRyaXgudHJhbnNsYXRlKFsyLCAzXSk7XG4gICAqIC8vID0+IG5ldyBNYXRyaXgyRChcbiAgICogLy8gICAgICBbMSwgMl0sXG4gICAqIC8vICAgICAgWzMsIDRdLFxuICAgKiAvLyAgICAgIFsxNiwgMjJdLFxuICAgKiAvLyAgICApXG4gICAqXG4gICAqIGNvbnN0IHJlc3VsdDIgPSBtYXRyaXgudHJhbnNsYXRlKDIpO1xuICAgKiAvLyA9PiBuZXcgTWF0cml4MkQoXG4gICAqIC8vICAgICAgWzEsIDJdLFxuICAgKiAvLyAgICAgIFszLCA0XSxcbiAgICogLy8gICAgICBbMTMsIDE4XSxcbiAgICogLy8gICAgKVxuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHZlYyAtIFRoZSB2ZWN0b3IgYnkgd2hpY2ggdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXhcbiAgICovXG4gIHRyYW5zbGF0ZSh2ZWMpIHtcbiAgICBjb25zdCB2ID0gbmV3IFZlY3RvcjIodmVjKTtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgyRDIoXG4gICAgICB0aGlzLnZhbHVlc1swXSxcbiAgICAgIHRoaXMudmFsdWVzWzFdLFxuICAgICAgdGhpcy52YWx1ZXNbMl0sXG4gICAgICB0aGlzLnZhbHVlc1szXSxcbiAgICAgIHRoaXMudmFsdWVzWzBdICogdi54ICsgdGhpcy52YWx1ZXNbMl0gKiB2LnkgKyB0aGlzLnZhbHVlc1s0XSxcbiAgICAgIHRoaXMudmFsdWVzWzFdICogdi54ICsgdGhpcy52YWx1ZXNbM10gKiB2LnkgKyB0aGlzLnZhbHVlc1s1XVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCB0aGUgcHJvdmlkZWQgbWF0cml4IHRvIHRoaXMgbWF0cml4LlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IG1hdHJpeCByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICogY29tcHV0YXRpb24uIEl0IHdpbGwgbm90IG1vZGlmeSB0aGUgc291cmNlIG1hdHJpeC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY29uc3QgYSA9IG5ldyBNYXRyaXgyRChcbiAgICogICBbMSwgMl0sXG4gICAqICAgWzMsIDRdLFxuICAgKiAgIFs1LCA2XSxcbiAgICogKTtcbiAgICogY29uc3QgYSA9IG5ldyBNYXRyaXgyRChcbiAgICogICBbNywgOF0sXG4gICAqICAgWzksIDEwXSxcbiAgICogICBbMTEsIDEyXSxcbiAgICogKTtcbiAgICpcbiAgICogY29uc3QgcmVzdWx0ID0gYS5hZGQoYik7XG4gICAqIC8vID0+IE1hdHJpeDJEKFxuICAgKiAvLyAgICAgIFs4LCAxMF0sXG4gICAqIC8vICAgICAgWzEyLCAxNF0sXG4gICAqIC8vICAgICAgWzE2LCAxOF0sXG4gICAqIC8vICAgIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBtYXRyaXggdG8gYWRkXG4gICAqL1xuICBhZGQob3RoZXIpIHtcbiAgICByZXR1cm4gbmV3IF9NYXRyaXgyRDIoXG4gICAgICB0aGlzLnZhbHVlc1swXSArIG90aGVyLnZhbHVlc1swXSxcbiAgICAgIHRoaXMudmFsdWVzWzFdICsgb3RoZXIudmFsdWVzWzFdLFxuICAgICAgdGhpcy52YWx1ZXNbMl0gKyBvdGhlci52YWx1ZXNbMl0sXG4gICAgICB0aGlzLnZhbHVlc1szXSArIG90aGVyLnZhbHVlc1szXSxcbiAgICAgIHRoaXMudmFsdWVzWzRdICsgb3RoZXIudmFsdWVzWzRdLFxuICAgICAgdGhpcy52YWx1ZXNbNV0gKyBvdGhlci52YWx1ZXNbNV1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTdWJ0cmFjdCB0aGUgcHJvdmlkZWQgbWF0cml4IGZyb20gdGhpcyBtYXRyaXguXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgbWF0cml4IHJlcHJlc2VudGluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICAgKiBjb21wdXRhdGlvbi4gSXQgd2lsbCBub3QgbW9kaWZ5IHRoZSBzb3VyY2UgbWF0cml4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBhID0gbmV3IE1hdHJpeDJEKFxuICAgKiAgIFsxLCAyXSxcbiAgICogICBbMywgNF0sXG4gICAqICAgWzUsIDZdLFxuICAgKiApO1xuICAgKiBjb25zdCBhID0gbmV3IE1hdHJpeDJEKFxuICAgKiAgIFs3LCA4XSxcbiAgICogICBbOSwgMTBdLFxuICAgKiAgIFsxMSwgMTJdLFxuICAgKiApO1xuICAgKlxuICAgKiBjb25zdCByZXN1bHQgPSBhLnN1YihiKTtcbiAgICogLy8gPT4gTWF0cml4MkQoXG4gICAqIC8vICAgICAgWy02LCAtNl0sXG4gICAqIC8vICAgICAgWy02LCAtNl0sXG4gICAqIC8vICAgICAgWy02LCAtNl0sXG4gICAqIC8vICAgIClcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBvdGhlciAtIFRoZSBtYXRyaXggdG8gc3VicmFjdFxuICAgKi9cbiAgc3ViKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4MkQyKFxuICAgICAgdGhpcy52YWx1ZXNbMF0gLSBvdGhlci52YWx1ZXNbMF0sXG4gICAgICB0aGlzLnZhbHVlc1sxXSAtIG90aGVyLnZhbHVlc1sxXSxcbiAgICAgIHRoaXMudmFsdWVzWzJdIC0gb3RoZXIudmFsdWVzWzJdLFxuICAgICAgdGhpcy52YWx1ZXNbM10gLSBvdGhlci52YWx1ZXNbM10sXG4gICAgICB0aGlzLnZhbHVlc1s0XSAtIG90aGVyLnZhbHVlc1s0XSxcbiAgICAgIHRoaXMudmFsdWVzWzVdIC0gb3RoZXIudmFsdWVzWzVdXG4gICAgKTtcbiAgfVxuICB0b1N5bWJvbCgpIHtcbiAgICByZXR1cm4gX01hdHJpeDJEMi5zeW1ib2w7XG4gIH1cbiAgdG9Vbmlmb3JtKGdsLCBsb2NhdGlvbikge1xuICAgIGdsLnVuaWZvcm1NYXRyaXgzeDJmdihsb2NhdGlvbiwgZmFsc2UsIHRoaXMudmFsdWVzKTtcbiAgfVxuICBlcXVhbHMob3RoZXIsIHRocmVzaG9sZCA9IEVQU0lMT04pIHtcbiAgICByZXR1cm4gTWF0aC5hYnModGhpcy52YWx1ZXNbMF0gLSBvdGhlci52YWx1ZXNbMF0pIDw9IHRocmVzaG9sZCArIE51bWJlci5FUFNJTE9OICYmIE1hdGguYWJzKHRoaXMudmFsdWVzWzFdIC0gb3RoZXIudmFsdWVzWzFdKSA8PSB0aHJlc2hvbGQgKyBOdW1iZXIuRVBTSUxPTiAmJiBNYXRoLmFicyh0aGlzLnZhbHVlc1syXSAtIG90aGVyLnZhbHVlc1syXSkgPD0gdGhyZXNob2xkICsgTnVtYmVyLkVQU0lMT04gJiYgTWF0aC5hYnModGhpcy52YWx1ZXNbM10gLSBvdGhlci52YWx1ZXNbM10pIDw9IHRocmVzaG9sZCArIE51bWJlci5FUFNJTE9OICYmIE1hdGguYWJzKHRoaXMudmFsdWVzWzRdIC0gb3RoZXIudmFsdWVzWzRdKSA8PSB0aHJlc2hvbGQgKyBOdW1iZXIuRVBTSUxPTiAmJiBNYXRoLmFicyh0aGlzLnZhbHVlc1s1XSAtIG90aGVyLnZhbHVlc1s1XSkgPD0gdGhyZXNob2xkICsgTnVtYmVyLkVQU0lMT047XG4gIH1cbiAgZXhhY3RseUVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1swXSA9PT0gb3RoZXIudmFsdWVzWzBdICYmIHRoaXMudmFsdWVzWzFdID09PSBvdGhlci52YWx1ZXNbMV0gJiYgdGhpcy52YWx1ZXNbMl0gPT09IG90aGVyLnZhbHVlc1syXSAmJiB0aGlzLnZhbHVlc1szXSA9PT0gb3RoZXIudmFsdWVzWzNdICYmIHRoaXMudmFsdWVzWzRdID09PSBvdGhlci52YWx1ZXNbNF0gJiYgdGhpcy52YWx1ZXNbNV0gPT09IG90aGVyLnZhbHVlc1s1XTtcbiAgfVxufTtcbl9NYXRyaXgyRC5zeW1ib2wgPSAvKiBAX19QVVJFX18gKi8gU3ltYm9sLmZvcihcIkB0d2ljay9jb3JlL3R5cGVzL01hdHJpeDJEXCIpO1xuX01hdHJpeDJELmlkZW50aXR5ID0gbmV3IF9NYXRyaXgyRCgxLCAwLCAwLCAxLCAwLCAwKTtcbl9NYXRyaXgyRC56ZXJvID0gbmV3IF9NYXRyaXgyRCgwLCAwLCAwLCAwLCAwLCAwKTtcbnZhciBQbGF5YmFja01hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZnJhbWUgPSAwO1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIHRoaXMuZnBzID0gMzA7XG4gICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2xpZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NjZW5lID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gMjtcbiAgICB0aGlzLmN1cnJlbnRTY2VuZVJlZmVyZW5jZSA9IG51bGw7XG4gICAgdGhpcy5zY2VuZXMgPSBuZXcgVmFsdWVEaXNwYXRjaGVyKFtdKTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIGFjdGl2ZSBzY2VuZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgZ2V0IG9uU2NlbmVDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZVJlZmVyZW5jZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxheWJhY2tNYW5hZ2VyIGhhcyBub3QgYmVlbiBwcm9wZXJseSBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNjZW5lUmVmZXJlbmNlLnN1YnNjcmliYWJsZTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlcmVkIHdoZW4gdGhlIHNjZW5lcyBnZXQgcmVjYWxjdWxhdGVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIGV2ZW50IGluZGljYXRlcyB0aGF0IHRoZSB0aW1pbmcgb2YgYXQgbGVhc3Qgb25lIHNjZW5lIGhhcyBjaGFuZ2VkLlxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgZ2V0IG9uU2NlbmVzUmVjYWxjdWxhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNjZW5lcy5zdWJzY3JpYmFibGU7XG4gIH1cbiAgZ2V0IGN1cnJlbnRTY2VuZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50U2NlbmVSZWZlcmVuY2UgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsYXliYWNrTWFuYWdlciBoYXMgbm90IGJlZW4gcHJvcGVybHkgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZVJlZmVyZW5jZS5jdXJyZW50O1xuICB9XG4gIHNldCBjdXJyZW50U2NlbmUoc2NlbmUpIHtcbiAgICBpZiAoIXNjZW5lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjZW5lLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50U2NlbmVSZWZlcmVuY2UgPz8gKHRoaXMuY3VycmVudFNjZW5lUmVmZXJlbmNlID0gbmV3IFZhbHVlRGlzcGF0Y2hlcihzY2VuZSkpO1xuICAgIHRoaXMuY3VycmVudFNjZW5lUmVmZXJlbmNlLmN1cnJlbnQgPSBzY2VuZTtcbiAgfVxuICBzZXR1cChzY2VuZXMpIHtcbiAgICB0aGlzLnNjZW5lcy5jdXJyZW50ID0gc2NlbmVzO1xuICAgIHRoaXMuY3VycmVudFNjZW5lID0gc2NlbmVzWzBdO1xuICB9XG4gIGFzeW5jIHByb2dyZXNzKCkge1xuICAgIHRoaXMuZmluaXNoZWQgPSBhd2FpdCB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hlZDtcbiAgfVxuICBhc3luYyBzZWVrKGZyYW1lKSB7XG4gICAgaWYgKGZyYW1lIDw9IHRoaXMuZnJhbWUgfHwgdGhpcy5jdXJyZW50U2NlbmUuaXNDYWNoZWQoKSAmJiB0aGlzLmN1cnJlbnRTY2VuZS5sYXN0RnJhbWUgPCBmcmFtZSkge1xuICAgICAgY29uc3Qgc2NlbmUgPSB0aGlzLmZpbmRCZXN0U2NlbmUoZnJhbWUpO1xuICAgICAgaWYgKHNjZW5lICE9PSB0aGlzLmN1cnJlbnRTY2VuZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5zdG9wQWxsTWVkaWEoKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1NjZW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUgPSBzY2VuZTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuY3VycmVudFNjZW5lLmZpcnN0RnJhbWU7XG4gICAgICAgIGF3YWl0IHRoaXMuY3VycmVudFNjZW5lLnJlc2V0KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZnJhbWUgPj0gZnJhbWUpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1NjZW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuY3VycmVudFNjZW5lLmZpcnN0RnJhbWU7XG4gICAgICAgIGF3YWl0IHRoaXMuY3VycmVudFNjZW5lLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB3aGlsZSAodGhpcy5mcmFtZSA8IGZyYW1lICYmICF0aGlzLmZpbmlzaGVkKSB7XG4gICAgICB0aGlzLmZpbmlzaGVkID0gYXdhaXQgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaGVkO1xuICB9XG4gIGFzeW5jIHJlc2V0KCkge1xuICAgIHRoaXMucHJldmlvdXNTY2VuZSA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50U2NlbmUgPSB0aGlzLnNjZW5lcy5jdXJyZW50WzBdO1xuICAgIHRoaXMuZnJhbWUgPSAwO1xuICAgIGF3YWl0IHRoaXMuY3VycmVudFNjZW5lLnJlc2V0KCk7XG4gIH1cbiAgcmVsb2FkKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5zY2VuZXMuY3VycmVudC5mb3JFYWNoKChzY2VuZSkgPT4gc2NlbmUucmVsb2FkKGRlc2NyaXB0aW9uKSk7XG4gIH1cbiAgYXN5bmMgcmVjYWxjdWxhdGUoKSB7XG4gICAgdGhpcy5wcmV2aW91c1NjZW5lID0gbnVsbDtcbiAgICB0aGlzLnNsaWRlcyA9IFtdO1xuICAgIGNvbnN0IHNwZWVkID0gdGhpcy5zcGVlZDtcbiAgICB0aGlzLmZyYW1lID0gMDtcbiAgICB0aGlzLnNwZWVkID0gMTtcbiAgICBjb25zdCBzY2VuZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgZm9yIChjb25zdCBzY2VuZSBvZiB0aGlzLnNjZW5lcy5jdXJyZW50KSB7XG4gICAgICAgIGF3YWl0IHNjZW5lLnJlY2FsY3VsYXRlKChmcmFtZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2xpZGVzLnB1c2goLi4uc2NlbmUuc2xpZGVzLm9uQ2hhbmdlZC5jdXJyZW50KTtcbiAgICAgICAgc2NlbmVzLnB1c2goc2NlbmUpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgfVxuICAgIHRoaXMuc2NlbmVzLmN1cnJlbnQgPSBzY2VuZXM7XG4gICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuZnJhbWU7XG4gIH1cbiAgYXN5bmMgbmV4dCgpIHtcbiAgICBpZiAodGhpcy5wcmV2aW91c1NjZW5lKSB7XG4gICAgICBhd2FpdCB0aGlzLnByZXZpb3VzU2NlbmUubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lLmlzRmluaXNoZWQoKSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzU2NlbmUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZyYW1lICs9IHRoaXMuc3BlZWQ7XG4gICAgaWYgKHRoaXMuY3VycmVudFNjZW5lLmlzRmluaXNoZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuY3VycmVudFNjZW5lLm5leHQoKTtcbiAgICBpZiAodGhpcy5wcmV2aW91c1NjZW5lICYmIHRoaXMuY3VycmVudFNjZW5lLmlzQWZ0ZXJUcmFuc2l0aW9uSW4oKSkge1xuICAgICAgdGhpcy5wcmV2aW91c1NjZW5lID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3VycmVudFNjZW5lLmNhblRyYW5zaXRpb25PdXQoKSkge1xuICAgICAgdGhpcy5wcmV2aW91c1NjZW5lID0gdGhpcy5jdXJyZW50U2NlbmU7XG4gICAgICBjb25zdCBuZXh0U2NlbmUgPSB0aGlzLmdldE5leHRTY2VuZSh0aGlzLnByZXZpb3VzU2NlbmUpO1xuICAgICAgaWYgKG5leHRTY2VuZSkge1xuICAgICAgICB0aGlzLnByZXZpb3VzU2NlbmUuc3RvcEFsbE1lZGlhKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gbmV4dFNjZW5lO1xuICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnRTY2VuZS5yZXNldCh0aGlzLnByZXZpb3VzU2NlbmUpO1xuICAgICAgfVxuICAgICAgaWYgKCFuZXh0U2NlbmUgfHwgdGhpcy5jdXJyZW50U2NlbmUuaXNBZnRlclRyYW5zaXRpb25JbigpKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNTY2VuZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5pc0ZpbmlzaGVkKCk7XG4gIH1cbiAgZmluZEJlc3RTY2VuZShmcmFtZSkge1xuICAgIGxldCBsYXN0U2NlbmUgPSB0aGlzLnNjZW5lcy5jdXJyZW50WzBdO1xuICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgdGhpcy5zY2VuZXMuY3VycmVudCkge1xuICAgICAgaWYgKCFzY2VuZS5pc0NhY2hlZCgpIHx8IHNjZW5lLmxhc3RGcmFtZSA+IGZyYW1lKSB7XG4gICAgICAgIHJldHVybiBzY2VuZTtcbiAgICAgIH1cbiAgICAgIGxhc3RTY2VuZSA9IHNjZW5lO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdFNjZW5lO1xuICB9XG4gIGdldE5leHRTY2VuZShzY2VuZSkge1xuICAgIGNvbnN0IHNjZW5lcyA9IHRoaXMuc2NlbmVzLmN1cnJlbnQ7XG4gICAgaWYgKCFzY2VuZSkge1xuICAgICAgcmV0dXJuIHNjZW5lc1swXTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBzY2VuZXMuZmluZEluZGV4KChzKSA9PiBzID09PSBzY2VuZSk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzY2VuZXNbaW5kZXggKyAxXSA/PyBudWxsO1xuICB9XG59O1xudmFyIFBsYXliYWNrU3RhdHVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwbGF5YmFjaykge1xuICAgIHRoaXMucGxheWJhY2sgPSBwbGF5YmFjaztcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBzZWNvbmRzIHRvIGZyYW1lcyB1c2luZyB0aGUgY3VycmVudCBmcmFtZXJhdGUuXG4gICAqXG4gICAqIEBwYXJhbSBzZWNvbmRzIC0gVGhlIHNlY29uZHMgdG8gY29udmVydC5cbiAgICovXG4gIHNlY29uZHNUb0ZyYW1lcyhzZWNvbmRzKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChzZWNvbmRzICogdGhpcy5wbGF5YmFjay5mcHMpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IGZyYW1lcyB0byBzZWNvbmRzIHVzaW5nIHRoZSBjdXJyZW50IGZyYW1lcmF0ZS5cbiAgICpcbiAgICogQHBhcmFtIGZyYW1lcyAtIFRoZSBmcmFtZXMgdG8gY29udmVydC5cbiAgICovXG4gIGZyYW1lc1RvU2Vjb25kcyhmcmFtZXMpIHtcbiAgICByZXR1cm4gZnJhbWVzIC8gdGhpcy5wbGF5YmFjay5mcHM7XG4gIH1cbiAgZ2V0IHRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVzVG9TZWNvbmRzKHRoaXMucGxheWJhY2suZnJhbWUpO1xuICB9XG4gIGdldCBmcmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5YmFjay5mcmFtZTtcbiAgfVxuICBnZXQgc3BlZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWJhY2suc3BlZWQ7XG4gIH1cbiAgZ2V0IGZwcygpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5YmFjay5mcHM7XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnBsYXliYWNrLnN0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdGltZSBwYXNzZWQgc2luY2UgdGhlIGxhc3QgZnJhbWUgaW4gc2Vjb25kcy5cbiAgICovXG4gIGdldCBkZWx0YVRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhbWVzVG9TZWNvbmRzKDEpICogdGhpcy5zcGVlZDtcbiAgfVxufTtcbnZhciBTT1VSQ0VfVVJMX1JFR0VYID0gL15cXC9cXC8jIHNvdXJjZVVSTD0oLiopJC9nbTtcbnZhciBJTkZPX0xPR19SRUdFWCA9IC9FUlJPUjogXFxkKzooXFxkKyk6ICguKikvZztcbnZhciBJTkZPX1RPS0VOX1JFR0VYID0gL14nKFteJ10rKScvO1xudmFyIGluY2x1ZGVXaXRob3V0UHJlcHJvY2Vzc29yID0gYFxuVGhlIFxcYCNpbmNsdWRlXFxgIGRpcmVjdGl2ZSByZXF1aXJlcyB0aGUgdXNlIG9mIGEgcHJlcHJvY2Vzc29yLlxuXG5NYWtlIHN1cmUgdG8gaW1wb3J0IHRoZSBzaGFkZXIgZnJvbSBhIGZpbGU6XG5cblxcYFxcYFxcYHRzXG5pbXBvcnQgc2hhZGVyIGZyb20gJy4vc2hhZGVyLmdsc2wnO1xuXFxgXFxgXFxgXG5cbkRvICoqTk9UKiogdXNlIHRoZSByYXcgbG9hZGVyOlxuXG5cXGBcXGBcXGB0c1xuaW1wb3J0IHNoYWRlciBmcm9tICcuL3NoYWRlci5nbHNsP3Jhdyc7XG5cXGBcXGBcXGBcblxuRG8gKipOT1QqKiB1c2UgXFxgI2luY2x1ZGVcXGAgaW4gYW4gaW5saW5lIHN0cmluZzpcblxuXFxgXFxgXFxgdHNcbmNvbnN0IHNoYWRlciA9IFxcYFxcXFxcbiNpbmNsdWRlIFwiZXhhbXBsZS5nbHNsXCJcblxcYDtcblxcYFxcYFxcYFxuXG5bTGVhcm4gbW9yZV0oaHR0cHM6Ly9tb3Rpb25jYW52YXMuaW8vZG9jcy9zaGFkZXJzKSBhYm91dCB3b3JraW5nIHdpdGggc2hhZGVycy5cbmA7XG52YXIgU2hhcmVkV2ViR0xDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnRPd25lciA9IG51bGw7XG4gICAgdGhpcy5wcm9ncmFtTG9va3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBib3Jyb3cob3duZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuY3VycmVudE93bmVyID09PSBvd25lcikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2w7XG4gICAgfVxuICAgIChfYSA9IHRoaXMuY3VycmVudE93bmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGVhcmRvd24odGhpcy5nbCk7XG4gICAgdGhpcy5jdXJyZW50T3duZXIgPSBvd25lcjtcbiAgICB0aGlzLmN1cnJlbnRPd25lci5zZXR1cCh0aGlzLmdldEdMKCkpO1xuICAgIHJldHVybiB0aGlzLmdsO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlIHRoZSBXZWJHTCBjb250ZXh0IHRvIGZyZWUgdXAgcmVzb3VyY2VzLlxuICAgKi9cbiAgZGlzcG9zZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghdGhpcy5nbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoX2EgPSB0aGlzLmN1cnJlbnRPd25lcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRlYXJkb3duKHRoaXMuZ2wpO1xuICAgIHRoaXMuY3VycmVudE93bmVyID0gbnVsbDtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XG4gICAgZm9yIChjb25zdCB7IHByb2dyYW0sIGZyYWdtZW50LCB2ZXJ0ZXggfSBvZiB0aGlzLnByb2dyYW1Mb29rdXAudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50KTtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHZlcnRleCk7XG4gICAgfVxuICAgIHRoaXMucHJvZ3JhbUxvb2t1cC5jbGVhcigpO1xuICAgIChfYiA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCR0xfbG9zZV9jb250ZXh0XCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2IubG9zZUNvbnRleHQoKTtcbiAgICB0aGlzLmdsLmNhbnZhcy5yZW1vdmUoKTtcbiAgICB0aGlzLmdsID0gbnVsbDtcbiAgfVxuICBnZXRQcm9ncmFtKGZyYWdtZW50LCB2ZXJ0ZXgpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmcmFnbWVudH0jJHt2ZXJ0ZXh9YDtcbiAgICBpZiAodGhpcy5wcm9ncmFtTG9va3VwLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9ncmFtTG9va3VwLmdldChrZXkpLnByb2dyYW07XG4gICAgfVxuICAgIGNvbnN0IGdsID0gdGhpcy5nZXRHTCgpO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5nZXRTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudCk7XG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gdGhpcy5nZXRTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4KTtcbiAgICBpZiAoIWZyYWdtZW50U2hhZGVyIHx8ICF2ZXJ0ZXhTaGFkZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgICAgdGhpcy5sb2dnZXIuZXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBpbml0aWFsaXplIHRoZSBzaGFkZXIgcHJvZ3JhbS5cIixcbiAgICAgICAgcmVtYXJrczogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkgPz8gdm9pZCAwLFxuICAgICAgICBzdGFjazogbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgIH0pO1xuICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLnByb2dyYW1Mb29rdXAuc2V0KGtleSwge1xuICAgICAgcHJvZ3JhbSxcbiAgICAgIGZyYWdtZW50OiBmcmFnbWVudFNoYWRlcixcbiAgICAgIHZlcnRleDogdmVydGV4U2hhZGVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cbiAgZ2V0U2hhZGVyKHR5cGUsIHNvdXJjZSkge1xuICAgIGNvbnN0IGdsID0gdGhpcy5nZXRHTCgpO1xuICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgY29uc3QgbG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgbG9nR2xzbEVycm9yKHRoaXMubG9nZ2VyLCBsb2csIHNvdXJjZSk7XG4gICAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZGVyO1xuICB9XG4gIGdldEdMKCkge1xuICAgIGlmICh0aGlzLmdsKSB7XG4gICAgICByZXR1cm4gdGhpcy5nbDtcbiAgICB9XG4gICAgdGhpcy5nbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIndlYmdsMlwiLCB7XG4gICAgICBkZXB0aDogZmFsc2UsXG4gICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgICAgc3RlbmNpbDogZmFsc2UsXG4gICAgICBwb3dlclByZWZlcmVuY2U6IFwiaGlnaC1wZXJmb3JtYW5jZVwiXG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLmdsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBXZWJHTC5cIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdsO1xuICB9XG59O1xuZnVuY3Rpb24gbG9nR2xzbEVycm9yKGxvZ2dlciwgbG9nLCBzb3VyY2UpIHtcbiAgbGV0IHNvdXJjZVVybCA9IG51bGw7XG4gIFNPVVJDRV9VUkxfUkVHRVgubGFzdEluZGV4ID0gMDtcbiAgY29uc3Qgc291cmNlTWF0Y2ggPSBTT1VSQ0VfVVJMX1JFR0VYLmV4ZWMoc291cmNlKTtcbiAgaWYgKHNvdXJjZU1hdGNoKSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChzb3VyY2VNYXRjaFsxXSwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoXCJ0XCIsIERhdGUubm93KCkudG9TdHJpbmcoKSk7XG4gICAgc291cmNlVXJsID0gdXJsLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKCFsb2cpIHtcbiAgICBsb2dnZXIuZXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYFVua25vd24gc2hhZGVyIGNvbXBpbGF0aW9uIGVycm9yLmAsXG4gICAgICBzdGFjazogZmFrZVN0YWNrVHJhY2Uoc291cmNlVXJsLCAxLCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBsb2dnZWQgPSBmYWxzZTtcbiAgbGV0IHJlc3VsdDtcbiAgd2hpbGUgKHJlc3VsdCA9IElORk9fTE9HX1JFR0VYLmV4ZWMobG9nKSkge1xuICAgIGNvbnN0IFssIGxpbmUsIG1lc3NhZ2VdID0gcmVzdWx0O1xuICAgIGxldCBjb2x1bW4gPSAwO1xuICAgIGNvbnN0IG1hdGNoID0gbWVzc2FnZS5tYXRjaChJTkZPX1RPS0VOX1JFR0VYKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IHRva2VuTGluZSA9IHNvdXJjZS5zcGxpdChcIlxcblwiKVtwYXJzZUludChsaW5lKSAtIDFdO1xuICAgICAgY29uc3QgaW5kZXggPSB0b2tlbkxpbmUuaW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGNvbHVtbiA9IGluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKG1hdGNoWzFdID09PSBcImluY2x1ZGVcIikge1xuICAgICAgICBjb25zdCBsaW5lMiA9IHNvdXJjZS5zcGxpdChcIlxcblwiKS5maW5kKChsaW5lMykgPT4gbGluZTMuc3RhcnRzV2l0aChcIiNpbmNsdWRlXCIpKTtcbiAgICAgICAgaWYgKGxpbmUyKSB7XG4gICAgICAgICAgbG9nZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogYFNoYWRlciBjb21waWxhdGlvbiBlcnJvcjogJHttZXNzYWdlfWAsXG4gICAgICAgICAgICByZW1hcmtzOiBpbmNsdWRlV2l0aG91dFByZXByb2Nlc3NvclxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxvZ2dlZCA9IHRydWU7XG4gICAgbG9nZ2VyLmVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBTaGFkZXIgY29tcGlsYXRpb24gZXJyb3I6ICR7bWVzc2FnZX1gLFxuICAgICAgc3RhY2s6IGZha2VTdGFja1RyYWNlKHNvdXJjZVVybCwgbGluZSwgY29sdW1uKVxuICAgIH0pO1xuICB9XG4gIGlmICghbG9nZ2VkKSB7XG4gICAgbG9nZ2VyLmVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBTaGFkZXIgY29tcGlsYXRpb24gZXJyb3I6ICR7bG9nfWAsXG4gICAgICBzdGFjazogZmFrZVN0YWNrVHJhY2Uoc291cmNlVXJsLCAxLCAwKVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBmYWtlU3RhY2tUcmFjZShmaWxlLCBsaW5lLCBjb2x1bW4pIHtcbiAgaWYgKCFmaWxlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiY2hyb21lXCIpID8gYCAgYXQgKCR7ZmlsZX06JHtsaW5lfToke2NvbHVtbn0pYCA6IGBAJHtmaWxlfToke2xpbmV9OiR7Y29sdW1ufWA7XG59XG52YXIgUGxheWVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihwcm9qZWN0LCBzZXR0aW5ncyA9IHt9LCBpbml0aWFsU3RhdGUgPSB7fSwgaW5pdGlhbEZyYW1lID0gLTEpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuaW5pdGlhbEZyYW1lID0gaW5pdGlhbEZyYW1lO1xuICAgIHRoaXMucmVuZGVyID0gbmV3IEFzeW5jRXZlbnREaXNwYXRjaGVyKCk7XG4gICAgdGhpcy5mcmFtZSA9IG5ldyBWYWx1ZURpc3BhdGNoZXIoMCk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IG5ldyBWYWx1ZURpc3BhdGNoZXIoMCk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZWQgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XG4gICAgdGhpcy5sb2NrID0gbmV3IFNlbWFwaG9yZSgpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLmVuZFRpbWUgPSBJbmZpbml0eTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJUaW1lID0gMDtcbiAgICB0aGlzLnJlcXVlc3RlZFNlZWsgPSAtMTtcbiAgICB0aGlzLnJlcXVlc3RlZFJlbmRlciA9IGZhbHNlO1xuICAgIHRoaXMucmVxdWVzdGVkUmVjYWxjdWxhdGlvbiA9IHRydWU7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnBsYXllclN0YXRlID0gbmV3IFZhbHVlRGlzcGF0Y2hlcih7XG4gICAgICBsb29wOiB0cnVlLFxuICAgICAgbXV0ZWQ6IHRydWUsXG4gICAgICB2b2x1bWU6IDEsXG4gICAgICBzcGVlZDogMSxcbiAgICAgIC4uLmluaXRpYWxTdGF0ZSxcbiAgICAgIHBhdXNlZDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuc2hhcmVkV2ViR0xDb250ZXh0ID0gbmV3IFNoYXJlZFdlYkdMQ29udGV4dCh0aGlzLnByb2plY3QubG9nZ2VyKTtcbiAgICB0aGlzLnJlcXVlc3RlZFNlZWsgPSBpbml0aWFsRnJhbWU7XG4gICAgdGhpcy5sb2dnZXIgPSB0aGlzLnByb2plY3QubG9nZ2VyO1xuICAgIHRoaXMucGxheWJhY2sgPSBuZXcgUGxheWJhY2tNYW5hZ2VyKCk7XG4gICAgdGhpcy5zdGF0dXMgPSBuZXcgUGxheWJhY2tTdGF0dXModGhpcy5wbGF5YmFjayk7XG4gICAgdGhpcy5zaXplID0gc2V0dGluZ3Muc2l6ZSA/PyBuZXcgVmVjdG9yMigxOTIwLCAxMDgwKTtcbiAgICB0aGlzLnJlc29sdXRpb25TY2FsZSA9IHNldHRpbmdzLnJlc29sdXRpb25TY2FsZSA/PyAxO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gKChfYSA9IHNldHRpbmdzLnJhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID8/IDA7XG4gICAgdGhpcy5lbmRUaW1lID0gKChfYiA9IHNldHRpbmdzLnJhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2JbMV0pID8/IEluZmluaXR5O1xuICAgIHRoaXMucGxheWJhY2suZnBzID0gc2V0dGluZ3MuZnBzID8/IDYwO1xuICAgIGNvbnN0IHNjZW5lcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRpb24gb2YgcHJvamVjdC5zY2VuZXMpIHtcbiAgICAgIGNvbnN0IHNjZW5lID0gbmV3IGRlc2NyaXB0aW9uLmtsYXNzKHtcbiAgICAgICAgLi4uZGVzY3JpcHRpb24sXG4gICAgICAgIHBsYXliYWNrOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgbG9nZ2VyOiB0aGlzLnByb2plY3QubG9nZ2VyLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIHJlc29sdXRpb25TY2FsZTogdGhpcy5yZXNvbHV0aW9uU2NhbGUsXG4gICAgICAgIHNoYXJlZFdlYkdMQ29udGV4dDogdGhpcy5zaGFyZWRXZWJHTENvbnRleHQsXG4gICAgICAgIGV4cGVyaW1lbnRhbEZlYXR1cmVzOiBwcm9qZWN0LmV4cGVyaW1lbnRhbEZlYXR1cmVzXG4gICAgICB9KTtcbiAgICAgIHNjZW5lLm9uUmVsb2FkZWQuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVxdWVzdFJlY2FsY3VsYXRpb24oKSk7XG4gICAgICBzY2VuZS52YXJpYWJsZXMudXBkYXRlU2lnbmFscyhwcm9qZWN0LnZhcmlhYmxlcyA/PyB7fSk7XG4gICAgICBzY2VuZXMucHVzaChzY2VuZSk7XG4gICAgfVxuICAgIHRoaXMucGxheWJhY2suc2V0dXAoc2NlbmVzKTtcbiAgICB0aGlzLmFjdGl2YXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBkdXJpbmcgZWFjaCBpdGVyYXRpb24gb2YgdGhlIHVwZGF0ZSBsb29wIHdoZW4gdGhlIGZyYW1lIGlzIHJlYWR5XG4gICAqIHRvIGJlIHJlbmRlcmVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBQbGF5ZXIgZG9lcyBub3QgcGVyZm9ybSBhbnkgcmVuZGVyaW5nIG9uIGl0cyBvd24uIEZvciB0aGUgYW5pbWF0aW9uIHRvIGJlXG4gICAqIHZpc2libGUsIGFub3RoZXIgY2xhc3MgbXVzdCBzdWJzY3JpYmUgdG8gdGhpcyBldmVudCBhbmQgcGVyZm9ybSB0aGVcbiAgICogcmVuZGVyaW5nIGl0c2VsZi4ge0BsaW5rIFN0YWdlfSBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IHRoZSBhbmltYXRpb24uXG4gICAqXG4gICAqIEBldmVudFByb3BlcnR5XG4gICAqL1xuICBnZXQgb25SZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyLnN1YnNjcmliYWJsZTtcbiAgfVxuICBnZXQgb25TdGF0ZUNoYW5nZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWVyU3RhdGUuc3Vic2NyaWJhYmxlO1xuICB9XG4gIGdldCBvbkZyYW1lQ2hhbmdlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFtZS5zdWJzY3JpYmFibGU7XG4gIH1cbiAgZ2V0IG9uRHVyYXRpb25DaGFuZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLmR1cmF0aW9uLnN1YnNjcmliYWJsZTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlcmVkIHJpZ2h0IGFmdGVyIHJlY2FsY3VsYXRpb24gZmluaXNoZXMuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIENhbiBiZSB1c2VkIHRvIHByb3ZpZGUgdmlzdWFsIGZlZWRiYWNrLlxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgZ2V0IG9uUmVjYWxjdWxhdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnJlY2FsY3VsYXRlZC5zdWJzY3JpYmFibGU7XG4gIH1cbiAgZ2V0IHN0YXJ0RnJhbWUoKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKFxuICAgICAgdGhpcy5wbGF5YmFjay5kdXJhdGlvbixcbiAgICAgIHRoaXMuc3RhdHVzLnNlY29uZHNUb0ZyYW1lcyh0aGlzLnN0YXJ0VGltZSlcbiAgICApO1xuICB9XG4gIGdldCBlbmRGcmFtZSgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICB0aGlzLnBsYXliYWNrLmR1cmF0aW9uLFxuICAgICAgdGhpcy5zdGF0dXMuc2Vjb25kc1RvRnJhbWVzKHRoaXMuZW5kVGltZSlcbiAgICApO1xuICB9XG4gIGdldCBmaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wbGF5YmFjay5maW5pc2hlZCB8fCB0aGlzLnBsYXliYWNrLmZyYW1lID49IHRoaXMuZW5kRnJhbWU7XG4gIH1cbiAgYXN5bmMgY29uZmlndXJlKHNldHRpbmdzKSB7XG4gICAgYXdhaXQgdGhpcy5sb2NrLmFjcXVpcmUoKTtcbiAgICBsZXQgZnJhbWUgPSB0aGlzLnBsYXliYWNrLmZyYW1lO1xuICAgIGxldCByZWNhbGN1bGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc2V0dGluZ3MucmFuZ2VbMF07XG4gICAgdGhpcy5lbmRUaW1lID0gc2V0dGluZ3MucmFuZ2VbMV07XG4gICAgY29uc3QgbmV3RnBzID0gTWF0aC5tYXgoMSwgc2V0dGluZ3MuZnBzKTtcbiAgICBpZiAodGhpcy5wbGF5YmFjay5mcHMgIT09IG5ld0Zwcykge1xuICAgICAgY29uc3QgcmF0aW8gPSBuZXdGcHMgLyB0aGlzLnBsYXliYWNrLmZwcztcbiAgICAgIHRoaXMucGxheWJhY2suZnBzID0gbmV3RnBzO1xuICAgICAgZnJhbWUgPSBNYXRoLmZsb29yKGZyYW1lICogcmF0aW8pO1xuICAgICAgcmVjYWxjdWxhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXNldHRpbmdzLnNpemUuZXhhY3RseUVxdWFscyh0aGlzLnNpemUpIHx8IHNldHRpbmdzLnJlc29sdXRpb25TY2FsZSAhPT0gdGhpcy5yZXNvbHV0aW9uU2NhbGUpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IHNldHRpbmdzLnNpemU7XG4gICAgICB0aGlzLnJlc29sdXRpb25TY2FsZSA9IHNldHRpbmdzLnJlc29sdXRpb25TY2FsZTtcbiAgICAgIHRoaXMucGxheWJhY2sucmVsb2FkKHtcbiAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICByZXNvbHV0aW9uU2NhbGU6IHRoaXMucmVzb2x1dGlvblNjYWxlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5sb2NrLnJlbGVhc2UoKTtcbiAgICBpZiAocmVjYWxjdWxhdGUpIHtcbiAgICAgIHRoaXMucGxheWJhY2sucmVsb2FkKCk7XG4gICAgICB0aGlzLmZyYW1lLmN1cnJlbnQgPSBmcmFtZTtcbiAgICAgIHRoaXMucmVxdWVzdFJlY2FsY3VsYXRpb24oKTtcbiAgICAgIHRoaXMucmVxdWVzdGVkU2VlayA9IGZyYW1lO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gZnJhbWUgaXMgaW5zaWRlIHRoZSBhbmltYXRpb24gcmFuZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBmcmFtZSAtIFRoZSBmcmFtZSB0byBjaGVjay5cbiAgICovXG4gIGlzSW5SYW5nZShmcmFtZSkge1xuICAgIHJldHVybiBmcmFtZSA+PSAwICYmIGZyYW1lIDw9IHRoaXMucGxheWJhY2suZHVyYXRpb247XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdpdmVuIGZyYW1lIGlzIGluc2lkZSB0aGUgdXNlci1kZWZpbmVkIHJhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJhbWUgLSBUaGUgZnJhbWUgdG8gY2hlY2suXG4gICAqL1xuICBpc0luVXNlclJhbmdlKGZyYW1lKSB7XG4gICAgcmV0dXJuIGZyYW1lID49IHRoaXMuc3RhcnRGcmFtZSAmJiBmcmFtZSA8PSB0aGlzLmVuZEZyYW1lO1xuICB9XG4gIHJlcXVlc3RTZWVrKHZhbHVlKSB7XG4gICAgdGhpcy5yZXF1ZXN0ZWRTZWVrID0gdGhpcy5jbGFtcFJhbmdlKHZhbHVlKTtcbiAgfVxuICByZXF1ZXN0UHJldmlvdXNGcmFtZSgpIHtcbiAgICB0aGlzLnJlcXVlc3RlZFNlZWsgPSB0aGlzLmZyYW1lLmN1cnJlbnQgLSB0aGlzLnBsYXliYWNrLnNwZWVkO1xuICB9XG4gIHJlcXVlc3ROZXh0RnJhbWUoKSB7XG4gICAgdGhpcy5yZXF1ZXN0ZWRTZWVrID0gdGhpcy5mcmFtZS5jdXJyZW50ICsgdGhpcy5wbGF5YmFjay5zcGVlZDtcbiAgfVxuICByZXF1ZXN0UmVzZXQoKSB7XG4gICAgdGhpcy5yZXF1ZXN0ZWRTZWVrID0gMDtcbiAgfVxuICByZXF1ZXN0UmVuZGVyKCkge1xuICAgIHRoaXMucmVxdWVzdGVkUmVuZGVyID0gdHJ1ZTtcbiAgfVxuICB0b2dnbGVMb29wKHZhbHVlID0gIXRoaXMucGxheWVyU3RhdGUuY3VycmVudC5sb29wKSB7XG4gICAgaWYgKHZhbHVlICE9PSB0aGlzLnBsYXllclN0YXRlLmN1cnJlbnQubG9vcCkge1xuICAgICAgdGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgICAuLi50aGlzLnBsYXllclN0YXRlLmN1cnJlbnQsXG4gICAgICAgIGxvb3A6IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB0b2dnbGVQbGF5YmFjayh2YWx1ZSA9IHRoaXMucGxheWVyU3RhdGUuY3VycmVudC5wYXVzZWQpIHtcbiAgICBpZiAodmFsdWUgPT09IHRoaXMucGxheWVyU3RhdGUuY3VycmVudC5wYXVzZWQpIHtcbiAgICAgIHRoaXMucGxheWVyU3RhdGUuY3VycmVudCA9IHtcbiAgICAgICAgLi4udGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50LFxuICAgICAgICBwYXVzZWQ6ICF2YWx1ZVxuICAgICAgfTtcbiAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50Lmxvb3AgJiYgdGhpcy5wbGF5YmFjay5mcmFtZSA9PT0gdGhpcy5wbGF5YmFjay5kdXJhdGlvbikge1xuICAgICAgICB0aGlzLnJlcXVlc3RSZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0b2dnbGVBdWRpbyh2YWx1ZSA9IHRoaXMucGxheWVyU3RhdGUuY3VycmVudC5tdXRlZCkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50Lm11dGVkKSB7XG4gICAgICB0aGlzLnBsYXllclN0YXRlLmN1cnJlbnQgPSB7XG4gICAgICAgIC4uLnRoaXMucGxheWVyU3RhdGUuY3VycmVudCxcbiAgICAgICAgbXV0ZWQ6ICF2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgc2V0QXVkaW9Wb2x1bWUodmFsdWUpIHtcbiAgICBjb25zdCBjbGFtcGVkVmFsdWUgPSBjbGFtcCgwLCAxLCB2YWx1ZSk7XG4gICAgaWYgKGNsYW1wZWRWYWx1ZSAhPT0gdGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50LnZvbHVtZSkge1xuICAgICAgdGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgICAuLi50aGlzLnBsYXllclN0YXRlLmN1cnJlbnQsXG4gICAgICAgIHZvbHVtZTogY2xhbXBlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBhZGRBdWRpb1ZvbHVtZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0QXVkaW9Wb2x1bWUodGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50LnZvbHVtZSArIHZhbHVlKTtcbiAgfVxuICBzZXRTcGVlZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50LnNwZWVkKSB7XG4gICAgICB0aGlzLnBsYXliYWNrLnNwZWVkID0gdmFsdWU7XG4gICAgICB0aGlzLnBsYXliYWNrLnJlbG9hZCgpO1xuICAgICAgdGhpcy5wbGF5ZXJTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgICAuLi50aGlzLnBsYXllclN0YXRlLmN1cnJlbnQsXG4gICAgICAgIHNwZWVkOiB2YWx1ZVxuICAgICAgfTtcbiAgICAgIHRoaXMucmVxdWVzdFJlY2FsY3VsYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgc2V0VmFyaWFibGVzKHZhcmlhYmxlcykge1xuICAgIGZvciAoY29uc3Qgc2NlbmUgb2YgdGhpcy5wbGF5YmFjay5vblNjZW5lc1JlY2FsY3VsYXRlZC5jdXJyZW50KSB7XG4gICAgICBzY2VuZS52YXJpYWJsZXMudXBkYXRlU2lnbmFscyh2YXJpYWJsZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIHBsYXllci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQSBwbGF5ZXIgbmVlZHMgdG8gYmUgYWN0aXZlIGluIG9yZGVyIGZvciB0aGUgdXBkYXRlIGxvb3AgdG8gcnVuLiBFYWNoXG4gICAqIHBsYXllciBpcyBhY3RpdmUgYnkgZGVmYXVsdC5cbiAgICovXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnJlcXVlc3QoKTtcbiAgfVxuICAvKipcbiAgICogRGVhY3RpdmF0ZSB0aGUgcGxheWVyLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBEZWFjdGl2YXRpbmcgdGhlIHBsYXllciBwcmV2ZW50cyBpdHMgdXBkYXRlIGxvb3AgZnJvbSBydW5uaW5nLiBUaGlzIHNob3VsZFxuICAgKiBiZSBkb25lIGJlZm9yZSBkaXNwb3NpbmcgdGhlIHBsYXllciwgdG8gcHJldmVudCBpdCBmcm9tIHJ1bm5pbmcgaW4gdGhlXG4gICAqIGJhY2tncm91bmQuXG4gICAqXG4gICAqIEp1c3QgcGF1c2luZyB0aGUgcGxheWVyIGRvZXMgbm90IHN0b3AgdGhlIGxvb3AuXG4gICAqL1xuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zaGFyZWRXZWJHTENvbnRleHQuZGlzcG9zZSgpO1xuICAgIHRoaXMucGxheWJhY2suY3VycmVudFNjZW5lLnN0b3BBbGxNZWRpYSgpO1xuICAgIGlmICh0aGlzLnJlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0SWQpO1xuICAgICAgdGhpcy5yZXF1ZXN0SWQgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXF1ZXN0UmVjYWxjdWxhdGlvbigpIHtcbiAgICB0aGlzLnJlcXVlc3RlZFJlY2FsY3VsYXRpb24gPSB0cnVlO1xuICAgIHRoaXMucmVxdWVzdCgpO1xuICB9XG4gIGFzeW5jIHByZXBhcmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAuLi50aGlzLnBsYXllclN0YXRlLmN1cnJlbnQsXG4gICAgICBzZWVrOiB0aGlzLnJlcXVlc3RlZFNlZWssXG4gICAgICByZW5kZXI6IHRoaXMucmVxdWVzdGVkUmVuZGVyXG4gICAgfTtcbiAgICB0aGlzLnJlcXVlc3RlZFNlZWsgPSAtMTtcbiAgICB0aGlzLnJlcXVlc3RlZFJlbmRlciA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnJlcXVlc3RlZFJlY2FsY3VsYXRpb24pIHtcbiAgICAgIGlmIChzdGF0ZS5zZWVrIDwgMCkge1xuICAgICAgICBzdGF0ZS5zZWVrID0gdGhpcy5wbGF5YmFjay5mcmFtZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucGxheWJhY2sucmVjYWxjdWxhdGUoKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbi5jdXJyZW50ID0gdGhpcy5wbGF5YmFjay5mcmFtZTtcbiAgICAgICAgdGhpcy5yZWNhbGN1bGF0ZWQuZGlzcGF0Y2goKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFNlZWsoc3RhdGUuc2Vlayk7XG4gICAgICAgIHRocm93IGUyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZWNhbGN1bGF0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhdGUubG9vcCAmJiB0aGlzLmZpbmlzaGVkICYmICFzdGF0ZS5wYXVzZWQgJiYgc3RhdGUuc2VlayA8IDAgfHwgdGhpcy5lbmRGcmFtZSA9PT0gdGhpcy5zdGFydEZyYW1lKSB7XG4gICAgICB0aGlzLnRvZ2dsZVBsYXliYWNrKGZhbHNlKTtcbiAgICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgICBzdGF0ZS5zZWVrID0gdGhpcy5lbmRGcmFtZSA9PT0gdGhpcy5zdGFydEZyYW1lID8gc3RhdGUuc2VlayA6IHRoaXMuc3RhcnRGcmFtZTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmxvb3AgJiYgKHN0YXRlLnNlZWsgPiB0aGlzLmVuZEZyYW1lIHx8IHRoaXMuZmluaXNoZWQgJiYgIXN0YXRlLnBhdXNlZCkgJiYgdGhpcy5zdGFydEZyYW1lICE9PSB0aGlzLmVuZFRpbWUpIHtcbiAgICAgIHN0YXRlLnNlZWsgPSB0aGlzLnN0YXJ0RnJhbWU7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuICBhc3luYyBydW4oKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLnByZXBhcmUoKTtcbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5wbGF5YmFjay5zdGF0ZTtcbiAgICB0aGlzLnBsYXliYWNrLnN0YXRlID0gc3RhdGUucGF1c2VkID8gMiA6IDA7XG4gICAgaWYgKHN0YXRlLnNlZWsgPj0gMCB8fCAhdGhpcy5pc0luVXNlclJhbmdlKHRoaXMuc3RhdHVzLmZyYW1lKSkge1xuICAgICAgY29uc3Qgc2Vla0ZyYW1lID0gc3RhdGUuc2VlayA8IDAgPyB0aGlzLnN0YXR1cy5mcmFtZSA6IHN0YXRlLnNlZWs7XG4gICAgICBjb25zdCBjbGFtcGVkRnJhbWUgPSB0aGlzLmNsYW1wUmFuZ2Uoc2Vla0ZyYW1lKTtcbiAgICAgIHRoaXMubG9nZ2VyLnByb2ZpbGUoXCJzZWVrIHRpbWVcIik7XG4gICAgICBhd2FpdCB0aGlzLnBsYXliYWNrLnNlZWsoY2xhbXBlZEZyYW1lKTtcbiAgICAgIHRoaXMubG9nZ2VyLnByb2ZpbGUoXCJzZWVrIHRpbWVcIik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wYXVzZWQpIHtcbiAgICAgIGlmIChzdGF0ZS5yZW5kZXIgfHwgc3RhdGUucGF1c2VkICYmIHByZXZpb3VzU3RhdGUgIT09IDIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXIuZGlzcGF0Y2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVxdWVzdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0dXMuZnJhbWUgPCB0aGlzLmVuZEZyYW1lKSB7XG4gICAgICBhd2FpdCB0aGlzLnBsYXliYWNrLnByb2dyZXNzKCk7XG4gICAgfVxuICAgIGlmICghc3RhdGUucGF1c2VkICYmIHRoaXMucGxheWJhY2suY3VycmVudFNjZW5lLnNsaWRlcy5pc1dhaXRpbmcoKSkge1xuICAgICAgdGhpcy50b2dnbGVQbGF5YmFjayhmYWxzZSk7XG4gICAgICBzdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlbmRlci5kaXNwYXRjaCgpO1xuICAgIHRoaXMuZnJhbWUuY3VycmVudCA9IHRoaXMucGxheWJhY2suZnJhbWU7XG4gICAgdGhpcy5yZXF1ZXN0KCk7XG4gIH1cbiAgcmVxdWVzdCgpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSByZXR1cm47XG4gICAgdGhpcy5yZXF1ZXN0SWQgPz8gKHRoaXMucmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFzeW5jICh0aW1lKSA9PiB7XG4gICAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XG4gICAgICBpZiAodGltZSAtIHRoaXMucmVuZGVyVGltZSA+PSAxZTMgLyAodGhpcy5zdGF0dXMuZnBzICsgNSkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUaW1lID0gdGltZTtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2NrLmFjcXVpcmUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnJ1bigpO1xuICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGUyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2sucmVsZWFzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0KCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIGNsYW1wUmFuZ2UoZnJhbWUpIHtcbiAgICByZXR1cm4gY2xhbXAodGhpcy5zdGFydEZyYW1lLCB0aGlzLmVuZEZyYW1lLCBmcmFtZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRGdWxsUHJldmlld1NldHRpbmdzKHByb2plY3QpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5wcm9qZWN0LnNldHRpbmdzLnNoYXJlZCxcbiAgICAuLi5wcm9qZWN0LnNldHRpbmdzLnByZXZpZXdcbiAgfTtcbn1cbnZhciBTdGFnZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICB0aGlzLnJlc29sdXRpb25TY2FsZSA9IDE7XG4gICAgdGhpcy5jb2xvclNwYWNlID0gXCJzcmdiXCI7XG4gICAgdGhpcy5zaXplID0gVmVjdG9yMi56ZXJvO1xuICAgIHRoaXMuZmluYWxCdWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY3VycmVudEJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5wcmV2aW91c0J1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY29uc3QgY29sb3JTcGFjZSA9IHRoaXMuY29sb3JTcGFjZTtcbiAgICB0aGlzLmNvbnRleHQgPSBnZXRDb250ZXh0KHsgY29sb3JTcGFjZSB9LCB0aGlzLmZpbmFsQnVmZmVyKTtcbiAgICB0aGlzLmN1cnJlbnRDb250ZXh0ID0gZ2V0Q29udGV4dCh7IGNvbG9yU3BhY2UgfSwgdGhpcy5jdXJyZW50QnVmZmVyKTtcbiAgICB0aGlzLnByZXZpb3VzQ29udGV4dCA9IGdldENvbnRleHQoeyBjb2xvclNwYWNlIH0sIHRoaXMucHJldmlvdXNCdWZmZXIpO1xuICB9XG4gIGdldCBjYW52YXNTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUuc2NhbGUodGhpcy5yZXNvbHV0aW9uU2NhbGUpO1xuICB9XG4gIGNvbmZpZ3VyZSh7XG4gICAgY29sb3JTcGFjZSA9IHRoaXMuY29sb3JTcGFjZSxcbiAgICBzaXplID0gdGhpcy5zaXplLFxuICAgIHJlc29sdXRpb25TY2FsZSA9IHRoaXMucmVzb2x1dGlvblNjYWxlLFxuICAgIGJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmRcbiAgfSkge1xuICAgIGlmIChjb2xvclNwYWNlICE9PSB0aGlzLmNvbG9yU3BhY2UpIHtcbiAgICAgIHRoaXMuY29sb3JTcGFjZSA9IGNvbG9yU3BhY2U7XG4gICAgICB0aGlzLmNvbnRleHQgPSBnZXRDb250ZXh0KHsgY29sb3JTcGFjZSB9LCB0aGlzLmZpbmFsQnVmZmVyKTtcbiAgICAgIHRoaXMuY3VycmVudENvbnRleHQgPSBnZXRDb250ZXh0KHsgY29sb3JTcGFjZSB9LCB0aGlzLmN1cnJlbnRCdWZmZXIpO1xuICAgICAgdGhpcy5wcmV2aW91c0NvbnRleHQgPSBnZXRDb250ZXh0KHsgY29sb3JTcGFjZSB9LCB0aGlzLnByZXZpb3VzQnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKCFzaXplLmV4YWN0bHlFcXVhbHModGhpcy5zaXplKSB8fCByZXNvbHV0aW9uU2NhbGUgIT09IHRoaXMucmVzb2x1dGlvblNjYWxlKSB7XG4gICAgICB0aGlzLnJlc29sdXRpb25TY2FsZSA9IHJlc29sdXRpb25TY2FsZTtcbiAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLnJlc2l6ZUNhbnZhcyh0aGlzLmNvbnRleHQpO1xuICAgICAgdGhpcy5yZXNpemVDYW52YXModGhpcy5jdXJyZW50Q29udGV4dCk7XG4gICAgICB0aGlzLnJlc2l6ZUNhbnZhcyh0aGlzLnByZXZpb3VzQ29udGV4dCk7XG4gICAgfVxuICAgIHRoaXMuYmFja2dyb3VuZCA9IHR5cGVvZiBiYWNrZ3JvdW5kID09PSBcInN0cmluZ1wiID8gYmFja2dyb3VuZCA6IChiYWNrZ3JvdW5kID09IG51bGwgPyB2b2lkIDAgOiBiYWNrZ3JvdW5kLnNlcmlhbGl6ZSgpKSA/PyBudWxsO1xuICB9XG4gIGFzeW5jIHJlbmRlcihjdXJyZW50U2NlbmUsIHByZXZpb3VzU2NlbmUpIHtcbiAgICBjb25zdCBwcmV2aW91c09uVG9wID0gcHJldmlvdXNTY2VuZSA/IHVud3JhcChjdXJyZW50U2NlbmUucHJldmlvdXNPblRvcCkgOiBmYWxzZTtcbiAgICBpZiAocHJldmlvdXNTY2VuZSkge1xuICAgICAgYXdhaXQgcHJldmlvdXNTY2VuZS5yZW5kZXIodGhpcy5wcmV2aW91c0NvbnRleHQpO1xuICAgIH1cbiAgICBhd2FpdCBjdXJyZW50U2NlbmUucmVuZGVyKHRoaXMuY3VycmVudENvbnRleHQpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmNhbnZhc1NpemU7XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xuICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmQ7XG4gICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzU2NlbmUgJiYgIXByZXZpb3VzT25Ub3ApIHtcbiAgICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5wcmV2aW91c0J1ZmZlciwgMCwgMCk7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dC5kcmF3SW1hZ2UodGhpcy5jdXJyZW50QnVmZmVyLCAwLCAwKTtcbiAgICBpZiAocHJldmlvdXNPblRvcCkge1xuICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLnByZXZpb3VzQnVmZmVyLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgcmVzaXplQ2FudmFzKGNvbnRleHQpIHtcbiAgICBjb25zdCBzaXplID0gdGhpcy5jYW52YXNTaXplO1xuICAgIGNvbnRleHQuY2FudmFzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICBjb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzVGhyZWFkR2VuZXJhdG9yKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlICYmIFwibmV4dFwiIGluIHZhbHVlO1xufVxudmFyIHJldXNlZEdlbmVyYXRvciA9IGBcblRoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4geW91IG1pc3Rha2VubHkgcmV1c2UgYSBnZW5lcmF0b3IgdGhhdCBpcyBhbHJlYWR5XG5ydW5uaW5nLlxuXG5Gb3IgZXhhbXBsZSwgdXNpbmcgXFxgeWllbGRcXGAgaGVyZSB3aWxsIHJ1biB0aGUgb3BhY2l0eSBnZW5lcmF0b3IgY29uY3VycmVudGx5IGFuZFxuc3RvcmUgaXQgaW4gdGhlIFxcYHRhc2tcXGAgdmFyaWFibGUgKGluIGNhc2UgeW91IHdhbnQgdG8gY2FuY2VsIG9yIGF3YWl0IGl0IGxhdGVyKTpcblxuXFxgXFxgXFxgdHNcbmNvbnN0IHRhc2sgPSB5aWVsZCByZWN0KCkub3BhY2l0eSgxLCAxKTtcblxcYFxcYFxcYFxuXG5UcnlpbmcgdG8gXFxgeWllbGRcXGAgdGhpcyB0YXNrIGFnYWluIHdpbGwgY2F1c2UgdGhlIGN1cnJlbnQgZXJyb3I6XG5cblxcYFxcYFxcYHRzXG55aWVsZCB0YXNrO1xuXFxgXFxgXFxgXG5cblBhc3NpbmcgaXQgdG8gb3RoZXIgZmxvdyBmdW5jdGlvbnMgd2lsbCBhbHNvIGNhdXNlIHRoZSBlcnJvcjpcblxuXFxgXFxgXFxgdHNcbi8vIHByZXR0aWVyLWlnbm9yZVxueWllbGQqIGFsbCh0YXNrKTtcblxcYFxcYFxcYFxuXG5UcnkgdG8gaW52ZXN0aWdhdGUgeW91ciBjb2RlIGxvb2tpbmcgZm9yIFxcYHlpZWxkXFxgIHN0YXRlbWVudHMgd2hvc2UgcmV0dXJuIHZhbHVlXG5pcyByZXVzZWQgaW4gdGhpcyB3YXkuIEhlcmUncyBhbiBleGFtcGxlIG9mIGEgY29tbW9uIG1pc3Rha2U6XG5cblxcYFxcYFxcYHRzIHdyb25nXG4vLyBwcmV0dGllci1pZ25vcmVcbnlpZWxkKiBhbGwoXG4gIHlpZWxkIHJlY3QoKS5vcGFjaXR5KDEsIDEpLCBcbiAgeWllbGQgcmVjdCgpLngoMjAwLCAxKSxcbik7XG5cXGBcXGBcXGBcblxuXFxgXFxgXFxgdHMgY29ycmVjdFxuLy8gcHJldHRpZXItaWdub3JlXG55aWVsZCogYWxsKFxuICByZWN0KCkub3BhY2l0eSgxLCAxKSwgXG4gIHJlY3QoKS54KDIwMCwgMSksXG4pO1xuXFxgXFxgXFxgXG5gO1xuZGVjb3JhdGUobm9vcCwgdGhyZWFkYWJsZSgpKTtcbmZ1bmN0aW9uKiBub29wKCkge1xufVxudmFyIFRocmVhZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocnVubmVyKSB7XG4gICAgdGhpcy5ydW5uZXIgPSBydW5uZXI7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMudGltZSA9IGNyZWF0ZVNpZ25hbCgwKTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5pc0NhbmNlbGVkID0gZmFsc2U7XG4gICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuZml4ZWRUaW1lID0gMDtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgaWYgKHRoaXMucnVubmVyLnRhc2spIHtcbiAgICAgIHVzZUxvZ2dlcigpLmVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYFRoZSBnZW5lcmF0b3IgXCIke2dldFRhc2tOYW1lKFxuICAgICAgICAgIHRoaXMucnVubmVyXG4gICAgICAgICl9XCIgaXMgYWxyZWFkeSBiZWluZyBleGVjdXRlZCBieSBhbm90aGVyIHRocmVhZC5gLFxuICAgICAgICByZW1hcmtzOiByZXVzZWRHZW5lcmF0b3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ydW5uZXIgPSBub29wKCk7XG4gICAgfVxuICAgIHRoaXMucnVubmVyLnRhc2sgPSB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZml4ZWQgdGltZSBvZiB0aGlzIHRocmVhZC5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogRml4ZWQgdGltZSBpcyBhIG11bHRpcGxlIG9mIHRoZSBmcmFtZSBkdXJhdGlvbi4gSXQgY2FuIGJlIHVzZWQgdG8gYWNjb3VudFxuICAgKiBmb3IgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIHRocmVhZCdzIHtAbGluayB0aW1lfSBhbmQgdGhlIHRpbWUgb2YgdGhlXG4gICAqIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lLlxuICAgKi9cbiAgZ2V0IGZpeGVkKCkge1xuICAgIHJldHVybiB0aGlzLmZpeGVkVGltZTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhpcyB0aHJlYWQgb3IgYW55IG9mIGl0cyBhbmNlc3RvcnMgaGFzIGJlZW4gY2FuY2VsZWQuXG4gICAqL1xuICBnZXQgY2FuY2VsZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiB0aGlzLmlzQ2FuY2VsZWQgfHwgKCgoX2EgPSB0aGlzLnBhcmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbmNlbGVkKSA/PyBmYWxzZSk7XG4gIH1cbiAgZ2V0IHBhdXNlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXVzZWQgfHwgKCgoX2EgPSB0aGlzLnBhcmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBhdXNlZCkgPz8gZmFsc2UpO1xuICB9XG4gIC8qKlxuICAgKiBQcm9ncmVzcyB0aGUgd3JhcHBlZCBnZW5lcmF0b3Igb25jZS5cbiAgICovXG4gIG5leHQoKSB7XG4gICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0VGhyZWFkKHRoaXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucnVubmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgZW5kVGhyZWFkKHRoaXMpO1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICAqIFByZXBhcmUgdGhlIHRocmVhZCBmb3IgdGhlIG5leHQgdXBkYXRlIGN5Y2xlLlxuICAgKlxuICAgKiBAcGFyYW0gZHQgLSBUaGUgZGVsdGEgdGltZSBvZiB0aGUgbmV4dCBjeWNsZS5cbiAgICovXG4gIHVwZGF0ZShkdCkge1xuICAgIGlmICghdGhpcy5wYXVzZWQpIHtcbiAgICAgIHRoaXMudGltZSh0aGlzLnRpbWUoKSArIGR0KTtcbiAgICAgIHRoaXMuZml4ZWRUaW1lICs9IGR0O1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5maWx0ZXIoKGNoaWxkKSA9PiAhY2hpbGQuY2FuY2VsZWQpO1xuICB9XG4gIHNwYXduKGNoaWxkKSB7XG4gICAgaWYgKCFpc1RocmVhZEdlbmVyYXRvcihjaGlsZCkpIHtcbiAgICAgIGNoaWxkID0gY2hpbGQoKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbiAgYWRkKGNoaWxkKSB7XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICBjaGlsZC5pc0NhbmNlbGVkID0gZmFsc2U7XG4gICAgY2hpbGQudGltZSh0aGlzLnRpbWUoKSk7XG4gICAgY2hpbGQuZml4ZWRUaW1lID0gdGhpcy5maXhlZFRpbWU7XG4gICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICBzZXRUYXNrTmFtZShjaGlsZC5ydW5uZXIsIGB1bmtub3duICR7dGhpcy5jaGlsZHJlbi5sZW5ndGh9YCk7XG4gIH1cbiAgZHJhaW4oY2FsbGJhY2spIHtcbiAgICB0aGlzLnF1ZXVlLmZvckVhY2goY2FsbGJhY2spO1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5ydW5uZXIucmV0dXJuKCk7XG4gICAgdGhpcy5pc0NhbmNlbGVkID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5kcmFpbigodGFzaykgPT4gdGFzay5yZXR1cm4oKSk7XG4gIH1cbiAgcGF1c2UodmFsdWUpIHtcbiAgICB0aGlzLmlzUGF1c2VkID0gdmFsdWU7XG4gIH1cbn07XG5kZWNvcmF0ZSh0aHJlYWRzLCB0aHJlYWRhYmxlKCkpO1xuZnVuY3Rpb24qIHRocmVhZHMoZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgY29uc3QgcGxheWJhY2sgPSB1c2VQbGF5YmFjaygpO1xuICBjb25zdCByb290ID0gZmFjdG9yeSgpO1xuICBzZXRUYXNrTmFtZShyb290LCBcInJvb3RcIik7XG4gIGNvbnN0IHJvb3RUaHJlYWQgPSBuZXcgVGhyZWFkKHJvb3QpO1xuICBjYWxsYmFjayA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2socm9vdFRocmVhZCk7XG4gIGxldCB0aHJlYWRzMiA9IFtyb290VGhyZWFkXTtcbiAgd2hpbGUgKHRocmVhZHMyLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBuZXdUaHJlYWRzID0gW107XG4gICAgY29uc3QgcXVldWUgPSBbLi4udGhyZWFkczJdO1xuICAgIGNvbnN0IGR0ID0gcGxheWJhY2suZGVsdGFUaW1lO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0aHJlYWQgPSBxdWV1ZS5wb3AoKTtcbiAgICAgIGlmICghdGhyZWFkIHx8IHRocmVhZC5jYW5jZWxlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRocmVhZC5uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgdGhyZWFkLmNhbmNlbCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RocmVhZEdlbmVyYXRvcihyZXN1bHQudmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbmV3IFRocmVhZChyZXN1bHQudmFsdWUpO1xuICAgICAgICB0aHJlYWQudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHRocmVhZC5hZGQoY2hpbGQpO1xuICAgICAgICBxdWV1ZS5wdXNoKHRocmVhZCk7XG4gICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHQudmFsdWUpIHtcbiAgICAgICAgdGhyZWFkLnZhbHVlID0geWllbGQgcmVzdWx0LnZhbHVlO1xuICAgICAgICBxdWV1ZS5wdXNoKHRocmVhZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJlYWQudXBkYXRlKGR0KTtcbiAgICAgICAgdGhyZWFkLmRyYWluKCh0YXNrKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgVGhyZWFkKHRhc2spO1xuICAgICAgICAgIHRocmVhZC5hZGQoY2hpbGQpO1xuICAgICAgICAgIG5ld1RocmVhZHMudW5zaGlmdChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBuZXdUaHJlYWRzLnVuc2hpZnQodGhyZWFkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyZWFkczIgPSBuZXdUaHJlYWRzLmZpbHRlcigodGhyZWFkKSA9PiAhdGhyZWFkLmNhbmNlbGVkKTtcbiAgICBpZiAodGhyZWFkczIubGVuZ3RoID4gMCkgeWllbGQ7XG4gIH1cbn1cbnZhciBzdHlsZXNOZXcgPSBgXG4ub3ZlcmxheSB7XG5cdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0bGVmdDogMDtcblx0cmlnaHQ6IDA7XG5cdHRvcDogMDtcblx0Ym90dG9tOiAwO1xuXHRkaXNwbGF5OiBmbGV4O1xuXHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblx0b3BhY2l0eTogMDtcblx0dHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzO1xuXHR6LWluZGV4OiAwO1xuICB9XG4gIC5jYW52YXMge1xuXHR3aWR0aDogMTAwJTtcblx0aGVpZ2h0OiAxMDAlO1xuXHRkaXNwbGF5OiBibG9jaztcblx0b3BhY2l0eTogMTtcblx0dHJhbnNpdGlvbjogb3BhY2l0eSAwLjFzO1xuICB9XG5gO1xudmFyIFRFTVBMQVRFID0gYDxzdHlsZT4ke3N0eWxlc05ld308L3N0eWxlPjxkaXYgY2xhc3M9XCJvdmVybGF5XCI+PC9kaXY+YDtcbnZhciBJRCA9IFwidHdpY2stcGxheWVyXCI7XG52YXIgVHdpY2tQbGF5ZXIgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicm9vdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2FudmFzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJvdmVybGF5XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGF0ZVwiLCBcImluaXRpYWxcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2plY3RcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBsYXllclwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGVmYXVsdFNldHRpbmdzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhYm9ydENvbnRyb2xsZXJcIiwgbnVsbCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBsYXlpbmdcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdGFnZVwiLCBuZXcgU3RhZ2UoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRpbWVcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImR1cmF0aW9uXCIsIDApO1xuICAgIC8vIGluIGZyYW1lc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb29waW5nXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ2b2x1bWVcIiwgMSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInZvbHVtZUNoYW5nZVJlcXVlc3RlZFwiLCB0cnVlKTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgdGhlIHRpbWVsaW5lLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVTZWVrVG9cIiwgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXRoaXMucHJvamVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlMiA9IGV2ZW50O1xuICAgICAgdGhpcy50aW1lID0gZTIuZGV0YWlsO1xuICAgICAgKF9hID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZXF1ZXN0U2VlayhlMi5kZXRhaWwgKiB0aGlzLnBsYXllci5wbGF5YmFjay5mcHMpO1xuICAgICAgdGhpcy52b2x1bWVDaGFuZ2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVWb2x1bWVDaGFuZ2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXRoaXMucHJvamVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlMiA9IGV2ZW50O1xuICAgICAgdGhpcy52b2x1bWUgPSBlMi5kZXRhaWw7XG4gICAgICAoX2EgPSB0aGlzLnBsYXllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBsYXliYWNrLmN1cnJlbnRTY2VuZS5hZGp1c3RWb2x1bWUodGhpcy52b2x1bWUpO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSB0aGUgcGxheWVyLlxuICAgICAqL1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoYW5kbGVGcmFtZUNoYW5nZWRcIiwgKGZyYW1lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoIXRoaXMucHJvamVjdCB8fCAhdGhpcy5wbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50aW1lID0gZnJhbWUgLyB0aGlzLnBsYXllci5wbGF5YmFjay5mcHM7XG4gICAgICBpZiAodGhpcy52b2x1bWVDaGFuZ2VSZXF1ZXN0ZWQgfHwgZnJhbWUgPT09IDApIHtcbiAgICAgICAgKF9hID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5wbGF5YmFjay5jdXJyZW50U2NlbmUuYWRqdXN0Vm9sdW1lKHRoaXMudm9sdW1lKTtcbiAgICAgICAgdGhpcy52b2x1bWVDaGFuZ2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gZXZlcnkgZnJhbWUuXG4gICAgICovXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlbmRlclwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5wbGF5ZXIgJiYgdGhpcy5wcm9qZWN0KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RhZ2UucmVuZGVyKFxuICAgICAgICAgIHRoaXMucGxheWVyLnBsYXliYWNrLmN1cnJlbnRTY2VuZSxcbiAgICAgICAgICB0aGlzLnBsYXllci5wbGF5YmFjay5wcmV2aW91c1NjZW5lXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJ0aW1ldXBkYXRlXCIsIHsgZGV0YWlsOiB0aGlzLnRpbWUgfSkpO1xuICAgICAgICBjb25zdCBkdXJhdGlvbkluRnJhbWVzID0gdGhpcy5wbGF5ZXIucGxheWJhY2suZHVyYXRpb247XG4gICAgICAgIGlmIChkdXJhdGlvbkluRnJhbWVzID09PSB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbkluRnJhbWVzO1xuICAgICAgICBjb25zdCBkdXJhdGlvbkluU2Vjb25kcyA9IGR1cmF0aW9uSW5GcmFtZXMgLyB0aGlzLnBsYXllci5wbGF5YmFjay5mcHM7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoXCJkdXJhdGlvblwiLCB7IGRldGFpbDogZHVyYXRpb25JblNlY29uZHMgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgIHRoaXMucm9vdC5pbm5lckhUTUwgPSBURU1QTEFURTtcbiAgICB0aGlzLm92ZXJsYXkgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihcIi5vdmVybGF5XCIpO1xuICAgIHRoaXMuY2FudmFzID0gdGhpcy5zdGFnZS5maW5hbEJ1ZmZlcjtcbiAgICB0aGlzLmNhbnZhcy5jbGFzc0xpc3QuYWRkKFwiY2FudmFzXCIpO1xuICAgIHRoaXMucm9vdC5wcmVwZW5kKHRoaXMuY2FudmFzKTtcbiAgICB0aGlzLnNldFN0YXRlKFxuICAgICAgXCJpbml0aWFsXCJcbiAgICAgIC8qIEluaXRpYWwgKi9cbiAgICApO1xuICB9XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXG4gICAgICBcInBsYXlpbmdcIixcbiAgICAgIFwidmFyaWFibGVzXCIsXG4gICAgICBcImxvb3BpbmdcIixcbiAgICAgIFwiZnBzXCIsXG4gICAgICBcInF1YWxpdHlcIixcbiAgICAgIFwid2lkdGhcIixcbiAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICBcInZvbHVtZVwiXG4gICAgXTtcbiAgfVxuICBnZXQgZnBzKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJmcHNcIik7XG4gICAgcmV0dXJuIGF0dHIgPyBwYXJzZUZsb2F0KGF0dHIpIDogKChfYSA9IHRoaXMuZGVmYXVsdFNldHRpbmdzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZnBzKSA/PyA2MDtcbiAgfVxuICBnZXQgcXVhbGl0eSgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKFwicXVhbGl0eVwiKTtcbiAgICByZXR1cm4gYXR0ciA/IHBhcnNlRmxvYXQoYXR0cikgOiAoKF9hID0gdGhpcy5kZWZhdWx0U2V0dGluZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZXNvbHV0aW9uU2NhbGUpID8/IDE7XG4gIH1cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKTtcbiAgICByZXR1cm4gYXR0ciA/IHBhcnNlRmxvYXQoYXR0cikgOiAoKF9hID0gdGhpcy5kZWZhdWx0U2V0dGluZ3MpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaXplLndpZHRoKSA/PyAwO1xuICB9XG4gIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG4gICAgcmV0dXJuIGF0dHIgPyBwYXJzZUZsb2F0KGF0dHIpIDogKChfYSA9IHRoaXMuZGVmYXVsdFNldHRpbmdzKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2l6ZS5oZWlnaHQpID8/IDA7XG4gIH1cbiAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHZhcmlhYmxlcygpIHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShcInZhcmlhYmxlc1wiKTtcbiAgICAgIHJldHVybiBhdHRyID8gSlNPTi5wYXJzZShhdHRyKSA6IHt9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgKF9hID0gdGhpcy5wcm9qZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EubG9nZ2VyLndhcm4oYFByb2plY3QgdmFyaWFibGVzIGNvdWxkIG5vdCBiZSBwYXJzZWQuYCk7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XG4gIHNldFByb2plY3QocHJvamVjdCkge1xuICAgIHRoaXMudXBkYXRlUHJvamVjdChwcm9qZWN0KTtcbiAgfVxuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLnNldFBsYXlpbmcodGhpcy5wbGF5aW5nKTtcbiAgfVxuICBzZXRQbGF5aW5nKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJyZWFkeVwiICYmIHZhbHVlKSB7XG4gICAgICAoX2EgPSB0aGlzLnBsYXllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvZ2dsZVBsYXliYWNrKHRydWUpO1xuICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgKF9iID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b2dnbGVQbGF5YmFjayhmYWxzZSk7XG4gICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBwbGF5aW5nID0gdGhpcy5wbGF5aW5nO1xuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICBcImluaXRpYWxcIlxuICAgICAgLyogSW5pdGlhbCAqL1xuICAgICk7XG4gICAgKF9hID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5hYm9ydCgpO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgdGhpcy5kZWZhdWx0U2V0dGluZ3MgPSBnZXRGdWxsUHJldmlld1NldHRpbmdzKHRoaXMucHJvamVjdCk7XG4gICAgY29uc3QgcGxheWVyID0gbmV3IFBsYXllcih0aGlzLnByb2plY3QpO1xuICAgIHBsYXllci5zZXRWYXJpYWJsZXModGhpcy52YXJpYWJsZXMpO1xuICAgIHBsYXllci50b2dnbGVMb29wKHRoaXMubG9vcGluZyk7XG4gICAgKF9iID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vblJlbmRlci51bnN1YnNjcmliZSh0aGlzLnJlbmRlcik7XG4gICAgKF9jID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYy5vbkZyYW1lQ2hhbmdlZC51bnN1YnNjcmliZSh0aGlzLmhhbmRsZUZyYW1lQ2hhbmdlZCk7XG4gICAgKF9kID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfZC50b2dnbGVQbGF5YmFjayhmYWxzZSk7XG4gICAgKF9lID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfZS5kZWFjdGl2YXRlKCk7XG4gICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG4gICAgdGhpcy51cGRhdGVTZXR0aW5ncygpO1xuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICBcInJlYWR5XCJcbiAgICAgIC8qIFJlYWR5ICovXG4gICAgKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicGxheWVycmVhZHlcIiwgeyBkZXRhaWw6IHRoaXMucGxheWVyIH0pKTtcbiAgICB0aGlzLnNldFBsYXlpbmcocGxheWluZyk7XG4gICAgdGhpcy5wbGF5ZXIub25SZW5kZXIuc3Vic2NyaWJlKHRoaXMucmVuZGVyKTtcbiAgICB0aGlzLnBsYXllci5vbkZyYW1lQ2hhbmdlZC5zdWJzY3JpYmUodGhpcy5oYW5kbGVGcmFtZUNoYW5nZWQpO1xuICB9XG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBfLCBuZXdWYWx1ZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJwbGF5aW5nXCI6XG4gICAgICAgIHRoaXMuc2V0UGxheWluZyhuZXdWYWx1ZSA9PT0gXCJ0cnVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ2YXJpYWJsZXNcIjpcbiAgICAgICAgKF9hID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zZXRWYXJpYWJsZXModGhpcy52YXJpYWJsZXMpO1xuICAgICAgICAoX2IgPSB0aGlzLnBsYXllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnJlcXVlc3RTZWVrKHRoaXMucGxheWVyLnBsYXliYWNrLmZyYW1lKTtcbiAgICAgICAgKF9jID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYy5wbGF5YmFjay5yZWxvYWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibG9vcGluZ1wiOlxuICAgICAgICB0aGlzLmxvb3BpbmcgPSBuZXdWYWx1ZSA9PT0gXCJ0cnVlXCI7XG4gICAgICAgIChfZCA9IHRoaXMucGxheWVyKSA9PSBudWxsID8gdm9pZCAwIDogX2QudG9nZ2xlTG9vcChuZXdWYWx1ZSA9PT0gXCJ0cnVlXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmcHNcIjpcbiAgICAgIGNhc2UgXCJxdWFsaXR5XCI6XG4gICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgdGhpcy51cGRhdGVTZXR0aW5ncygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ2b2x1bWVcIjpcbiAgICAgICAgdGhpcy52b2x1bWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy52b2x1bWVDaGFuZ2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUnVucyB3aGVuIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NLlxuICAgKi9cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAoX2EgPSB0aGlzLnBsYXllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlYWN0aXZhdGUoKTtcbiAgICAoX2IgPSB0aGlzLnBsYXllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm9uUmVuZGVyLnVuc3Vic2NyaWJlKHRoaXMucmVuZGVyKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWVrdG9cIiwgdGhpcy5oYW5kbGVTZWVrVG8pO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZvbHVtZWNoYW5nZVwiLCB0aGlzLmhhbmRsZVZvbHVtZUNoYW5nZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1bnMgd2hlbiB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgRE9NLlxuICAgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAoX2EgPSB0aGlzLnBsYXllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFjdGl2YXRlKCk7XG4gICAgKF9iID0gdGhpcy5wbGF5ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vblJlbmRlci5zdWJzY3JpYmUodGhpcy5yZW5kZXIpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInNlZWt0b1wiLCB0aGlzLmhhbmRsZVNlZWtUbyk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwidm9sdW1lY2hhbmdlXCIsIHRoaXMuaGFuZGxlVm9sdW1lQ2hhbmdlKTtcbiAgfVxuICB1cGRhdGVTZXR0aW5ncygpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLmRlZmF1bHRTZXR0aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHV0aW9uU2NhbGUgPSBOdW1iZXIuaXNGaW5pdGUodGhpcy5xdWFsaXR5KSAmJiB0aGlzLnF1YWxpdHkgPiAwID8gdGhpcy5xdWFsaXR5IDogdGhpcy5kZWZhdWx0U2V0dGluZ3MucmVzb2x1dGlvblNjYWxlID8/IDE7XG4gICAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgICAuLi50aGlzLmRlZmF1bHRTZXR0aW5ncyxcbiAgICAgIHNpemU6IG5ldyBWZWN0b3IyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSxcbiAgICAgIHJlc29sdXRpb25TY2FsZSxcbiAgICAgIGZwczogdGhpcy5mcHNcbiAgICB9O1xuICAgIHRoaXMuc3RhZ2UuY29uZmlndXJlKHNldHRpbmdzKTtcbiAgICAoX2EgPSB0aGlzLnBsYXllcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbmZpZ3VyZShzZXR0aW5ncyk7XG4gIH1cbn07XG5pZiAoIWN1c3RvbUVsZW1lbnRzLmdldChJRCkpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKElELCBUd2lja1BsYXllcik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC1LWUI1WlE1RS1CZTFabFpaZy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@twick/live-player/dist/internal-KYB5ZQ5E-Be1ZlZZg.mjs\n"));

/***/ })

}]);